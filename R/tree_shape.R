#' Integer representing shape of a tree
#'
#' Returns an integer that uniquely represents the _shape_ of an _n_-tip
#' binary tree, ignoring tip labels.
#'
#' Rooted trees are numbered working up from the root.
#'
#' The root node divides _n_ tips into two subtrees.  The smaller subtree
#' may contain $a = 1, 2, ..., n/2$ tips, leaving $b = n - a$ tips in
#' These options are worked through in turn.
#'
#' For the first shape of the smaller subtree, work through each possible shape
#' for the larger subtree.  Then, move to the next shape of the smaller subtree,
#' and work through each possible shape of the larger subtree.
#'
#' Stop when the desired topology is encountered.
#'
#' Unrooted trees are numbered less elegantly.  Each cherry (i.e. node
#' subtending a pair of tips) is treated in turn.  The subtended tips are
#' removed, and the node treated as the root of a rooted tree.  The number of
#' this rooted tree is then calculated.  The tree is assigned a _key_
#' corresponding to the lowest such value.  The keys of all unrooted tree shapes
#' on _n_ tips are ranked, and the unrooted tree shape is assigned a _number_
#' based on the rank order of its key among all possible keys, counting from
#' zero.
#'
#' @template treeParam
#'
#' @return `TreeShape` returns an integer specifying the shape of a tree,
#' ignoring tip labels.
#'
#' @template MRS
#' @name TreeShape
#' @export
RootedTreeShape <- function (tree) {
  edge <- tree$edge
  nTip <- NTip(tree)
  edge <- PostorderEdges(edge[, 1], edge[, 2], nTip = nTip)

  edge_to_rooted_shape(edge[[1]], edge[[2]], nTip)
}

#' @rdname TreeShape
#' @param shape Integer specifying shape of tree, perhaps generated by
#'  `TreeShape`.
#' @param nTip Integer specifying number of tips.
#' @return `TreeWithShape` returns a tree of class `phylo` corresponding to the
#' shape provided.  Tips are unlabelled.
#' @export
RootedTreeWithShape <- function (shape, nTip) {
  structure(list(edge = rooted_shape_to_edge(shape, nTip),
                 Nnode = nTip - 1,
                 tip.label = rep('', nTip)),
            class = 'phylo')
}

#' @rdname TreeShape
#' @export
UnrootedTreeWithShape <- function (shape, nTip) {
  AddRoot <- function (x) {
    x$root.edge <- 1L
    x
  }
  SingleTaxonTree('') + SingleTaxonTree('') +
    AddRoot(RootedTreeWithShape(UnrootedShapes(nTip)[shape + 1L], nTip - 2L))
}

#' @rdname TreeShape
#' @importFrom ape drop.tip root
#' @export
UnrootedTreeShape <- function (tree) {
  which(UnrootedShapes(NTip(tree)) == UnrootedTreeKey(tree)) - 1L
}

#' @rdname TreeShape
#' @importFrom ape drop.tip root
#' @export
UnrootedTreeKey <- function (tree) {
  tree <- Postorder(Preorder(tree))
  edge <- tree$edge
  nTip <- NTip(tree)
  parent <- edge[, 1]
  child <- edge[, 2]
  nEdge <- length(child)
  unrooted <- nEdge %% 2L
  nodeFirst <- c(rep(c(TRUE, FALSE), nEdge / 2L), logical(as.integer(unrooted)))
  nodeSecond <- !nodeFirst
  nodeNumbers <- unique(parent)
  if (unrooted) {
    nodeFirst [nEdge - 0:2] <- FALSE
    nodeSecond[nEdge - 0:2] <- FALSE
    nodeNumbers <- nodeNumbers[-(nTip - 2L)]
  }

  RootedNumber <- function (nodeChildren) {
    RootedTreeShape(Postorder(drop.tip(root(tree, nodeChildren[1]), nodeChildren)))
  }

  basalTipEdges <- nEdge - (seq_len(4L - unrooted) - 1L)
  rootCandidate <- if (sum(child[basalTipEdges] <= nTip) == 2) {
    RootedNumber(child[basalTipEdges][child[basalTipEdges] <= nTip])
  } else {
    double(0)
  }

  cherryNodes <- nodeNumbers[child[nodeFirst] <= nTip & child[nodeSecond] <= nTip]
  allKeys <- c(vapply(cherryNodes, function (node) {
    RootedNumber(child[parent == node])
  }, double(1)), rootCandidate)

  # Return:
  min(allKeys)
}

#' @rdname TreeShape
#' @return `TreeShapes` returns an integer specifying the number of unique
#' unrooted tree shapes with `nTip` tips.
#' @importFrom memoise memoise
#' @export
UnrootedShapes <- memoise(function (nTip) {
  if (nTip > 5) {
    #TODO make efficient - this is horrible!
    shapes <- vapply(seq_len(NRootedShapes(nTip)) - 1L, function (shape)
      UnrootedTreeKey(RootedTreeWithShape(shape, nTip)), double(1))
    uniqueShapes <- unique(shapes)
  } else {
    uniqueShapes <- 0
  }

  # Return:
  sort(uniqueShapes)
})

#' @rdname TreeShape
#' @return `TreeShapes` returns an integer specifying the number of unique
#' unrooted tree shapes with `nTip` tips.
#' @export
NUnrootedShapes <- function (nTip) {
  length(UnrootedShapes(nTip))
}

#' @rdname TreeShape
#' @return `RootedTreeShapes` returns an integer specifying the number of unique
#' rooted tree shapes with `nTip` tips.
#' @export
NRootedShapes <- function (nTip) {
  n_rooted_shapes(as.integer(nTip))
}
