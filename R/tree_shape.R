#' Integer representing shape of a tree
#'
#' Returns an integer that uniquely represents the _shape_ of an _n_-tip
#' binary tree, ignoring tip labels.
#'
#' Rooted trees are numbered working up from the root.
#'
#' The root node divides _n_ tips into two subtrees.  The smaller subtree
#' may contain $a = 1, 2, ..., n/2$ tips, leaving $b = n - a$ tips in
#' These options are worked through in turn.
#'
#' For the first shape of the smaller subtree, work through each possible shape
#' for the larger subtree.  Then, move to the next shape of the smaller subtree,
#' and work through each possible shape of the larger subtree.
#'
#' Stop when the desired topology is encountered.
#'
#' @template treeParam
#'
#' @return `TreeShape` returns an integer specifying the shape of a tree,
#' ignoring tip labels.
#'
#' @template MRS
#' @name TreeShape
#' @export
RootedTreeShape <- function (tree) {
  edge <- tree$edge
  nTip <- NTip(tree)
  edge <- PostorderEdges(edge[, 1], edge[, 2], nTip = nTip)

  edge_to_rooted_shape(edge[[1]], edge[[2]], nTip)

}

#' @rdname TreeShape
#' @param shape Integer specifying shape of tree, perhaps generated by
#'  `TreeShape`.
#' @param nTip Integer specifying number of tips.
#' @return `TreeWithShape` returns a tree of class `phylo` corresponding to the
#' shape provided.  Tips are unlabelled.
#' @export
RootedTreeWithShape <- function (shape, nTip) {
  structure(list(edge = rooted_shape_to_edge(shape, nTip),
                 Nnode = nTip - 1,
                 tip.label = rep('', nTip)),
            class = 'phylo')
}

#' @rdname TreeShape
#' @export
UnrootedTreeWithShape <- function (shape, nTip) {
  AddRoot <- function (x) {
    x$root.edge <- 1L
    x
  }
  SingleTaxonTree('') + SingleTaxonTree('') +
    AddRoot(RootedTreeWithShape(shape, nTip - 2L))
}

#' @rdname TreeShape
#' @importFrom ape drop.tip root
#' @export
UnrootedTreeShape <- function (tree) {
  tree <- Postorder(tree)
  edge <- tree$edge
  nTip <- NTip(tree)
  parent <- edge[, 1]
  child <- edge[, 2]
  nEdge <- length(child)
  nodeFirst <- rep(c(TRUE, FALSE), nEdge / 2L)
  nodeSecond <- !nodeFirst
  nodeNumbers <- unique(parent)

  RootedNumber <- function (nodeChildren) {
    RootedTreeShape(Postorder(drop.tip(root(tree, nodeChildren), nodeChildren)))
  }

  rootCandidate <- if (sum(child[nEdge - 0:3] <= nTip) == 2) {
    RootedNumber(child[nEdge - 0:3][child[nEdge - 0:3] <= nTip])
  } else double(0)


  cherryNodes <- nodeNumbers[child[nodeFirst] <= nTip & child[nodeSecond] <= nTip]

  # Return:
  min(vapply(cherryNodes, function (node) {
    cat(child[parent == node])
    RootedNumber(child[parent == node])
  }, double(1)), rootCandidate)
}

#' @rdname TreeShape
#' @return `TreeShapes` returns an integer specifying the number of unique
#' unrooted tree shapes with `nTip` tips.
#' @export
NUnrootedShapes <- function (nTip) {
  #TODO make efficient - this is horrible!
  uniqueShapes <- unique(vapply(seq_len(NRootedShapes(nTip)) - 1L, function (shape)
    UnrootedTreeShape(RootedTreeWithShape(shape, nTip)), double(1)))
  if (max(uniqueShapes) + 1 != length(uniqueShapes)) {
    warning("Holey numbers")
  }

  # Return:
  length(uniqueShapes)
}

#' @rdname TreeShape
#' @return `RootedTreeShapes` returns an integer specifying the number of unique
#' rooted tree shapes with `nTip` tips.
#' @export
NRootedShapes <- function (nTip) {
  n_rooted_shapes(as.integer(nTip))
}
