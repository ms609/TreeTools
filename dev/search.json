[{"path":"https://ms609.github.io/TreeTools/dev/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (https://www.contributor-covenant.org), version 1.0.0, available https://contributor-covenant.org/version/1/0/0/.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"CONTRIBUTING","text":"Small typos grammatical errors documentation may edited directly using GitHub web interface, long changes made source file. : edit roxygen comment .R file R/. DON’T: edit .Rd file man/.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/CONTRIBUTING.html","id":"prerequisites","dir":"","previous_headings":"","what":"Prerequisites","title":"CONTRIBUTING","text":"make substantial pull request, always file issue make sure someone team agrees ’s problem. ’ve found bug, create associated issue illustrate bug minimal reprex.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"","what":"Pull request process","title":"CONTRIBUTING","text":"recommend create Git branch pull request (PR). Look GitHub actions CodeCovr build status making changes. follow Google’s R style guide use camelCase variable names, TitleCase function names. use Oxford ending ‘ize’ (‘ise’), UK spelling (e.g. ‘colour’) possible avoid distinction (e.g. shortening ‘col’) use roxygen2 build documentation. use testthat. Contributions test cases included easier accept. use semantic versioning. user-facing changes, add bullet top NEWS.md current development version header describing changes made followed GitHub username, links relevant issue(s)/PR(s).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/CONTRIBUTING.html","id":"contributor-license-agreement","dir":"","previous_headings":"","what":"Contributor license agreement","title":"CONTRIBUTING","text":"Contributors agree reassign copyright contributions maintainers package.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"CONTRIBUTING","text":"Please note project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/CONTRIBUTING.html","id":"prefer-to-e-mail","dir":"","previous_headings":"","what":"Prefer to e-mail?","title":"CONTRIBUTING","text":"E-mail person listed maintainer DESCRIPTION file repo. Private discussions email don’t help others - course email totally warranted sensitive problems.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/CONTRIBUTING.html","id":"thanks-for-contributing","dir":"","previous_headings":"","what":"Thanks for contributing!","title":"CONTRIBUTING","text":"document adapted tidyverse contributing guide.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/articles/filesystem-navigation.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"File system navigation in R","text":"Now know locate files, might want load dataset phylogenetic tree R.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-data.html","id":"from-an-excel-spreadsheet","dir":"Articles","previous_headings":"Load raw data","what":"From an Excel spreadsheet","title":"Loading phylogenetic data into R","text":"data Excel spreadsheet, one way load R using ‘readxl’ package. First ’ll install : prepare Excel spreadsheet row corresponds taxon, column character. can read data Excel file telling R sheet, rows columns contain data:","code":"install.packages(\"readxl\") # You only need to do this once library(\"readxl\") raw_data <- as.matrix(read_excel(   filename,   sheet = 1,           # Loads sheet number 1 from the excel file   range = \"B1:AA21\",   # Extracts columns B to AA, rows 1 to 21   # Note that the first row is interpreted as column (character) names   col_types = \"text\"   # Read all columns as character strings ))  # Read row (taxon) names from column A # Again, the first cell will be interpreted as a column name taxon_names <- unlist(read_excel(filename, sheet = 1, range = \"A1:A21\"))  rownames(raw_data) <- taxon_names"},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-data.html","id":"from-a-text-or-csv-comma-separated-values-file","dir":"Articles","previous_headings":"Load raw data","what":"From a text or CSV (comma separated values) file","title":"Loading phylogenetic data into R","text":"Characters can read text file similar manner Excel. may need adjust R commands match particular format input file.","code":"raw_data <- read.table(   filename,            # Path to your input file   sep = \",\",           # What character separates columns?   header = TRUE,       # Does the data contain a header row?   row.names = 1,       # Which column contains the row names?   na.strings = \"\",    stringsAsFactors = FALSE )"},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-data.html","id":"from-a-nexus-file","dir":"Articles","previous_headings":"Load raw data","what":"From a Nexus file","title":"Loading phylogenetic data into R","text":"TreeTools contains inbuilt Nexus parser: extract character names codings dataset. ’s written work datasets downloaded MorphoBank, aim function handle valid (many invalid) NEXUS files. find file function can’t handle, please let know ’ll try fix . meantime, alternative Nexus parsers available: try Non-standard elements Nexus file might beyond capabilities ape’s parser. particular, need replace spaces taxon names underscore, arrange data single block starting BEGIN DATA. ’ll need strip comments, character definitions separate taxon blocks. function readNexus package phylobase uses NCL library promises powerful, ’ve able get work.","code":"raw_data <- ReadCharacters(filename) # Or, to go straight to PhyDat format: as_phydat <- ReadAsPhyDat(filename) raw_data <- ape::read.nexus.data(filename)"},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-data.html","id":"from-a-tnt-file","dir":"Articles","previous_headings":"Load raw data","what":"From a TNT file","title":"Loading phylogenetic data into R","text":"TNT format dataset downloaded MorphoBank can parsed ReadTntCharacters, might also handle TNT-compatible files. ’s file ’s read correctly, please let know ’ll try fix .","code":"raw_data <- ReadTntCharacters(filename) # Or, to go straight to PhyDat format: my_data <- ReadTntAsPhyDat(filename)"},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-data.html","id":"processing-raw-data","dir":"Articles","previous_headings":"","what":"Processing raw data","title":"Loading phylogenetic data into R","text":"Next, need raw data R-friendly phyDat format. ’ve used ReadAsPhyDat ReadTntAsPhyDat functions, can skip step – ’re already . Otherwise, can try doesn’t work, functions pretty robust, might return error encounter unexpected dataset format – don’t work dataset, pleaselet know. Failing , can enlist help ‘phangorn’ package: type=\"USER\" tells parser expect morphological data. levels parameter simply lists states character might take. 0:9 includes integer digits 0 9. inapplicable data matrix, list - separate level represents additional state (handled Morphy implementation (Brazeau, Guillerme, & Smith, 2019)). complicated ambiguities, may need use contrast matrix decode matrix. contrast matrix translates tokens used dataset character states correspond: example decoding ‘’ {01}. details, see ‘phangorn-specials’ vignette phangorn package, accessible typing ‘?phangorn’ R prompt navigating index > package vignettes. need use contrast matrix, convert data using","code":"my_data <- PhyDat(raw_data) my_data <- MatrixToPhyDat(raw_data) install.packages(\"phangorn\") library(\"phangorn\") my_data <- phyDat(raw_data, type = \"USER\", levels = c(0:9, \"-\")) contrast.matrix <- matrix(data = c( # 0 1 -  # Each column corresponds to a character-state   1, 0, 0, # Each row corresponds to a token, here 0, denoting the             # character-state set {0}    0, 1, 0, # 1 | {1}   0, 0, 1, # - | {-}   1, 1, 0, # A | {01}   1, 1, 0, # + | {01}   1, 1, 1  # ? | {01-} ), ncol = 3, # ncol corresponds to the number of columns in the matrix byrow = TRUE) dimnames(contrast.matrix) <- list(   c(0, 1, \"-\", \"A\", \"+\", \"?\"), # A list of the tokens corresponding to each row                                # in the contrast matrix   c(0, 1, \"-\") # A list of the character-states corresponding to the columns                 # in the contrast matrix )  contrast.matrix ##   0 1 - ## 0 1 0 0 ## 1 0 1 0 ## - 0 0 1 ## A 1 1 0 ## + 1 1 0 ## ? 1 1 1 my.phyDat <- phyDat(my.data, type = \"USER\", contrast = contrast.matrix)"},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-data.html","id":"store-processed-data","dir":"Articles","previous_headings":"","what":"Store processed data","title":"Loading phylogenetic data into R","text":"simplify subsequent analysis, allow data read contexts (e.g. via TreeSearch::EasyTrees() interface), save processed data Nexus format:","code":"ape::write.nexus.data(my.phyDat, \"my_data.nex\", format = \"standard\")"},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-data.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Loading phylogenetic data into R","text":"might want : Load phylogenetic tree R. Conduct parsimony search using Brazeau, Guillerme & Smith’s (2019) approach inapplicable data, using Profile parsimony (Faith & Trueman, 2001).","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-trees.html","id":"manual-entry","dir":"Articles","previous_headings":"","what":"Manual entry","title":"Loading phylogenetic trees into R","text":"straightforward, cumbersome, way enter trees R manual text entry:  Beware common gotchas entering text: Ensure tree string ends semi-colon. Make sure brackets matched. text editors, RStudio Notepad++, contain built-syntax highlighting highlight counterpart parenthesis type. Look ((double brackets)) brackets enclosing single node: resultant ‘invisible nodes’ can cause R crash.  text expected Newick format, can contain edge lengths - edge lengths must included every edge tree, ignored.","code":"myTree <- ape::read.tree(text = \"((A, B), ((C, D), (E, F)));\") plot(myTree) badTree <- ape::read.tree(text = \"((A, B), (((C, D), ((E), F))));\") plot(badTree) ape::nodelabels(bg = c(3, 3, 2, 2, 3, 3, 2)) myTree <- ape::read.tree(   text = \"((A:1, B:1):2, ((C:1, D:1):2, (E:1, F:1):2):4);\" ) plot(myTree)"},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-trees.html","id":"from-a-file","dir":"Articles","previous_headings":"","what":"From a file","title":"Loading phylogenetic trees into R","text":"First , make sure comfortable telling R find file.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-trees.html","id":"nexus-files","dir":"Articles","previous_headings":"From a file","what":"Nexus files","title":"Loading phylogenetic trees into R","text":"can load trees nexus file using: file contains multiple trees, return list trees file, class multiPhylo. single tree, returned tree class phylo unless option force.multiPhylo = TRUE. can useful unknown number trees processed bulk, example ","code":"filename <- \"my_file_name.nex\" ape::read.nexus(filename) lapply(ape::read.nexus(filename, force.multiPhylo = TRUE), ape::consensus)"},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-trees.html","id":"newick-files","dir":"Articles","previous_headings":"From a file","what":"Newick files","title":"Loading phylogenetic trees into R","text":"Newick trees can read ape::read.tree(filename); phytools::read.newick(filename) report error ‘node’ single descendant (often denote misspecified tree).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-trees.html","id":"trees-from-tnt","dir":"Articles","previous_headings":"From a file","what":"Trees from TNT","title":"Loading phylogenetic trees into R","text":"Trees saved using TNT can opened R using ReadTntTree(). Trees saved parenthetical format (TNT command tsav*), rather TNT’s compressed format (TNT command tsav). TNT command taxname= write taxon names file, results larger easier read files. Trees file read using terminal names saved within file. TNT command taxname- saves just numbers terminals. order trees reunited names tips, terminal labels read linked matrix file listed first line .tre file. Ensure file exists expected location. , use ReadTntTree(treeFile, relativePath = '../path//tipNameFile'), tipLabels manually specify names tips (e.g. ReadTntTree(treeFile, tipLabels = c('outgroup', letters[1:8])).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-trees.html","id":"other-formats","dir":"Articles","previous_headings":"From a file","what":"Other formats","title":"Loading phylogenetic trees into R","text":"formats listed ? Please let know opening issue.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-trees.html","id":"export-write-trees","dir":"Articles","previous_headings":"","what":"Export (write) trees","title":"Loading phylogenetic trees into R","text":"save tree text file, use ape::write.tree(tree, file='filename.txt') Newick format (widely supported phylogenetic software), ape::write.nexus(tree, file='filename.nex') Nexus format.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/articles/load-trees.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Loading phylogenetic trees into R","text":"might want : Load phylogenetic data R. Conduct parsimony search using Brazeau, Guillerme & Smith’s approach inapplicable data, using Profile parsimony. Calculate distances pairs trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin R. Smith. Author, maintainer, copyright holder. Emmanuel Paradis. Copyright holder. Robert Noble. Copyright holder.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith (2019). TreeTools: create, modify analyse phylogenetic trees. Comprehensive R Archive Network. doi: 10.32614/CRAN.package.TreeTools","code":"@Manual{Smith2019,   title = {TreeTools: create, modify and analyse phylogenetic trees},   author = {Martin R. Smith},   note = {R package version 1.15.0.9009},   year = {2019},   doi = {10.32614/CRAN.package.TreeTools},   organization = {Comprehensive R Archive Network}, }"},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":null,"dir":"","previous_headings":"","what":"TreeTools R Package Development","title":"TreeTools R Package Development","text":"TreeTools R package providing efficient implementations functions creation, modification analysis phylogenetic trees. includes C++ code performance, comprehensive testing 61+ test files, benchmarking infrastructure, extensive CI/CD workflows. Always reference instructions first fallback search bash commands encounter unexpected information match info .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"bootstrap-and-development-setup","dir":"","previous_headings":"Working Effectively","what":"Bootstrap and Development Setup","title":"TreeTools R Package Development","text":"Install R development tools: Install R development packages: Install TreeTools dependencies:","code":"sudo apt update && sudo apt install -y r-base r-base-dev build-essential sudo apt install -y libcurl4-openssl-dev libssl-dev libxml2-dev libfontconfig1-dev libharfbuzz-dev libfribidi-dev sudo R -e \"install.packages(c('devtools', 'testthat', 'roxygen2', 'lintr'), repos='https://cran.r-project.org/')\" sudo R -e \"install.packages(c('ape', 'bit64', 'lifecycle', 'colorspace', 'fastmatch', 'RCurl', 'R.cache', 'Rdpack', 'stringi', 'PlotTools'), repos='https://cran.r-project.org/', dependencies=TRUE)\""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"building-and-checking","dir":"","previous_headings":"Working Effectively","what":"Building and Checking","title":"TreeTools R Package Development","text":"NEVER CANCEL: R package builds can take 10-30+ minutes depending dependencies system performance. Set timeout 60+ minutes. Build package: NEVER CANCEL: Full R CMD check takes 15-45+ minutes. Set timeout 90+ minutes. Check package (full validation): Quick check (development, ~2-5 minutes):","code":"R CMD build . R CMD check TreeTools_*.tar.gz R CMD check --no-build-vignettes --no-manual ."},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"testing","dir":"","previous_headings":"Working Effectively","what":"Testing","title":"TreeTools R Package Development","text":"NEVER CANCEL: Test suite 61+ test files can take 10-30+ minutes. Set timeout 60+ minutes. Run tests: Run tests testthat directly: Run specific test file:","code":"R -e \"devtools::test()\" R -e \"testthat::test_dir('tests/testthat')\" R -e \"testthat::test_file('tests/testthat/test-tree_display.R')\""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"development-workflow-commands","dir":"","previous_headings":"Working Effectively","what":"Development Workflow Commands","title":"TreeTools R Package Development","text":"Load package development: Check code style (~1-2 minutes): Build documentation: NEVER CANCEL: Build vignettes takes 5-15+ minutes. Set timeout 30+ minutes. Build vignettes:","code":"R -e \"devtools::load_all()\" R -e \"lintr::lint_dir('.')\" R -e \"devtools::document()\" R -e \"devtools::build_vignettes(install = FALSE)\""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"validation","dir":"","previous_headings":"","what":"Validation","title":"TreeTools R Package Development","text":"Always run R CMD check complete validation finalizing changes. ALWAYS run full test suite modifying C++ code src/ directory. ALWAYS run lintr ensure code style compliance committing. performance-critical changes, run benchmarks benchmark/ directory: Memory checking available optional (takes significant time):","code":"R -e \"source('benchmark/_run_benchmarks.R')\" R -d \"valgrind --tool=memcheck --leak-check=full\" --vanilla < memcheck/tests.R"},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"validation-scenarios","dir":"","previous_headings":"","what":"Validation Scenarios","title":"TreeTools R Package Development","text":"making code changes, validate functionality testing core phylogenetic tree operations:","code":""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"test-tree-creation-and-manipulation","dir":"","previous_headings":"Validation Scenarios","what":"Test Tree Creation and Manipulation","title":"TreeTools R Package Development","text":"","code":"R -e \" library(TreeTools) # Test tree generation tree <- BalancedTree(8) print(tree) # Test tree manipulation   rooted <- RootTree(tree, 1) print(rooted) # Test tree properties splits <- TreeToSplits(tree) print(length(splits)) \""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"test-file-io-operations","dir":"","previous_headings":"Validation Scenarios","what":"Test File I/O Operations","title":"TreeTools R Package Development","text":"","code":"R -e \" library(TreeTools) # Create test tree tree <- PectinateTree(6) # Write to Newick format WriteNewick(tree, file='test_tree.nwk') # Read it back read_tree <- ReadNewick('test_tree.nwk') # Verify it matches identical(tree, read_tree) \""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"test-c-integration","dir":"","previous_headings":"Validation Scenarios","what":"Test C++ Integration","title":"TreeTools R Package Development","text":"","code":"R -e \" library(TreeTools) # Test C++ functions work correctly tree <- RandomTree(100) result <- PathLengths(tree) print(length(result))  # Should be 100x100 matrix \""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"time-expectations--critical-warnings","dir":"","previous_headings":"","what":"Time Expectations & Critical Warnings","title":"TreeTools R Package Development","text":"R startup: ~0.1 seconds Linting: 1-3 minutes full codebase Quick check (vignettes/manual): 2-5 minutes Documentation building: 2-5 minutes Test suite: 10-30+ minutes (NEVER CANCEL - set 60+ minute timeout) Full R CMD check: 15-45+ minutes (NEVER CANCEL - set 90+ minute timeout) Package build: 10-30+ minutes (NEVER CANCEL - set 60+ minute timeout) Vignette building: 5-15+ minutes (NEVER CANCEL - set 30+ minute timeout) Benchmarks: 5-20+ minutes (NEVER CANCEL - set 30+ minute timeout)","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"key-directories","dir":"","previous_headings":"Repository Structure","what":"Key Directories","title":"TreeTools R Package Development","text":"R/ - R source code (59 R files 500+ exported functions) src/ - C++ source code requiring compilation (17 C++ files, SystemRequirements: C++17) tests/testthat/ - Test suite (61+ test files) benchmark/ - Performance benchmarking (10+ benchmark files) man/ - Generated documentation (edit manually) vignettes/ - Package tutorials documentation data/ - Package data files .github/workflows/ - Extensive CI/CD R-CMD-check, benchmarks, memory checks","code":""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"important-files","dir":"","previous_headings":"Repository Structure","what":"Important Files","title":"TreeTools R Package Development","text":"DESCRIPTION - Package metadata, dependencies, system requirements NAMESPACE - Generated roxygen2 (edit manually) .lintr - Code style configuration (follows Google R style guide) NEWS.md - Version history (update user-facing changes) tests/testthat.R - Test runner entry point","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"after-making-changes","dir":"","previous_headings":"Common Tasks","what":"After Making Changes","title":"TreeTools R Package Development","text":"Load test changes interactively: Run linting: Run relevant tests: C++ changes, always run full check:","code":"R -e \"devtools::load_all(); # test your changes interactively\" R -e \"lintr::lint_dir('.')\" R -e \"devtools::test()\" R CMD check --no-build-vignettes ."},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"code-style-guidelines","dir":"","previous_headings":"Common Tasks","what":"Code Style Guidelines","title":"TreeTools R Package Development","text":"Follow Google’s R style guide Use camelCase variable names, TitleCase function names Use Oxford ending ‘ize’ (‘ise’) UK spelling applicable Document functions roxygen2 comments Include test cases new functionality","code":""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"ci-will-fail-if","dir":"","previous_headings":"Common Tasks","what":"CI Will Fail If","title":"TreeTools R Package Development","text":"R CMD check fails Tests fail Code style violations (lintr) Missing inadequate documentation Missing test coverage new code","code":""},{"path":"https://ms609.github.io/TreeTools/dev/copilot-instructions.html","id":"troubleshooting","dir":"","previous_headings":"","what":"Troubleshooting","title":"TreeTools R Package Development","text":"package won’t build: check system dependencies installed tests fail C++ changes: rebuild package completely documentation missing: run devtools::document() benchmarks fail: performance regressions may need investigation Memory issues: use valgrind checking C++ code validation","code":""},{"path":"https://ms609.github.io/TreeTools/dev/index.html","id":"treetools","dir":"","previous_headings":"","what":"Create, Modify and Analyse Phylogenetic Trees","title":"Create, Modify and Analyse Phylogenetic Trees","text":"‘TreeTools’ R package provides efficient implementations functions creation, modification analysis phylogenetic trees. Applications include: generation trees specified shapes; analysis tree shape; rooting trees extraction subtrees; calculation depiction node support; calculation ancestor-descendant relationships; import export trees Newick, Nexus TNT formats; analysis partitions cladistic information. complements packages ‘ape’, ‘phangorn’ ‘phytools’, aiming efficient robust implementations functions, typically applied unweighted trees (.e. without edge lengths).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Create, Modify and Analyse Phylogenetic Trees","text":"Install load library CRAN follows: Install latest version, may development, : Please note ‘TreeTools’ project released Contributor Code Conduct. contributing project, agree terms.","code":"install.packages(\"TreeTools\") library(\"TreeTools\") if (!require(\"devtools\")) install.packages(\"devtools\") devtools::install_github(\"ms609/TreeTools\")"},{"path":"https://ms609.github.io/TreeTools/dev/reference/AddTip.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a tip to a phylogenetic tree — AddTip","title":"Add a tip to a phylogenetic tree — AddTip","text":"AddTip() adds tip phylogenetic tree specified location.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/AddTip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a tip to a phylogenetic tree — AddTip","text":"","code":"AddTip(   tree,   where = sample.int(tree[[\"Nnode\"]] * 2 + 2L, size = 1) - 1L,   label = \"New tip\",   nodeLabel = \"\",   edgeLength = 0,   lengthBelow = NULL,   nTip = NTip(tree),   nNode = tree[[\"Nnode\"]],   rootNode = RootNode(tree) )  AddTipEverywhere(tree, label = \"New tip\", includeRoot = FALSE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/AddTip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a tip to a phylogenetic tree — AddTip","text":"tree tree class phylo. node tip form sister taxon new node.  add new tip root, use = 0.  default, new tip added random edge. label Character string providing label apply new tip. nodeLabel Character string providing label apply newly created node, tree$node.label specified. edgeLength Numeric specifying length new edge. NULL, defaults lengthBelow. become default behaviour future release; please manually specify desired behaviour code. lengthBelow Numeric specifying length neighbour graft new edge. Values greater length edge result negative edge lengths. NULL, default, new tip added midpoint broken edge. inserting root (= 0), new edge length lengthBelow inserted. NA, new leaf attached adjacent ; internal nodes, result polytomy. nTip, nNode, rootNode Optional integer vectors specifying number tips nodes tree, index root node. checked correctness: specifying values yields marginal speed increase cost code safety. includeRoot Logical; TRUE, position adjacent root edge considered represent distinct edges; FALSE, treated single edge.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/AddTip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a tip to a phylogenetic tree — AddTip","text":"AddTip() returns tree class phylo additional tip desired location. AddTipEverywhere() returns list class multiPhylo containing trees produced adding label edge tree turn.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/AddTip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a tip to a phylogenetic tree — AddTip","text":"AddTip() extends bind.tree, handle single-taxon trees. AddTipEverywhere() adds tip edge turn.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/AddTip.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add a tip to a phylogenetic tree — AddTip","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/AddTip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a tip to a phylogenetic tree — AddTip","text":"","code":"tree <- BalancedTree(10)  # Add a leaf below an internal node plot(tree) ape::nodelabels() # Identify node numbers  node <- 15        # Select location to add leaf ape::nodelabels(bg = ifelse(NodeNumbers(tree) == node, \"green\", \"grey\"))   plot(AddTip(tree, 15, \"NEW_TIP\"))   # Add edge lengths for an ultrametric tree tree$edge.length <- rep(c(rep(1, 5), 2, 1, 2, 2), 2)  # Add a leaf to an external edge leaf <- 5 plot(tree) ape::tiplabels(bg = ifelse(seq_len(NTip(tree)) == leaf, \"green\", \"grey\"))   plot(AddTip(tree, 5, \"NEW_TIP\", edgeLength = NULL))   # Create a polytomy, rather than a new node plot(AddTip(tree, 5, \"NEW_TIP\", edgeLength = NA)) #> Warning: 1 branch length(s) NA(s): branch lengths ignored in the plot   # Set up multi-panel plot oldPar <- par(mfrow = c(2, 4), mar = rep(0.3, 4), cex = 0.9)  # Add leaf to each edge on a tree in turn backbone <- BalancedTree(4) # Treating the position of the root as instructive: additions <- AddTipEverywhere(backbone, includeRoot = TRUE) xx <- lapply(additions, plot)  par(mfrow = c(2, 3))  # Don't treat root edges as distinct: additions <- AddTipEverywhere(backbone, includeRoot = FALSE) xx <- lapply(additions, plot)  # Restore original plotting parameters par(oldPar)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/AncestorEdge.html","id":null,"dir":"Reference","previous_headings":"","what":"Ancestral edge — AncestorEdge","title":"Ancestral edge — AncestorEdge","text":"Ancestral edge","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/AncestorEdge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ancestral edge — AncestorEdge","text":"","code":"AncestorEdge(edge, parent, child)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/AncestorEdge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ancestral edge — AncestorEdge","text":"edge Number edge parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 1] child Integer vector corresponding second column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 2].","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/AncestorEdge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ancestral edge — AncestorEdge","text":"AncestorEdge returns logical vector identifying whether edge immediate ancestor given edge.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/AncestorEdge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ancestral edge — AncestorEdge","text":"","code":"tree <- BalancedTree(6) parent <- tree$edge[, 1] child <- tree$edge[, 2] plot(tree) ape::edgelabels()  AncestorEdge(5, parent, child) #>  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE which(AncestorEdge(5, parent, child)) #> [1] 1"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ApeTime.html","id":null,"dir":"Reference","previous_headings":"","what":"Read modification time from ","title":"Read modification time from ","text":"ApeTime() reads time tree written \"ape\" modified, based comment Nexus file.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ApeTime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read modification time from ","text":"","code":"ApeTime(filepath, format = \"double\")"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ApeTime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read modification time from ","text":"filepath Character string specifying path file. format Format return time: \"double\" sortable numeric; value return string format YYYY-MM-DD hh:mm:ss.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ApeTime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read modification time from ","text":"ApeTime() returns time specified file created ape, format specified format.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ApeTime.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read modification time from ","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ArtificialExtinction.html","id":null,"dir":"Reference","previous_headings":"","what":"Artificial Extinction — ArtificialExtinction","title":"Artificial Extinction — ArtificialExtinction","text":"Remove tokens occur fossil \"template\" taxon living taxon, simulate process fossilization removing data phylogenetic dataset.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ArtificialExtinction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Artificial Extinction — ArtificialExtinction","text":"","code":"ArtificialExtinction(   dataset,   subject,   template,   replaceAmbiguous = \"ambig\",   replaceCoded = \"original\",   replaceAll = TRUE,   sampleFrom = NULL )  # S3 method for class 'matrix' ArtificialExtinction(   dataset,   subject,   template,   replaceAmbiguous = \"ambig\",   replaceCoded = \"original\",   replaceAll = TRUE,   sampleFrom = NULL )  # S3 method for class 'phyDat' ArtificialExtinction(   dataset,   subject,   template,   replaceAmbiguous = \"ambig\",   replaceCoded = \"original\",   replaceAll = TRUE,   sampleFrom = NULL )  ArtEx(   dataset,   subject,   template,   replaceAmbiguous = \"ambig\",   replaceCoded = \"original\",   replaceAll = TRUE,   sampleFrom = NULL )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ArtificialExtinction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Artificial Extinction — ArtificialExtinction","text":"dataset Phylogenetic dataset class phyDat matrix. subject Vector identifying subject taxa, name index. template Character integer identifying taxon use template. replaceAmbiguous, replaceCoded Character specifying whether tokens ambiguous (?) coded (?) fossil template replaced : original: original value; .e. change; ambiguous: ambiguous token, ?; binary: tokens 0 1, equal probability; uniform: One tokens present sampleFrom, equal probability; sample: One tokens present sampleFrom, sampled according frequency. replaceAll Logical: TRUE, replace tokens subject; FALSE, leave ambiguous tokens (?) ambiguous. sampleFrom Vector identifying subset characters sample replacement tokens. NULL, replacement tokens sampled initial states taxa used template (including subjects).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ArtificialExtinction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Artificial Extinction — ArtificialExtinction","text":"dataset class dataset entries ambiguous template made ambiguous subject.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ArtificialExtinction.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Artificial Extinction — ArtificialExtinction","text":"details provided Asher Smith (2022) . Note: simple implementation account character contingency, e.g. characters whose absence imposes inapplicable absent tokens dependent characters.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ArtificialExtinction.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Artificial Extinction — ArtificialExtinction","text":"Asher R, Smith MR (2022). “Phylogenetic signal bias paleontology.” Systematic Biology, 71(4), 986–1008. doi:10.1093/sysbio/syab072 .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ArtificialExtinction.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Artificial Extinction — ArtificialExtinction","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ArtificialExtinction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Artificial Extinction — ArtificialExtinction","text":"","code":"set.seed(1) dataset <- matrix(c(sample(0:2, 4 * 8, TRUE),                     \"0\", \"0\", rep(\"?\", 6)), nrow = 5,                     dimnames = list(c(LETTERS[1:4], \"FOSSIL\"),                                     paste(\"char\", 1:8)), byrow = TRUE) artex <- ArtificialExtinction(dataset, c(\"A\", \"C\"), \"FOSSIL\")"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CharacterInformation.html","id":null,"dir":"Reference","previous_headings":"","what":"Character information content — CharacterInformation","title":"Character information content — CharacterInformation","text":"CharacterInformation() calculates cladistic information content (Steel Penny 2006)  given character, bits. total information characters gives measure potential utility dataset (Cotton Wilkinson 2008) , can compared profile parsimony score (Faith Trueman 2001)  evaluate degree homoplasy within dataset.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CharacterInformation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Character information content — CharacterInformation","text":"","code":"CharacterInformation(tokens)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CharacterInformation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Character information content — CharacterInformation","text":"tokens Character vector specifying tokens assigned taxon character.  Example: c(0, 0, 0, 1, 1, 1, \"?\", \"-\"). Note ambiguous tokens (01) supported, replaced ?.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CharacterInformation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Character information content — CharacterInformation","text":"CharacterInformation() returns numeric specifying phylogenetic information content character (sensu Steel Penny 2006 ), bits.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CharacterInformation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Character information content — CharacterInformation","text":"Cotton JA, Wilkinson M (2008). “Quantifying potential utility phylogenetic characters.” Taxon, 57(1), 131–136. Faith DP, Trueman JWH (2001). “Towards inclusive philosophy phylogenetic inference.” Systematic Biology, 50(3), 331–350. doi:10.1080/10635150118627 . Steel MA, Penny D (2006). “Maximum parsimony phylogenetic information multistate characters.” Albert VA (ed.), Parsimony, Phylogeny, Genomics, 163–178. Oxford University Press, Oxford.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/CharacterInformation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Character information content — CharacterInformation","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladeSizes.html","id":null,"dir":"Reference","previous_headings":"","what":"Clade sizes — CladeSizes","title":"Clade sizes — CladeSizes","text":"CladeSizes() reports number nodes clade tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladeSizes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clade sizes — CladeSizes","text":"","code":"CladeSizes(tree, internal = FALSE, nodes = NULL)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladeSizes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clade sizes — CladeSizes","text":"tree tree class phylo. internal Logical specifying whether internal nodes counted towards size clade. nodes Integer specifying indices nodes base clades whose sizes returned. unspecified, counts provided nodes (including leaves).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladeSizes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clade sizes — CladeSizes","text":"CladeSizes() returns number nodes (including leaves) descended node, including node .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladeSizes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clade sizes — CladeSizes","text":"","code":"tree <- BalancedTree(6) plot(tree) ape::nodelabels()  CladeSizes(tree, nodes = c(1, 8, 9)) #> [1] 1 3 2"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladisticInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Cladistic information content of a tree — CladisticInfo","title":"Cladistic information content of a tree — CladisticInfo","text":"CladisticInfo() calculates cladistic (phylogenetic) information content phylogenetic object, sensu Thorley et al. (1998).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladisticInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cladistic information content of a tree — CladisticInfo","text":"","code":"CladisticInfo(x)  PhylogeneticInfo(x)  # S3 method for class 'phylo' CladisticInfo(x)  # S3 method for class 'Splits' CladisticInfo(x)  # S3 method for class 'list' CladisticInfo(x)  # S3 method for class 'multiPhylo' CladisticInfo(x)  PhylogeneticInformation(x)  CladisticInformation(x)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladisticInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cladistic information content of a tree — CladisticInfo","text":"x Tree class phylo, list thereof.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladisticInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cladistic information content of a tree — CladisticInfo","text":"CladisticInfo() returns numeric giving cladistic information content input tree(s), bits. passed Splits object, returns information content split turn.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladisticInfo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cladistic information content of a tree — CladisticInfo","text":"CIC logarithm number binary trees include specified topology. base two logarithm gives information content bits. CIC originally proposed Rohlf (1982) , formalised, information-theoretic justification, Thorley et al. (1998) . Steel Penny (2006)  term equivalent quantity \"phylogenetic information content\" context individual characters. number binary trees consistent cladogram provides satisfactory measure resolution tree simply counting number edges resolved (Page 1992) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladisticInfo.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cladistic information content of a tree — CladisticInfo","text":"Page RD (1992). “Comments information content classifications.” Cladistics, 8(1), 87–95. doi:10.1111/j.1096-0031.1992.tb00054.x . Rohlf FJ (1982). “Consensus indices comparing classifications.” Mathematical Biosciences, 59(1), 131–144. doi:10.1016/0025-5564(82)90112-2 . Steel MA, Penny D (2006). “Maximum parsimony phylogenetic information multistate characters.” Albert VA (ed.), Parsimony, Phylogeny, Genomics, 163–178. Oxford University Press, Oxford. Thorley JL, Wilkinson M, Charleston M (1998). “information content consensus trees.” Rizzi , Vichi M, Bock H (eds.), Advances Data Science Classification, 91–98. Springer, Berlin. ISBN 978-3-540-64641-9, doi:10.1007/978-3-642-72253-0 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/CladisticInfo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cladistic information content of a tree — CladisticInfo","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"S3 methods for ClusterTable objects — ClusterTable-methods","title":"S3 methods for ClusterTable objects — ClusterTable-methods","text":"S3 methods ClusterTable objects.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S3 methods for ClusterTable objects — ClusterTable-methods","text":"","code":"# S3 method for class 'ClusterTable' as.matrix(x, ...)  # S3 method for class 'ClusterTable' print(x, ...)  # S3 method for class 'ClusterTable' summary(object, ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"S3 methods for ClusterTable objects — ClusterTable-methods","text":"x, object Object class ClusterTable. ... Additional arguments consistency S3 methods.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"S3 methods for ClusterTable objects — ClusterTable-methods","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S3 methods for ClusterTable objects — ClusterTable-methods","text":"","code":"clustab <- as.ClusterTable(TreeTools::BalancedTree(6)) as.matrix(clustab) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    2    3 #> [3,]    1    3 #> [4,]    1    4 #> [5,]    1    5 #> [6,]    1    6 print(clustab) #> ClusterTable on 6 leaves: t1 .. t6 summary(clustab) #> ClusterTable on 6 leaves: #>  123456 #>  .**... #>  ***... #>  ****.. #>  *****. #>  ****** #>  1: t6  2: t5  3: t4  4: t3  5: t2  6: t1"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert phylogenetic tree to ClusterTable — ClusterTable","title":"Convert phylogenetic tree to ClusterTable — ClusterTable","text":".ClusterTable() converts phylogenetic tree ClusterTable object, internal representation splits suitable rapid tree distance calculation (per Day, 1985).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert phylogenetic tree to ClusterTable — ClusterTable","text":"","code":"as.ClusterTable(x, tipLabels = NULL, ...)  # S3 method for class 'phylo' as.ClusterTable(x, tipLabels = NULL, ...)  # S3 method for class 'list' as.ClusterTable(x, tipLabels = NULL, ...)  # S3 method for class 'multiPhylo' as.ClusterTable(x, tipLabels = NULL, ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert phylogenetic tree to ClusterTable — ClusterTable","text":"x Object convert ClusterTable: perhaps tree class phylo. tipLabels Character vector specifying sequence order tip labels. ... Unused.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert phylogenetic tree to ClusterTable — ClusterTable","text":".ClusterTable() returns object class ClusterTable, list thereof.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert phylogenetic tree to ClusterTable — ClusterTable","text":"row cluster table relates clade tree rooted tip 1. Tips numbered according order visited preorder: .e., plotted using plot(x), top page downwards.  clade containing tips 2 .. 5 denoted entry 2, 5, either row 2 row 5 cluster table.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Convert phylogenetic tree to ClusterTable — ClusterTable","text":"Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert phylogenetic tree to ClusterTable — ClusterTable","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ClusterTable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert phylogenetic tree to ClusterTable — ClusterTable","text":"","code":"tree1 <- ape::read.tree(text = \"(A, (B, (C, (D, E))));\"); tree2 <- ape::read.tree(text = \"(A, (B, (D, (C, E))));\"); ct1 <- as.ClusterTable(tree1) summary(ct1) #> ClusterTable on 5 leaves: #>  12345 #>  **... #>  ***.. #>  ****. #>  ***** #>  1: E  2: D  3: C  4: B  5: A  as.matrix(ct1) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    1    2 #> [3,]    1    3 #> [4,]    1    4 #> [5,]    1    5  # Tip label order must match ct1 to allow comparison ct2 <- as.ClusterTable(tree2, tipLabels = LETTERS[1:5])  # It can thus be safer to use ctList <- as.ClusterTable(c(tree1, tree2)) ctList[[2]] #> ClusterTable on 5 leaves: A .. E"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CollapseNode.html","id":null,"dir":"Reference","previous_headings":"","what":"Collapse nodes on a phylogenetic tree — CollapseNode","title":"Collapse nodes on a phylogenetic tree — CollapseNode","text":"Collapses specified nodes edges phylogenetic tree, resulting polytomies.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CollapseNode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collapse nodes on a phylogenetic tree — CollapseNode","text":"","code":"CollapseNode(tree, nodes)  # S3 method for class 'phylo' CollapseNode(tree, nodes)  CollapseEdge(tree, edges)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CollapseNode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collapse nodes on a phylogenetic tree — CollapseNode","text":"tree tree class phylo. nodes, edges Integer vector specifying nodes edges tree dropped. (Use nodelabels() edgelabels() view numbers plotted tree.)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CollapseNode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collapse nodes on a phylogenetic tree — CollapseNode","text":"CollapseNode() CollapseEdge() return tree class phylo, corresponding tree specified nodes edges collapsed. length dropped edge (naively) added descendant edge.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/CollapseNode.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Collapse nodes on a phylogenetic tree — CollapseNode","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CollapseNode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collapse nodes on a phylogenetic tree — CollapseNode","text":"","code":"oldPar <- par(mfrow = c(3, 1), mar = rep(0.5, 4))  tree <- as.phylo(898, 7) tree$edge.length <- 11:22 plot(tree) nodelabels() edgelabels() edgelabels(round(tree$edge.length, 2),            cex = 0.6, frame = \"n\", adj = c(1, -1))  # Collapse by node number newTree <- CollapseNode(tree, c(12, 13)) plot(newTree) nodelabels() edgelabels(round(newTree$edge.length, 2),            cex = 0.6, frame = \"n\", adj = c(1, -1))  # Collapse by edge number newTree <- CollapseEdge(tree, c(2, 4)) plot(newTree)   par(oldPar)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CompatibleSplits.html","id":null,"dir":"Reference","previous_headings":"","what":"Which splits are compatible? — CompatibleSplits","title":"Which splits are compatible? — CompatibleSplits","text":"splits compatible?","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CompatibleSplits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Which splits are compatible? — CompatibleSplits","text":"","code":"CompatibleSplits(splits, splits2)  .CompatibleSplit(a, b, nTip)  .CompatibleRaws(rawA, rawB, bitmask)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/CompatibleSplits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Which splits are compatible? — CompatibleSplits","text":"splits object class Splits. splits2 second Splits object. , b Raw representations splits, row Splits object. rawA, rawB Raw representations splits. bitmask Raw masking bits correspond tips.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CompatibleSplits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Which splits are compatible? — CompatibleSplits","text":"CompatibleSplits returns logical matrix specifying whether split splits compatible split splits2. .CompatibleSplit returns logical vector stating whether splits compatible. .CompatibleRaws returns logical vector specifying whether input raws compatible.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CompatibleSplits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Which splits are compatible? — CompatibleSplits","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/CompatibleSplits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Which splits are compatible? — CompatibleSplits","text":"","code":"splits <- as.Splits(BalancedTree(8)) splits2 <- as.Splits(PectinateTree(8))  summary(splits) #> 5 bipartition splits dividing 8 tips, t1 .. t8 #>      12345678 #>  10  ****.... #>  11  **...... #>  12  ..**.... #>  14  ....**.. #>  15  ......** #>  #>  Tip 1: t1\t Tip 2: t2\t Tip 3: t3\t Tip 4: t4\t Tip 5: t5\t #>  Tip 6: t6\t Tip 7: t7\t Tip 8: t8\t summary(splits2) #> 5 bipartition splits dividing 8 tips, t1 .. t8 #>      12345678 #>  11  ..****** #>  12  ...***** #>  13  ....**** #>  14  .....*** #>  15  ......** #>  #>  Tip 1: t1\t Tip 2: t2\t Tip 3: t3\t Tip 4: t4\t Tip 5: t5\t #>  Tip 6: t6\t Tip 7: t7\t Tip 8: t8\t  CompatibleSplits(splits, splits2) #>      11    12   13    14   15 #> 10 TRUE  TRUE TRUE  TRUE TRUE #> 11 TRUE  TRUE TRUE  TRUE TRUE #> 12 TRUE FALSE TRUE  TRUE TRUE #> 14 TRUE  TRUE TRUE FALSE TRUE #> 15 TRUE  TRUE TRUE  TRUE TRUE"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Consensus.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct consensus trees — Consensus","title":"Construct consensus trees — Consensus","text":"Consensus() calculates consensus set trees, using algorithm (Day 1985) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Consensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct consensus trees — Consensus","text":"","code":"Consensus(trees, p = 1, check.labels = TRUE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Consensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct consensus trees — Consensus","text":"trees List trees, optionally class multiPhylo. p Proportion trees must contain split reported consensus.  p = 0.5 gives majority-rule consensus; p = 1 (default) gives strict consensus. check.labels Logical specifying whether check trees identical labels.  Defaults TRUE, slower.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Consensus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct consensus trees — Consensus","text":"Consensus() returns object class phylo, rooted first entry trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Consensus.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Construct consensus trees — Consensus","text":"Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Consensus.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Construct consensus trees — Consensus","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Consensus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct consensus trees — Consensus","text":"","code":"Consensus(as.phylo(0:2, 8)) #>  #> Phylogenetic tree with 8 tips and 6 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length."},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConsensusWithout.html","id":null,"dir":"Reference","previous_headings":"","what":"Reduced consensus, omitting specified taxa — ConsensusWithout","title":"Reduced consensus, omitting specified taxa — ConsensusWithout","text":"ConsensusWithout() displays consensus plot specified taxa excluded, can useful way increase resolution consensus tree wildcard taxa obscure consistent set relationships. MarkMissing() adds missing taxa loose leaves plot.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConsensusWithout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reduced consensus, omitting specified taxa — ConsensusWithout","text":"","code":"ConsensusWithout(trees, tip = character(0), ...)  # S3 method for class 'phylo' ConsensusWithout(trees, tip = character(0), ...)  # S3 method for class 'multiPhylo' ConsensusWithout(trees, tip = character(0), ...)  # S3 method for class 'list' ConsensusWithout(trees, tip = character(0), ...)  MarkMissing(tip, position = \"bottomleft\", ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConsensusWithout.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reduced consensus, omitting specified taxa — ConsensusWithout","text":"trees list phylogenetic trees, class multiPhylo list. tip character vector specifying names (numbers) tips drop (using ape::drop.tip()). ... Additional parameters pass ape::consensus() legend(). position plot missing taxa. See legend() options.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConsensusWithout.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reduced consensus, omitting specified taxa — ConsensusWithout","text":"ConsensusWithout() returns consensus tree (class phylo) without excluded taxa. MarkMissing() provides null return, plotting specified tips legend.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConsensusWithout.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reduced consensus, omitting specified taxa — ConsensusWithout","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConsensusWithout.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reduced consensus, omitting specified taxa — ConsensusWithout","text":"","code":"oldPar <- par(mfrow = c(1, 2), mar = rep(0.5, 4))  # Two trees differing only in placement of tip 2: trees <- as.phylo(c(0, 53), 6) plot(trees[[1]]) plot(trees[[2]])   # Strict consensus (left panel) lacks resolution: plot(ape::consensus(trees))  # But omitting tip two (right panel) reveals shared structure in common: plot(ConsensusWithout(trees, \"t2\")) MarkMissing(\"t2\")   par(oldPar)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConstrainedNJ.html","id":null,"dir":"Reference","previous_headings":"","what":"Constrained neighbour-joining tree — ConstrainedNJ","title":"Constrained neighbour-joining tree — ConstrainedNJ","text":"Constructs approximation neighbour-joining tree, modified order consistent constraint.  Zero-length branches collapsed random.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConstrainedNJ.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constrained neighbour-joining tree — ConstrainedNJ","text":"","code":"ConstrainedNJ(dataset, constraint, weight = 1L, ratio = TRUE, ambig = \"mean\")"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConstrainedNJ.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constrained neighbour-joining tree — ConstrainedNJ","text":"dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. constraint Either object class phyDat, case returned trees perfectly compatible character constraint; tree class phylo, node constraint occur returned tree. See vignette examples. weight Numeric specifying degree -weight characters constraint. ambig, ratio Settings ambig ratio used computing Hamming() distances sequences.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConstrainedNJ.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constrained neighbour-joining tree — ConstrainedNJ","text":"ConstrainedNJ() returns tree class phylo.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConstrainedNJ.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Constrained neighbour-joining tree — ConstrainedNJ","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ConstrainedNJ.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constrained neighbour-joining tree — ConstrainedNJ","text":"","code":"dataset <- MatrixToPhyDat(matrix(   c(0, 1, 1, 1, 0, 1,     0, 1, 1, 0, 0, 1), ncol = 2,   dimnames = list(letters[1:6], NULL))) constraint <- MatrixToPhyDat(   c(a = 0, b = 0, c = 0, d = 0, e = 1, f = 1)) plot(ConstrainedNJ(dataset, constraint))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Decompose.html","id":null,"dir":"Reference","previous_headings":"","what":"Decompose additive (ordered) phylogenetic characters — Decompose","title":"Decompose additive (ordered) phylogenetic characters — Decompose","text":"Decompose() decomposes additive characters series binary characters, mathematically equivalent analysed equal weights parsimony.  (equivalence exact implied weights probabilistic tree inference methods.)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Decompose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decompose additive (ordered) phylogenetic characters — Decompose","text":"","code":"Decompose(dataset, indices)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Decompose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decompose additive (ordered) phylogenetic characters — Decompose","text":"dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. indices Integer logical vector specifying indices characters decomposed","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Decompose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decompose additive (ordered) phylogenetic characters — Decompose","text":"Decompose() returns phyDat object specified ordered characters decomposed binary characters. attribute originalIndex lists index character dataset element corresponds.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Decompose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Decompose additive (ordered) phylogenetic characters — Decompose","text":"ordered (additive) character can rewritten mathematically equivalent hierarchy binary neomorphic characters (Farris et al. 1970) . Two reasons prefer latter approach : makes explicit evolutionary assumptions underlying ordered character, whether underlying ordering linear, reticulate branched (Mabee 1989) . avoids identify characters requiring special treatment phylogenetic software, requires maintenance --date log characters treated additive sequence states occur , step may overlooked re-users data. Careful consideration warranted evaluating whether group related characteristics treated ordered (Wilkinson 1992) . one hand, 'principle indifference' states treat transformations equally probable (/ surprising / informative); ordered characters fail test, larger changes treated less probable smaller ones. hand, ordered characters allow opportunities homology different character states, might thus defended auspices Hennig’s Auxiliary Principle (Wilkinson 1992) . case study ordering phylogenetic characters can affect phylogenetic outcomes practice, see Brady et al. (2024) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Decompose.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Decompose additive (ordered) phylogenetic characters — Decompose","text":"Brady PL, Castrellon Arteaga , López-Torres S, Springer MS (2024). “Effects Ordered Multistate Morphological Characters Phylogenetic Analyses Eutherian Mammals.” Journal Mammalian Evolution, 31(3), 28. doi:10.1007/s10914-024-09727-2 . Farris JS, Kluge AG, Eckardt MJ (1970). “Numerical Approach Phylogenetic Systematics.” Systematic Biology, 19(2), 172–189. doi:10.2307/2412452 . Mabee PM (1989). “Assumptions Underlying Use Ontogenetic Sequences Determining Character State Order.” Transactions American Fisheries Society, 118(2), 151–158. doi:10.1577/1548-8659(1989)118<0151:AUTUOO>2.3.CO;2 . Wilkinson M (1992). “Ordered versus Unordered Characters.” Cladistics, 8(4), 375–385. doi:10.1111/j.1096-0031.1992.tb00079.x .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Decompose.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Decompose additive (ordered) phylogenetic characters — Decompose","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Decompose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Decompose additive (ordered) phylogenetic characters — Decompose","text":"","code":"data(\"Lobo\")  # Identify character 11 as additive # Character 11 will be replaced with two characters # The present codings 0, 1 and 2 will be replaced with 00, 10, and 11. decomposed <- Decompose(Lobo.phy, 11)  NumberOfChars <- function(x) sum(attr(x, \"weight\")) NumberOfChars(Lobo.phy)   # 115 characters in original #> [1] 115 NumberOfChars(decomposed) # 116 characters in decomposed #> [1] 116"},{"path":"https://ms609.github.io/TreeTools/dev/reference/DescendantEdges.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify descendant edges — DescendantEdges","title":"Identify descendant edges — DescendantEdges","text":"DescendantEdges() efficiently identifies edges \"descended\" edges tree. DescendantTips() efficiently identifies leaves (external nodes) \"descended\" edges tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DescendantEdges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify descendant edges — DescendantEdges","text":"","code":"DescendantEdges(   parent,   child,   edge = NULL,   node = NULL,   nEdge = length(parent),   includeSelf = TRUE )  DescendantTips(parent, child, edge = NULL, node = NULL, nEdge = length(parent))  AllDescendantEdges(parent, child, nEdge = length(parent))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/DescendantEdges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify descendant edges — DescendantEdges","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 1] child Integer vector corresponding second column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 2]. edge Integer specifying number edge whose children required (see edgelabels()). node Integer specifying number(s) nodes whose children required.  Specify 0 return nodes.  NULL (default), edge parameter used instead. nEdge number edges (calculated length(parent) supplied). includeSelf Logical specifying whether mark edge descendant.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DescendantEdges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify descendant edges — DescendantEdges","text":"DescendantEdges() returns logical vector stating whether edge turn specified edge (includeSelf = TRUE) one descendants. DescendantTips() returns logical vector stating whether leaf turn descendant specified edge. AllDescendantEdges() deprecated; use DescendantEdges() instead. returns matrix class logical, row N specifying whether edge descendant edge N (edge ).","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/DescendantEdges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify descendant edges — DescendantEdges","text":"","code":"tree <- as.phylo(0, 6) plot(tree) desc <- DescendantEdges(tree$edge[, 1], tree$edge[, 2], edge = 5) which(desc) #> [1] 5 6 7 ape::edgelabels(bg = 3 + desc) tips <- DescendantTips(tree$edge[, 1], tree$edge[, 2], edge = 5) which(tips) #> [1] 2 6 tiplabels(bg = 3 + tips)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/DoubleFactorial.html","id":null,"dir":"Reference","previous_headings":"","what":"Double factorial — DoubleFactorial","title":"Double factorial — DoubleFactorial","text":"Calculate double factorial number, logarithm.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DoubleFactorial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Double factorial — DoubleFactorial","text":"","code":"DoubleFactorial(n)  DoubleFactorial64(n)  LnDoubleFactorial(n)  Log2DoubleFactorial(n)  LogDoubleFactorial(n)  LnDoubleFactorial.int(n)  LogDoubleFactorial.int(n)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/DoubleFactorial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Double factorial — DoubleFactorial","text":"n Vector integers.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DoubleFactorial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Double factorial — DoubleFactorial","text":"Returns double factorial, n * (n - 2) * (n - 4) * (n - 6) * ...","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DoubleFactorial.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Double factorial — DoubleFactorial","text":"DoubleFactorial64(): Returns exact double factorial 64-bit integer64, n < 34. LnDoubleFactorial(): Returns logarithm double factorial. Log2DoubleFactorial(): Returns logarithm double factorial. LnDoubleFactorial.int(): Slightly faster, x known length one 50001","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/DoubleFactorial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Double factorial — DoubleFactorial","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DoubleFactorial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Double factorial — DoubleFactorial","text":"","code":"DoubleFactorial (-4:0) # Return 1 if n < 2 #> [1] 1 1 1 1 1 DoubleFactorial (2) # 2 #> [1] 2 DoubleFactorial (5) # 1 * 3 * 5 #> [1] 15 exp(LnDoubleFactorial.int (8)) # log(2 * 4 * 6 * 8) #> [1] 384 DoubleFactorial64(31) #> integer64 #> [1] 191898783962510625"},{"path":"https://ms609.github.io/TreeTools/dev/reference/DropTip.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop leaves from tree — DropTip","title":"Drop leaves from tree — DropTip","text":"DropTip() removes specified leaves phylogenetic tree, collapsing incident branches.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DropTip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop leaves from tree — DropTip","text":"","code":"DropTip(tree, tip, preorder = TRUE, check = TRUE)  KeepTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class 'phylo' DropTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class 'phylo' KeepTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class 'Splits' KeepTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class 'Splits' DropTip(tree, tip, preorder, check = TRUE)  DropTipPhylo(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class 'multiPhylo' DropTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class 'multiPhylo' KeepTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class 'list' DropTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class 'list' KeepTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class '`NULL`' DropTip(tree, tip, preorder = TRUE, check = TRUE)  # S3 method for class '`NULL`' KeepTip(tree, tip, preorder = TRUE, check = TRUE)  KeepTipPreorder(tree, tip)  KeepTipPostorder(tree, tip)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/DropTip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop leaves from tree — DropTip","text":"tree tree class phylo. tip Character vector specifying labels leaves tree dropped kept, integer vector specifying indices leaves dropped kept. Specifying index internal node drop descendants node. preorder Logical specifying whether Preorder tree dropping tips.  Specifying FALSE saves little time, result undefined behaviour tree preorder. check Logical specifying whether check validity tip. FALSE tip contains entries correspond leaves tree, undefined behaviour may occur.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DropTip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Drop leaves from tree — DropTip","text":"DropTip() returns tree class phylo, requested leaves removed. edges tree numbered preorder, sequence may conform conventions Preorder(). KeepTip() returns tree leaves tip removed, preorder.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DropTip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Drop leaves from tree — DropTip","text":"function differs ape::drop.tip(), roots unrooted trees, can crash trees' internal numbering follows unexpected schema.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DropTip.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Drop leaves from tree — DropTip","text":"DropTipPhylo(): Direct call DropTip.phylo(), avoid overhead querying object's class. KeepTipPreorder(): Faster version checks. retain labels edge weights. Edges must listed preorder. May crash improper input specified. KeepTipPostorder(): Faster version checks. retain labels edge weights. Edges must listed postorder. May crash improper input specified.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/DropTip.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Drop leaves from tree — DropTip","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/DropTip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drop leaves from tree — DropTip","text":"","code":"tree <- BalancedTree(9) plot(tree)  plot(DropTip(tree, c(\"t5\", \"t6\")))   unrooted <- UnrootTree(tree) plot(unrooted)  plot(DropTip(unrooted, 4:5))   summary(DropTip(as.Splits(tree), 4:5)) #> 4 bipartition splits dividing 7 tips, t1 .. t9 #>      1234567 #>  12  ***.... #>  13  **..... #>  16  ...**.. #>  17  .....** #>  #>  Tip 1: t1\t Tip 2: t2\t Tip 3: t3\t Tip 4: t6\t Tip 5: t7\t #>  Tip 6: t8\t Tip 7: t9"},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeAncestry.html","id":null,"dir":"Reference","previous_headings":"","what":"Ancestors of an edge — EdgeAncestry","title":"Ancestors of an edge — EdgeAncestry","text":"Quickly identify edges \"ancestral\" particular edge tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeAncestry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ancestors of an edge — EdgeAncestry","text":"","code":"EdgeAncestry(edge, parent, child, stopAt = (parent == min(parent)))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeAncestry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ancestors of an edge — EdgeAncestry","text":"edge Integer specifying number edge whose child edges returned. parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 1] child Integer vector corresponding second column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 2]. stopAt Integer logical vector specifying edge(s) terminate search; defaults edges smallest parent, root edges nodes numbered Cladewise Preorder.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeAncestry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ancestors of an edge — EdgeAncestry","text":"EdgeAncestry() returns logical vector stating whether edge turn descendant specified edge.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeAncestry.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Ancestors of an edge — EdgeAncestry","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeAncestry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ancestors of an edge — EdgeAncestry","text":"","code":"tree <- PectinateTree(6) plot(tree) ape::edgelabels()  parent <- tree$edge[, 1] child <- tree$edge[, 2] EdgeAncestry(7, parent, child) #>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE which(EdgeAncestry(7, parent, child, stopAt = 4)) #> [1] 4 6"},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeDistances.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance between edges — EdgeDistances","title":"Distance between edges — EdgeDistances","text":"Number nodes must traversed navigate edge edge within tree","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeDistances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance between edges — EdgeDistances","text":"","code":"EdgeDistances(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeDistances.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance between edges — EdgeDistances","text":"tree tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeDistances.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance between edges — EdgeDistances","text":"EdgeDistances() returns symmetrical matrix listing number edges must traversed travel numbered edge . two edges straddling root rooted tree treated single edge.  Add \"root\" tip using AddTip() position root significant.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeDistances.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distance between edges — EdgeDistances","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EdgeDistances.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance between edges — EdgeDistances","text":"","code":"tree <- BalancedTree(5) plot(tree) ape::edgelabels()   EdgeDistances(tree) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    0    1    2    2    1    0    1    1 #> [2,]    1    0    1    1    1    1    2    2 #> [3,]    2    1    0    1    2    2    3    3 #> [4,]    2    1    1    0    2    2    3    3 #> [5,]    1    1    2    2    0    1    2    2 #> [6,]    0    1    2    2    1    0    1    1 #> [7,]    1    2    3    3    2    1    0    1 #> [8,]    1    2    3    3    2    1    1    0"},{"path":"https://ms609.github.io/TreeTools/dev/reference/EndSentence.html","id":null,"dir":"Reference","previous_headings":"","what":"Add full stop to end of a sentence — EndSentence","title":"Add full stop to end of a sentence — EndSentence","text":"Add full stop end sentence","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EndSentence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add full stop to end of a sentence — EndSentence","text":"","code":"EndSentence(string)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/EndSentence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add full stop to end of a sentence — EndSentence","text":"string Input string","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EndSentence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add full stop to end of a sentence — EndSentence","text":"EndSentence() returns string, punctuated final full stop (period).`","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/EndSentence.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add full stop to end of a sentence — EndSentence","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EndSentence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add full stop to end of a sentence — EndSentence","text":"","code":"EndSentence(\"Hello World\") # \"Hello World.\" #> [1] \"Hello World.\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EnforceOutgroup.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a tree with a specified outgroup — EnforceOutgroup","title":"Generate a tree with a specified outgroup — EnforceOutgroup","text":"Deprecated. function removed future version TreeTools. Use RootTree() instead.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EnforceOutgroup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a tree with a specified outgroup — EnforceOutgroup","text":"","code":"EnforceOutgroup(tree, outgroup)  # S3 method for class 'phylo' EnforceOutgroup(tree, outgroup)  # S3 method for class 'character' EnforceOutgroup(tree, outgroup)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/EnforceOutgroup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a tree with a specified outgroup — EnforceOutgroup","text":"tree Either tree class phylo; (EnforceOutgroup()) character vector listing names taxa tree, random tree generated. outgroup Character vector containing names taxa include outgroup.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EnforceOutgroup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a tree with a specified outgroup — EnforceOutgroup","text":"EnforceOutgroup() returned tree class phylo outgroup taxa sister remaining taxa, without modifying ingroup topology.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/EnforceOutgroup.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a tree with a specified outgroup — EnforceOutgroup","text":"Given tree list taxa, EnforceOutgroup() rearranged ingroup outgroup taxa two sister taxa across root, without changing relationships within ingroup within outgroup.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/EnforceOutgroup.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a tree with a specified outgroup — EnforceOutgroup","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ExtractTaxa.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract taxa from a matrix block — ExtractTaxa","title":"Extract taxa from a matrix block — ExtractTaxa","text":"Extract leaf labels character states Nexus-formatted matrix.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ExtractTaxa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract taxa from a matrix block — ExtractTaxa","text":"","code":"ExtractTaxa(matrixLines, character_num = NULL, continuous = FALSE)  NexusTokens(tokens, character_num = NULL)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ExtractTaxa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract taxa from a matrix block — ExtractTaxa","text":"matrixLines Character vector containing lines file include phylogenetic matrix. See ReadCharacters() expected format. character_num Index character(s) return. NULL, default, returns characters. continuous Logical specifying whether characters continuous. Treated discrete FALSE. tokens Vector character strings corresponding phylogenetic tokens.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ExtractTaxa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract taxa from a matrix block — ExtractTaxa","text":"ExtractTaxa() returns matrix n rows, named relevant taxon, c columns, corresponding respective character specified character_num. NexusTokens() returns character vector entry corresponds states phylogenetic character, list containing error message input invalid.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ExtractTaxa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract taxa from a matrix block — ExtractTaxa","text":"","code":"fileName <- paste0(system.file(package = \"TreeTools\"),                    \"/extdata/input/dataset.nex\") matrixLines <- readLines(fileName)[6:11] ExtractTaxa(matrixLines) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> ____1 \"'\"  \"C\"  \"h\"  \"a\"  \"r\"  \"a\"  \"c\"  \"t\"  \"e\"  \"r\"   \"o\"   \"n\"   \"e\"   #> ____2 \"C\"  \"h\"  \"a\"  \"r\"  \"a\"  \"c\"  \"t\"  \"e\"  \"r\"  \"_\"   \"t\"   \"w\"   \"o\"   #> ____3 \"'\"  \"l\"  \"o\"  \"t\"  \"s\"  \"-\"  \"o\"  \"f\"  \"-\"  \"p\"   \"u\"   \"n\"   \"c\"   #> ____4 \"C\"  \"h\"  \"a\"  \"r\"  \"a\"  \"c\"  \"t\"  \"e\"  \"r\"  \"_\"   \"n\"   \"/\"   \"a\"   #> ____5 \"C\"  \"h\"  \"a\"  \"r\"  \"a\"  \"c\"  \"t\"  \"e\"  \"r\"  \"_\"   \"5\"   \"/\"   \"s\"   #> ____6 \"C\"  \"h\"  \"a\"  \"r\"  \"a\"  \"c\"  \"t\"  \"e\"  \"r\"  \"_\"   \"6\"   \"/\"   NA    #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] #> ____1 \"'\"   \"/\"   \"a\"   \"b\"   \"s\"   \"e\"   \"n\"   \"t\"   \"p\"   \"r\"   \"e\"   \"s\"   #> ____2 \"/\"   \"a\"   \"b\"   \"s\"   \"e\"   \"n\"   \"t\"   \"p\"   \"r\"   \"e\"   \"s\"   \"e\"   #> ____3 \"t\"   \"u\"   \"a\"   \"t\"   \"i\"   \"o\"   \"n\"   \",\"   \"a\"   \"n\"   \"d\"   \"\\\"\"  #> ____4 \"_\"   \"l\"   \"o\"   \"n\"   \"g\"   \"_\"   \"d\"   \"e\"   \"s\"   \"c\"   \"r\"   \"i\"   #> ____5 \"i\"   \"m\"   \"p\"   \"l\"   \"e\"   \"m\"   \"o\"   \"r\"   \"e\"   \"_\"   \"c\"   \"o\"   #> ____6 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    #>       [,26] [,27] [,28] [,29] #> ____1 \"e\"   \"n\"   \"t\"   \",\"   #> ____2 \"n\"   \"t\"   \",\"   NA    #> ____3 \"s\"   \"o\"   \"o\"   \"n\"   #> ____4 \"p\"   \"t\"   \"i\"   \"o\"   #> ____5 \"m\"   \"p\"   \"l\"   \"e\"   #> ____6 NA    NA    NA    NA     NexusTokens(\"01[01]-?\") #>      [,1] [,2] [,3]   [,4] [,5] #> [1,] \"0\"  \"1\"  \"[01]\" \"-\"  \"?\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/GenerateTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate pectinate, balanced or random trees — GenerateTree","title":"Generate pectinate, balanced or random trees — GenerateTree","text":"RandomTree(), PectinateTree(), BalancedTree() StarTree() generate trees specified shapes leaf labels.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/GenerateTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate pectinate, balanced or random trees — GenerateTree","text":"","code":"RandomTree(tips, root = FALSE, nodes, lengths = NULL)  YuleTree(tips, addInTurn = FALSE, root = TRUE, lengths = NULL)  PectinateTree(tips, lengths = NULL)  BalancedTree(tips, lengths = NULL)  StarTree(tips, lengths = NULL)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/GenerateTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate pectinate, balanced or random trees — GenerateTree","text":"tips integer specifying number tips, character vector naming tips, object TipLabels() can extract leaf labels. root Character integer specifying tip use root; TRUE root tree random edge; FALSE return unrooted tree. nodes Number nodes generate.  default maximum, tips - 1, generates binary tree; setting lower value induce polytomies. lengths numeric vector specifying edge lengths tree. addInTurn Logical specifying whether add leaves order tips.  FALSE, leaves added random order.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/GenerateTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate pectinate, balanced or random trees — GenerateTree","text":"function returns unweighted binary tree class phylo specified leaf labels. Trees rooted unless root = FALSE. RandomTree() returns topology drawn random uniform distribution (.e. binary tree drawn equal probability). Trees generated inserting tip term randomly selected edge tree. Random numbers generated using Mersenne Twister. root = FALSE, tree unrooted, first tip basal position.  Otherwise, tree rooted root. YuleTree() returns topology generated Yule process (Steel McKenzie 2001) , .e. adding leaves turn adjacent randomly-chosen existing leaf. PectinateTree() returns pectinate (caterpillar) tree. BalancedTree() returns balanced (symmetrical) tree, preorder. StarTree() returns completely unresolved (star) tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/GenerateTree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate pectinate, balanced or random trees — GenerateTree","text":"Steel MA, McKenzie (2001). “Properties Phylogenetic Trees Generated Yule-type Speciation Models.” Mathematical Biosciences, 170(1), 91–112. doi:10.1016/S0025-5564(00)00061-4 . ()","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/GenerateTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate pectinate, balanced or random trees — GenerateTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/GenerateTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate pectinate, balanced or random trees — GenerateTree","text":"","code":"RandomTree(LETTERS[1:10]) #>  #> Phylogenetic tree with 10 tips and 8 internal nodes. #>  #> Tip labels: #>   A, B, C, D, E, F, ... #>  #> Unrooted; no branch length.  data(\"Lobo\") RandomTree(Lobo.phy) #>  #> Phylogenetic tree with 48 tips and 46 internal nodes. #>  #> Tip labels: #>   Tubiluchus_Priapulida, Cricocosmia, Aysheaia, Siberion, Onychodictyon_ferox, Onychodictyon_gracilis, ... #>  #> Unrooted; no branch length.  YuleTree(LETTERS[1:10]) #>  #> Phylogenetic tree with 10 tips and 9 internal nodes. #>  #> Tip labels: #>   A, D, E, J, G, I, ... #>  #> Rooted; no branch length.  plot(PectinateTree(LETTERS[1:10]))   plot(BalancedTree(LETTERS[1:10]))  plot(StarTree(LETTERS[1:10]))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Hamming.html","id":null,"dir":"Reference","previous_headings":"","what":"Hamming distance between taxa in a phylogenetic dataset — Hamming","title":"Hamming distance between taxa in a phylogenetic dataset — Hamming","text":"Hamming distance pair taxa number characters different coding, .e. smallest number evolutionary steps must occurred since common ancestor.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Hamming.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hamming distance between taxa in a phylogenetic dataset — Hamming","text":"","code":"Hamming(   dataset,   ratio = TRUE,   ambig = c(\"median\", \"mean\", \"zero\", \"one\", \"na\", \"nan\") )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Hamming.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hamming distance between taxa in a phylogenetic dataset — Hamming","text":"dataset Object class phyDat. ratio Logical specifying whether weight distance maximum possible, given token ambiguous either two taxa contribute total distance pair. ambig Character specifying value return pair taxa zero maximum distance (perhaps due preponderance ambiguous tokens). \"median\", default, take median distance values; \"mean\", mean; \"zero\" sets zero; \"one\" one; \"NA\" NA_integer_; \"NaN\" NaN.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Hamming.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hamming distance between taxa in a phylogenetic dataset — Hamming","text":"Hamming() returns object class dist listing Hamming distance pair taxa.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Hamming.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hamming distance between taxa in a phylogenetic dataset — Hamming","text":"Tokens contain inapplicable state treated requiring steps transform applicable token.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Hamming.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hamming distance between taxa in a phylogenetic dataset — Hamming","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Hamming.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hamming distance between taxa in a phylogenetic dataset — Hamming","text":"","code":"tokens <- matrix(c(0, 0, \"0\", 0, \"?\",                    0, 0, \"1\", 0, 1,                    0, 0, \"1\", 0, 1,                    0, 0, \"2\", 0, 1,                    1, 1, \"-\", \"?\", 0,                    1, 1, \"2\", 1, \"{01}\"),                    nrow = 6, ncol = 5, byrow = TRUE,                    dimnames = list(                      paste0(\"Taxon_\", LETTERS[1:6]),                      paste0(\"Char_\", 1:5)))  dataset <- MatrixToPhyDat(tokens) Hamming(dataset) #>         Taxon_A Taxon_B Taxon_C Taxon_D Taxon_E #> Taxon_B    0.25                                 #> Taxon_C    0.25    0.00                         #> Taxon_D    0.25    0.20    0.20                 #> Taxon_E    1.00    1.00    1.00    1.00         #> Taxon_F    1.00    0.80    0.80    0.60    0.00"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ImposeConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Force a tree to match a constraint — ImposeConstraint","title":"Force a tree to match a constraint — ImposeConstraint","text":"Modify tree matches specified constraint. present somewhat crude implementation attempts retain much structure tree whilst guaranteeing compatibility entry constraint.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ImposeConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Force a tree to match a constraint — ImposeConstraint","text":"","code":"ImposeConstraint(tree, constraint)  AddUnconstrained(constraint, toAdd, asPhyDat = TRUE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ImposeConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Force a tree to match a constraint — ImposeConstraint","text":"tree tree class phylo. constraint Either object class phyDat, case returned trees perfectly compatible character constraint; tree class phylo, node constraint occur returned tree. See vignette examples. toAdd Character vector specifying taxa add constraint. asPhyDat Logical: TRUE, return phyDat object; FALSE, return matrix.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ImposeConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Force a tree to match a constraint — ImposeConstraint","text":"ImposeConstraint() returns tree class phylo, consistent constraint.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ImposeConstraint.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Force a tree to match a constraint — ImposeConstraint","text":"AddUnconstrained(): Expand constraint include unconstrained taxa.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ImposeConstraint.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Force a tree to match a constraint — ImposeConstraint","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ImposeConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Force a tree to match a constraint — ImposeConstraint","text":"","code":"tips <- letters[1:9] tree <- as.phylo(1, 9, tips) plot(tree)   constraint <- StringToPhyDat(\"0000?1111 000111111 0000??110\", tips, FALSE) plot(ImposeConstraint(tree, constraint))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/J1Index.html","id":null,"dir":"Reference","previous_headings":"","what":"Robust universal tree balance index — J1Index","title":"Robust universal tree balance index — J1Index","text":"Calculate tree balance index J1 (nonRootDominance = FALSE) J1c (nonRootDominance = TRUE) Lemant J, Le Sueur C, Manojlović V, Noble R (2022). “Robust, Universal Tree Balance Indices.” Systematic Biology, 71(5), 1210–1224. doi:10.1093/sysbio/syac027 . .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/J1Index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robust universal tree balance index — J1Index","text":"","code":"J1Index(tree, q = 1, nonRootDominance = FALSE)  JQIndex(tree, q = 1, nonRootDominance = FALSE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/J1Index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robust universal tree balance index — J1Index","text":"tree Either object class 'phylo', dataframe column names Parent, Identity (optionally) Population. latter similar tree$edge, tree object class 'phylo'; differences class (data.frame versus matrix) column names. dataframe may (required ) include row root node. population sizes omitted internal nodes assigned population size zero leaves assigned population size one. q Numeric zero one specifying sensitivity type frequencies.  q < 1, Jq index - based generalized entropy - returned; see Lemant et al. (2022) , page 1223. nonRootDominance Logical specifying whether use non-root dominance factor.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/J1Index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Robust universal tree balance index — J1Index","text":"population sizes provided, function assigns size 0 internal nodes, size 1 leaves.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/J1Index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Robust universal tree balance index — J1Index","text":"Lemant J, Le Sueur C, Manojlović V, Noble R (2022). “Robust, Universal Tree Balance Indices.” Systematic Biology, 71(5), 1210–1224. doi:10.1093/sysbio/syac027 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/J1Index.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Robust universal tree balance index — J1Index","text":"Rob Noble, adapted Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/J1Index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Robust universal tree balance index — J1Index","text":"","code":"# Using phylo object as input: phylo_tree <- read.tree(text=\"((a:0.1)A:0.5,(b1:0.2,b2:0.1)B:0.2);\") J1Index(phylo_tree) #> [1] 0.7924813 phylo_tree2 <- read.tree(text='((A, B), ((C, D), (E, F)));') J1Index(phylo_tree2) #> [1] 0.9693609  # Using edges lists as input: tree1 <- data.frame(Parent = c(1, 1, 1, 1, 2, 3, 4),                     Identity = 1:7,                     Population = c(1, rep(5, 6))) J1Index(tree1) #> [1] 0.6666667 tree2 <- data.frame(Parent = c(1, 1, 1, 1, 2, 3, 4),                     Identity = 1:7,                     Population = c(rep(0, 4), rep(1, 3))) J1Index(tree2) #> [1] 0.5 tree3 <- data.frame(Parent = c(1, 1, 1, 1, 2, 3, 4),                     Identity = 1:7,                     Population = c(0, rep(1, 3), rep(0, 3))) J1Index(tree3) #> [1] 1 cat_tree <- data.frame(Parent = c(1, 1:14, 1:15, 15),                        Identity = 1:31,                        Population = c(rep(0, 15), rep(1, 16))) J1Index(cat_tree) #> [1] 0.4740741  # If population sizes are omitted then internal nodes are assigned population # size zero and leaves are assigned population size one: sym_tree1 <- data.frame(Parent = c(1, rep(1:15, each = 2)),                        Identity = 1:31,                        Population = c(rep(0, 15), rep(1, 16))) # Equivalently:                         sym_tree2 <- data.frame(Parent = c(1, rep(1:15, each = 2)),                        Identity = 1:31) J1Index(sym_tree1) #> [1] 1 J1Index(sym_tree2) #> [1] 1"},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptPaths.html","id":null,"dir":"Reference","previous_headings":"","what":"Paths present in reduced tree — KeptPaths","title":"Paths present in reduced tree — KeptPaths","text":"Lists paths present master tree present leaves dropped.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptPaths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Paths present in reduced tree — KeptPaths","text":"","code":"KeptPaths(paths, keptVerts, all = TRUE)  # S3 method for class 'data.frame' KeptPaths(paths, keptVerts, all = TRUE)  # S3 method for class 'matrix' KeptPaths(paths, keptVerts, all = TRUE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptPaths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Paths present in reduced tree — KeptPaths","text":"paths data.frame paths master tree, perhaps generated using PathLengths(). keptVerts Logical specifying whether entry retained reduced tree, perhaps generated using KeptVerts(). Logical: TRUE, return paths occur reduced tree; FALSE, return paths correspond single edge. correspond edges reduced tree. Ignored paths matrix.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptPaths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Paths present in reduced tree — KeptPaths","text":"KeptPaths() returns logical vector specifying whether path paths occurs keptVerts vertices retained.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptPaths.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Paths present in reduced tree — KeptPaths","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptPaths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Paths present in reduced tree — KeptPaths","text":"","code":"master <- BalancedTree(9) paths <- PathLengths(master) keptTips <- c(1, 5, 7, 9) keptVerts <- KeptVerts(master, keptTips) KeptPaths(paths, keptVerts) #>  [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #> [13] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE #> [25] FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE #> [37] FALSE  TRUE FALSE FALSE FALSE FALSE paths[KeptPaths(paths, keptVerts, all = FALSE), ] #>    start end length #> 2     11   1      3 #> 16    11   5      2 #> 22    15   7      2 #> 28    15   9      2 #> 30    10  11      1 #> 38    10  15      1"},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptVerts.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify vertices retained when leaves are dropped — KeptVerts","title":"Identify vertices retained when leaves are dropped — KeptVerts","text":"Identify vertices retained leaves dropped","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptVerts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify vertices retained when leaves are dropped — KeptVerts","text":"","code":"KeptVerts(tree, keptTips, tipLabels = TipLabels(tree))  # S3 method for class 'phylo' KeptVerts(tree, keptTips, tipLabels = TipLabels(tree))  # S3 method for class 'numeric' KeptVerts(tree, keptTips, tipLabels = TipLabels(tree))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptVerts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify vertices retained when leaves are dropped — KeptVerts","text":"tree Original tree class phylo, Preorder. keptTips Either: logical vector stating whether leaf retained, sequence corresponding tree[[\"tip.label\"]]; character vector listing leaf labels retain; numeric vector listing indices leaves retain. tipLabels Optional character vector naming leaves tree, keptTips logical.  Inferred tree unspecified.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptVerts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify vertices retained when leaves are dropped — KeptVerts","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/KeptVerts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify vertices retained when leaves are dropped — KeptVerts","text":"","code":"master <- BalancedTree(12) master <- Preorder(master) # Nodes must be listed in Preorder sequence plot(master) nodelabels()   allTips <- master[[\"tip.label\"]] keptTips <- sample(allTips, 8) plot(KeepTip(master, keptTips))  kept <- KeptVerts(master, allTips %in% keptTips)  map <- which(kept) # Node `i` in the reduced tree corresponds to node `map[i]` in the original."},{"path":"https://ms609.github.io/TreeTools/dev/reference/LabelSplits.html","id":null,"dir":"Reference","previous_headings":"","what":"Label splits — LabelSplits","title":"Label splits — LabelSplits","text":"Labels edges associated split plotted tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LabelSplits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label splits — LabelSplits","text":"","code":"LabelSplits(tree, labels = NULL, unit = \"\", ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/LabelSplits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label splits — LabelSplits","text":"tree tree class phylo. labels Named vector listing annotations split. Names correspond node associated split; see .Splits() details. NULL, splits labelled associated node. unit Character specifying units labels, desired. Include leading space necessary. ... Additional parameters ape::edgelabels().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LabelSplits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label splits — LabelSplits","text":"LabelSplits() returns invisible(), plotting labels relevant edge plot (already produced using plot(tree)).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LabelSplits.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label splits — LabelSplits","text":"two root edges rooted tree denote split, rightmost (plotted bottom, default) edge labelled. position root significant, add tip root using AddTip().","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/LabelSplits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label splits — LabelSplits","text":"","code":"tree <- BalancedTree(LETTERS[1:5]) splits <- as.Splits(tree) plot(tree) LabelSplits(tree, as.character(splits), frame = \"none\", pos = 3L) LabelSplits(tree, TipsInSplits(splits), unit = \" tips\", frame = \"none\",             pos = 1L)   # An example forest of 100 trees, some identical forest <- as.phylo(c(1, rep(10, 79), rep(100, 15), rep(1000, 5)), nTip = 9)  # Generate an 80% consensus tree cons <- ape::consensus(forest, p = 0.8) plot(cons)   # Calculate split frequencies splitFreqs <- SplitFrequency(cons, forest)  # Optionally, colour edges by corresponding frequency. # Note that not all edges are associated with a unique split # (and two root edges may be associated with one split - not handled here) edgeSupport <- rep(1, nrow(cons$edge)) # Initialize trivial splits to 1 childNode <- cons$edge[, 2] edgeSupport[match(names(splitFreqs), childNode)] <- splitFreqs / 100  plot(cons, edge.col = SupportColour(edgeSupport), edge.width = 3)  # Annotate nodes by frequency  LabelSplits(cons, splitFreqs, unit = \"%\",             col = SupportColor(splitFreqs / 100),             frame = \"none\", pos = 3L)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/LeafLabelInterchange.html","id":null,"dir":"Reference","previous_headings":"","what":"Leaf label interchange — LeafLabelInterchange","title":"Leaf label interchange — LeafLabelInterchange","text":"LeafLabelInterchange() exchanges position leaves within tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LeafLabelInterchange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leaf label interchange — LeafLabelInterchange","text":"","code":"LeafLabelInterchange(tree, n = 2L)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/LeafLabelInterchange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leaf label interchange — LeafLabelInterchange","text":"tree tree class phylo. n Integer specifying number leaves whose positions exchanged.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LeafLabelInterchange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leaf label interchange — LeafLabelInterchange","text":"LeafLabelInterchange() returns tree class phylo position n leaves exchanged. tree's internal topology change.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LeafLabelInterchange.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Leaf label interchange — LeafLabelInterchange","text":"Modifies tree switching positions n leaves.  avoid later swaps undoing earlier exchanges, n leaves guaranteed change position.  Note, however, attempt made avoid swapping equivalent leaves, example, pair others' closest relatives.  , relationships within tree guaranteed changed.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/LeafLabelInterchange.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Leaf label interchange — LeafLabelInterchange","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LeafLabelInterchange.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leaf label interchange — LeafLabelInterchange","text":"","code":"tree <- PectinateTree(8) plot(LeafLabelInterchange(tree, 3L))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ListAncestors.html","id":null,"dir":"Reference","previous_headings":"","what":"List ancestors — ListAncestors","title":"List ancestors — ListAncestors","text":"ListAncestors() reports ancestors given node.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ListAncestors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List ancestors — ListAncestors","text":"","code":"ListAncestors(parent, child, node = NULL)  AllAncestors(parent, child)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ListAncestors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List ancestors — ListAncestors","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 1] child Integer vector corresponding second column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 2]. node Integer giving index node tip whose ancestors required, NULL return ancestors nodes.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ListAncestors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List ancestors — ListAncestors","text":"node = NULL, ListAncestors() returns list. entry contains vector containing, order, nodes encountered traversing tree node root node. last entry member list therefore root node, exception entry root node , zero-length integer. node integer, ListAncestors() returns vector numbers nodes ancestral given node, including root node.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ListAncestors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List ancestors — ListAncestors","text":"Note node = NULL, tree's edges must listed internal node (except root) listed child listed parent, .e. index child less index parent. true trees listed Preorder.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ListAncestors.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"List ancestors — ListAncestors","text":"AllAncestors(): Alias ListAncestors(node = NULL).","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ListAncestors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"List ancestors — ListAncestors","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ListAncestors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List ancestors — ListAncestors","text":"","code":"tree <- PectinateTree(5) edge <- tree[[\"edge\"]]  # Identify desired node with: plot(tree) nodelabels() tiplabels()   # Ancestors of specific nodes: ListAncestors(edge[, 1], edge[, 2], 4L) #> [1] 9 8 7 6 ListAncestors(edge[, 1], edge[, 2], 8L) #> [1] 7 6  # Ancestors of each node, if tree numbering system is uncertain: lapply(seq_len(max(edge)), ListAncestors,        parent = edge[, 1], child = edge[, 2]) #> [[1]] #> [1] 6 #>  #> [[2]] #> [1] 7 6 #>  #> [[3]] #> [1] 8 7 6 #>  #> [[4]] #> [1] 9 8 7 6 #>  #> [[5]] #> [1] 9 8 7 6 #>  #> [[6]] #> integer(0) #>  #> [[7]] #> [1] 6 #>  #> [[8]] #> [1] 7 6 #>  #> [[9]] #> [1] 8 7 6 #>   # Ancestors of each node, if tree is in preorder: ListAncestors(edge[, 1], edge[, 2]) #> [[1]] #> [1] 6 #>  #> [[2]] #> [1] 7 6 #>  #> [[3]] #> [1] 8 7 6 #>  #> [[4]] #> [1] 9 8 7 6 #>  #> [[5]] #> [1] 9 8 7 6 #>  #> [[6]] #> integer(0) #>  #> [[7]] #> [1] 6 #>  #> [[8]] #> [1] 7 6 #>  #> [[9]] #> [1] 8 7 6 #>   # Alias: AllAncestors(edge[, 1], edge[, 2]) #> [[1]] #> [1] 6 #>  #> [[2]] #> [1] 7 6 #>  #> [[3]] #> [1] 8 7 6 #>  #> [[4]] #> [1] 9 8 7 6 #>  #> [[5]] #> [1] 9 8 7 6 #>  #> [[6]] #> integer(0) #>  #> [[7]] #> [1] 6 #>  #> [[8]] #> [1] 7 6 #>  #> [[9]] #> [1] 8 7 6 #>"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Lobo.data.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from Zhang et al. 2016 — Lobo.data","title":"Data from Zhang et al. 2016 — Lobo.data","text":"Phylogenetic data Zhang et al. (2016)  raw (Lobo.data) phyDat (Lobo.phy) formats.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Lobo.data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from Zhang et al. 2016 — Lobo.data","text":"","code":"Lobo.data  Lobo.phy"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Lobo.data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from Zhang et al. 2016 — Lobo.data","text":"object class list length 48. object class phyDat length 48.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Lobo.data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data from Zhang et al. 2016 — Lobo.data","text":"Zhang et al. (2016)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Lobo.data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data from Zhang et al. 2016 — Lobo.data","text":"Zhang X, Smith MR, Yang J, Hou J (2016). “Onychophoran-like musculature phosphatized Cambrian lobopodian.” Biology Letters, 12(9), 20160492. doi:10.1098/rsbl.2016.0492 .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Lobo.data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from Zhang et al. 2016 — Lobo.data","text":"","code":"data(\"Lobo\", package = \"TreeTools\") Lobo.data #> $Tubiluchus_Priapulida #>   [1] \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"0\" \"0\" \"1\" \"1\" #>  [19] \"1\" \"1\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [37] \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"-\" \"1\" \"0\" \"0\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [73] \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"-\" \"1\" \"1\" \"1\" \"-\" #> [109] \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" #>  #> $Cricocosmia #>   [1] \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"0\" \"0\" \"1\" \"1\" #>  [19] \"1\" \"?\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [37] \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"-\" \"1\" \"0\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"0\" \"-\" \"1\" \"0\" \"0\" \"1\" \"-\" \"0\" \"0\" \"1\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [73] \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" #>  #> $Aysheaia #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"0\" \"0\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"1\" \"0\" \"-\" \"1\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"0\" \"0\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"0\" \"0\" \"0\" \"0\" \"0\" \"1\" \"0\" \"4\" \"0\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"1\" \"-\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" #>  #> $Siberion #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"0\" \"0\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"1\" \"0\" \"-\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"0\" \"0\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"?\" \"-\" \"-\" \"-\" \"-\" \"1\" \"?\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"?\" \"?\" \"?\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"?\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Onychodictyon_ferox #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"1\" \"1\" \"1\" \"0\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"1\" \"0\" \"1\" \"0\" \"?\" \"1\" \"-\" \"0\" \"0\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"1\" \"-\" \"0\" \"0\" \"0\" \"1\" \"0\" \"1\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"1\" \"-\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Onychodictyon_gracilis #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"?\" \"?\" \"0\" \"0\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"?\" \"-\" \"0\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"?\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"?\" \"?\" \"1\" \"?\" \"?\" \"1\" \"-\" \"0\" \"0\" \"1\" \"0\" \"?\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"0\" \"1\" \"?\" \"0\" \"0\" \"-\" \"0\" \"0\" \"?\" \"?\" \"-\" #>  [91] \"1\" \"0\" \"1\" \"1\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Diania #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"1\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"0\" \"-\" \"0\" \"?\" \"?\" \"0\" \"-\" \"0\" \"0\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"0\" \"0\" \"0\" \"0\" \"0\" \"?\" \"?\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Xenusion #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"?\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"1\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"0\" \"-\" \"0\" \"?\" \"?\" \"1\" \"-\" \"0\" \"0\" \"1\" \"?\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Paucipodia #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"1\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"?\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"0\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Microdictyon #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"0\" \"0\" \"0\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"0\" \"-\" \"1\" \"0\" \"?\" \"1\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"0\" \"1\" \"?\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Cardiodictyon #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"1\" \"0\" \"d\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"0\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"?\" \"?\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"0\" \"-\" \"1\" \"0\" \"?\" \"1\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"0\" \"1\" \"?\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Hallucigenia_sparsa #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"1\" \"0\" \"0\" \"-\" \"1\" \"1\" \"0\" \"0\" \"1\" \"0\" #>  [19] \"1\" \"0\" \"1\" \"1\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"d\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"1\" \"1\" \"1\" #>  [55] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"0\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"0\" \"1\" \"0\" \"-\" #>  [91] \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Hallucigenia_fortis #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"1\" \"0\" \"0\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"0\" \"?\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"d\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"1\" \"?\" \"1\" \"1\" \"1\" #>  [55] \"1\" \"1\" \"1\" \"?\" \"?\" \"1\" \"0\" \"0\" \"0\" \"0\" \"0\" \"1\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"0\" \"1\" \"?\" \"0\" \"0\" \"-\" \"0\" \"0\" \"0\" \"0\" \"-\" #>  [91] \"?\" \"0\" \"0\" \"-\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Hallucigenia_hongmeia #>   [1] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"?\" \"?\" \"0\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"1\" \"?\" \"1\" \"1\" \"1\" #>  [55] \"1\" \"1\" \"1\" \"0\" \"?\" \"1\" \"0\" \"1\" \"0\" \"0\" \"?\" \"?\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"?\" \"?\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Luolishania #>   [1] \"1\" \"1\" \"0\" \"0\" \"-\" \"-\" \"-\" \"?\" \"1\" \"0\" \"0\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"d\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" #>  [55] \"1\" \"1\" \"1\" \"?\" \"?\" \"2\" \"0\" \"1\" \"1\" \"1\" \"0\" \"1\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"0\" \"1\" \"1\" \"0\" \"0\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"2\" \"1\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Collinsium #>   [1] \"1\" \"1\" \"0\" \"0\" \"-\" \"-\" \"-\" \"1\" \"0\" \"0\" \"0\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"d\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"1\" \"0\" \"1\" \"1\" \"1\" #>  [55] \"1\" \"1\" \"1\" \"0\" \"1\" \"4\" \"0\" \"1\" \"1\" \"1\" \"0\" \"1\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"0\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"3\" \"1\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Collins_monster_Burgess_Shale #>   [1] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"0\" \"-\" \"d\" \"-\" \"0\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"1\" \"0\" \"1\" \"1\" \"1\" #>  [55] \"1\" \"1\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"1\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"-\" \"0\" \"0\" \"3\" \"1\" \"-\" #>  [91] \"?\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Collins_monster_Emu_Bay #>   [1] \"1\" \"1\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"d\" \"-\" \"0\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"1\" \"0\" \"1\" \"1\" \"1\" #>  [55] \"1\" \"1\" \"1\" \"?\" \"?\" \"2\" \"0\" \"1\" \"?\" \"?\" \"?\" \"1\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"0\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"2\" \"1\" \"-\" #>  [91] \"?\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Acinocrinus #>   [1] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"0\" \"-\" \"d\" \"-\" \"0\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"1\" \"0\" \"1\" \"1\" \"1\" #>  [55] \"1\" \"1\" \"1\" \"?\" \"?\" \"5\" \"1\" \"1\" \"?\" \"?\" \"0\" \"1\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"-\" \"0\" \"0\" \"2\" \"1\" \"-\" #>  [91] \"?\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Orstenotubulus #>   [1] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"?\" \"?\" \"?\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"1\" \"1\" \"1\" \"1\" \"1\" #>  [55] \"?\" \"?\" \"?\" \"?\" \"?\" \"1\" \"0\" \"1\" \"?\" \"1\" \"?\" \"?\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"1\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"-\" \"0\" \"0\" \"?\" \"?\" \"-\" #>  [91] \"?\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Tritonychus #>   [1] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"?\" \"?\" \"?\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"?\" \"1\" \"?\" \"?\" \"?\" #>  [55] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"1\" \"?\" \"?\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"1\" \"1\" \"0\" \"1\" \"?\" \"2\" \"0\" \"0\" \"0\" \"-\" \"0\" \"0\" \"?\" \"?\" \"?\" #>  [91] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"0\" \"1\" \"?\" \"?\" #>  #> $Carbotubulus #>   [1] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"?\" \"?\" \"?\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"?\" \"?\" \"?\" #>  [55] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"-\" \"?\" \"1\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"-\" \"0\" \"0\" \"?\" \"?\" \"-\" #>  [91] \"0\" \"0\" \"?\" \"e\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" #>  #> $Antennacanthopodia #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"?\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" \"-\" \"0\" \"1\" \"-\" \"1\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"?\" \"-\" \"-\" \"-\" \"-\" \"?\" \"?\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"1\" \"?\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Helenodora #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"?\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"1\" \"0\" \"-\" \"0\" \"?\" \"-\" \"?\" \"?\" \"1\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"?\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"?\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"1\" \"?\" \"0\" \"1\" \"0\" \"1\" \"0\" \"?\" \"0\" \"-\" \"0\" \"0\" \"?\" \"?\" \"-\" #>  [91] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Euperipatoides_Onychophora #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"0\" \"-\" \"-\" \"1\" \"0\" #>  [19] \"0\" \"-\" \"-\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" \"-\" \"0\" \"1\" \"-\" \"2\" \"0\" \"1\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"0\" \"1\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"1\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"1\" \"1\" \"2\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" #> [109] \"1\" \"0\" \"1\" \"0\" \"1\" \"1\" \"1\" #>  #> $Plicatoperipatus_Onychophora #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"0\" \"-\" \"-\" \"1\" \"0\" #>  [19] \"0\" \"-\" \"-\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" \"-\" \"0\" \"1\" \"-\" \"2\" \"1\" \"1\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"0\" \"1\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"1\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"1\" \"1\" \"2\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" #> [109] \"1\" \"0\" \"1\" \"0\" \"1\" \"1\" \"1\" #>  #> $Ooperipatellus_Onychophora #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"0\" \"-\" \"-\" \"1\" \"0\" #>  [19] \"0\" \"-\" \"-\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" \"-\" \"0\" \"1\" \"-\" \"2\" \"1\" \"1\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"0\" \"1\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"1\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"1\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"1\" \"1\" \"2\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" #> [109] \"1\" \"0\" \"1\" \"0\" \"1\" \"1\" \"1\" #>  #> $Actinarctus_Heterotardigrada #>   [1] \"1\" \"1\" \"0\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"1\" \"1\" \"0\" \"0\" \"1\" \"0\" \"0\" \"1\" \"0\" #>  [19] \"1\" \"0\" \"0\" \"1\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"1\" \"1\" \"0\" #>  [55] \"0\" \"-\" \"1\" \"0\" \"0\" \"?\" \"?\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"1\" \"1\" \"0\" \"3\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"1\" \"-\" \"1\" \"1\" \"1\" \"0\" \"0\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"0\" \"1\" #> [109] \"1\" \"?\" \"-\" \"1\" \"0\" \"0\" \"-\" #>  #> $Halobiotus_Eutardigrada #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"0\" \"0\" \"1\" \"0\" #>  [19] \"1\" \"0\" \"0\" \"1\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"2\" #>  [37] \"0\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"0\" \"?\" \"?\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"1\" \"-\" \"1\" \"1\" \"1\" \"0\" \"0\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"0\" \"1\" #> [109] \"1\" \"1\" \"-\" \"1\" \"0\" \"0\" \"-\" #>  #> $Siberian_Orsten_tardigrade #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"0\" \"0\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"b\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"?\" \"?\" \"?\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"?\" \"?\" \"?\" #>  [55] \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"-\" \"-\" \"-\" \"?\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"a\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Megadictyon #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"?\" \"0\" \"0\" \"?\" \"?\" \"?\" \"1\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"0\" \"-\" \"-\" \"1\" \"0\" \"-\" \"1\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"0\" \"?\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"?\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"1\" \"-\" \"0\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"?\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Jianshanopodia #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"?\" \"?\" \"1\" \"0\" #>  [19] \"1\" \"1\" \"0\" \"0\" \"-\" \"-\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"?\" \"?\" \"?\" \"1\" \"0\" \"-\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"1\" \"0\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"?\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"1\" \"1\" \"-\" \"0\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Hadranax #>   [1] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" \"0\" \"?\" \"-\" \"?\" \"?\" \"?\" \"-\" \"?\" #>  [37] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"0\" \"1\" \"1\" \"?\" \"1\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"0\" \"-\" \"0\" \"-\" \"?\" \"3\" \"-\" \"-\" \"0\" \"1\" \"?\" \"0\" \"0\" \"-\" \"0\" \"-\" \"-\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"1\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"?\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Kerygmachela #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"0\" \"1\" \"0\" \"0\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"0\" #>  [37] \"1\" \"0\" \"-\" \"1\" \"0\" \"-\" \"1\" \"0\" \"0\" \"0\" \"1\" \"1\" \"0\" \"1\" \"0\" \"1\" \"1\" \"0\" #>  [55] \"0\" \"-\" \"0\" \"-\" \"?\" \"3\" \"-\" \"?\" \"0\" \"1\" \"1\" \"0\" \"1\" \"0\" \"0\" \"1\" \"0\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"0\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"0\" \"?\" \"?\" \"?\" #>  #> $Pambdelurion #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"1\" \"0\" \"0\" \"1\" \"0\" \"0\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"0\" \"-\" \"-\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"1\" \"0\" \"-\" \"1\" \"0\" \"-\" \"?\" \"0\" \"0\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [55] \"?\" \"?\" \"?\" \"?\" \"?\" \"-\" \"-\" \"?\" \"-\" \"?\" \"1\" \"0\" \"1\" \"0\" \"0\" \"1\" \"0\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"1\" \"1\" \"0\" \"-\" #>  #> $Opabinia #>   [1] \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"2\" \"1\" \"0\" \"?\" \"?\" \"?\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"0\" \"1\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"1\" \"1\" \"0\" \"1\" \"0\" \"-\" \"1\" \"1\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"1\" \"0\" \"0\" \"1\" \"1\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" #>  [91] \"?\" \"1\" \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Anomalocaris_canadensis #>   [1] \"1\" \"1\" \"0\" \"1\" \"0\" \"0\" \"0\" \"0\" \"?\" \"0\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"1\" \"0\" \"-\" \"1\" \"1\" \"0\" \"1\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"1\" \"1\" \"0\" \"1\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"1\" \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"1\" \"?\" \"?\" \"?\" #>  #> $Peytoia_nathorsti #>   [1] \"1\" \"1\" \"0\" \"1\" \"1\" \"0\" \"0\" \"0\" \"?\" \"0\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"1\" \"0\" \"-\" \"1\" \"0\" \"-\" \"1\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"1\" \"0\" \"1\" \"0\" \"0\" \"1\" \"1\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"1\" \"1\" \"0\" \"1\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Hurdia_victoria #>   [1] \"1\" \"1\" \"0\" \"1\" \"1\" \"0\" \"1\" \"0\" \"?\" \"0\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" #>  [19] \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"?\" \"?\" \"?\" \"1\" \"0\" \"-\" \"1\" \"?\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"?\" \"0\" \"1\" \"0\" \"0\" \"1\" \"1\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"1\" \"0\" \"0\" \"1\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Aegirocassis_benmoulae #>   [1] \"1\" \"1\" \"0\" \"1\" \"1\" \"0\" \"1\" \"0\" \"?\" \"0\" \"?\" \"1\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"?\" \"?\" \"?\" \"1\" \"0\" \"-\" \"1\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"?\" \"0\" \"1\" \"0\" \"0\" \"1\" \"1\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"1\" \"1\" \"0\" \"?\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Lyrarapax_unguispinus #>   [1] \"1\" \"1\" \"0\" \"1\" \"0\" \"0\" \"0\" \"0\" \"?\" \"0\" \"1\" \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"1\" \"0\" \"-\" \"1\" \"0\" \"-\" \"1\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"1\" \"0\" \"0\" \"0\" \"1\" \"0\" #>  [73] \"0\" \"-\" \"-\" \"0\" \"0\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"?\" \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"1\" \"1\" \"0\" \"1\" \"?\" \"?\" \"1\" \"0\" \"0\" \"1\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"1\" \"?\" \"?\" \"?\" #>  #> $Schinderhannes #>   [1] \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"0\" \"1\" \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"0\" \"1\" \"1\" \"1\" \"?\" \"?\" \"-\" \"0\" \"-\" \"0\" \"-\" \"1\" #>  [37] \"1\" \"0\" \"-\" \"1\" \"1\" \"0\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [55] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  [73] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"1\" \"?\" \"-\" \"-\" \"-\" #>  [91] \"0\" \"0\" \"1\" \"0\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Fuxianhuia #>   [1] \"1\" \"1\" \"0\" \"1\" \"0\" \"1\" \"-\" \"0\" \"-\" \"-\" \"2\" \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"1\" \"0\" \"-\" \"-\" \"-\" \"1\" \"1\" #>  [37] \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"1\" \"1\" \"1\" \"-\" \"0\" \"0\" #>  [73] \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"1\" #>  [91] \"-\" \"0\" \"1\" \"0\" \"1\" \"?\" \"?\" \"1\" \"2\" \"1\" \"1\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"1\" \"1\" \"0\" \"0\" \"-\" #>  #> $Chengjiangocaris #>   [1] \"1\" \"1\" \"0\" \"1\" \"0\" \"1\" \"-\" \"0\" \"-\" \"-\" \"2\" \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"1\" \"0\" \"-\" \"-\" \"-\" \"1\" \"1\" #>  [37] \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"1\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"1\" \"1\" \"1\" \"-\" \"0\" \"0\" #>  [73] \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"0\" \"0\" \"-\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"1\" #>  [91] \"-\" \"0\" \"1\" \"0\" \"1\" \"?\" \"1\" \"?\" \"?\" \"?\" \"?\" \"?\" \"0\" \"?\" \"1\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Leanchoilia #>   [1] \"1\" \"1\" \"1\" \"0\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"2\" \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"1\" \"1\" \"-\" \"-\" \"-\" \"0\" \"1\" #>  [37] \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"1\" \"?\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"1\" \"-\" \"1\" \"1\" \"1\" \"-\" \"0\" \"1\" #>  [73] \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"0\" \"c\" \"?\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" #>  [91] \"-\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Alalcomenaeus #>   [1] \"1\" \"1\" \"1\" \"0\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"2\" \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"1\" \"1\" \"?\" \"?\" \"-\" \"1\" \"1\" \"-\" \"-\" \"-\" \"0\" \"1\" #>  [37] \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"1\" \"?\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"1\" \"-\" \"1\" \"1\" \"1\" \"-\" \"0\" \"1\" #>  [73] \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" #>  [91] \"-\" \"0\" \"0\" \"-\" \"-\" \"?\" \"1\" \"1\" \"2\" \"1\" \"1\" \"1\" \"0\" \"0\" \"0\" \"-\" \"-\" \"?\" #> [109] \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #>  #> $Misszhouia_longicaudata #>   [1] \"1\" \"1\" \"1\" \"1\" \"0\" \"1\" \"-\" \"0\" \"-\" \"-\" \"2\" \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"1\" \"0\" \"-\" \"-\" \"-\" \"0\" \"1\" #>  [37] \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"1\" \"-\" \"1\" \"2\" \"1\" \"-\" \"0\" \"1\" #>  [73] \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" #>  [91] \"-\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"1\" \"?\" \"?\" \"?\" #>  #> $Kuamaia_lata #>   [1] \"1\" \"1\" \"1\" \"1\" \"0\" \"1\" \"-\" \"0\" \"-\" \"-\" \"2\" \"1\" \"0\" \"0\" \"-\" \"-\" \"?\" \"0\" #>  [19] \"?\" \"?\" \"?\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"0\" \"-\" \"1\" \"0\" \"-\" \"-\" \"-\" \"0\" \"1\" #>  [37] \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" \"-\" \"1\" \"1\" \"1\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" \"-\" #>  [55] \"-\" \"-\" \"-\" \"-\" \"0\" \"-\" \"-\" \"-\" \"-\" \"-\" \"1\" \"-\" \"1\" \"2\" \"1\" \"-\" \"0\" \"1\" #>  [73] \"-\" \"-\" \"-\" \"-\" \"-\" \"0\" \"1\" \"0\" \"2\" \"1\" \"0\" \"0\" \"-\" \"0\" \"0\" \"-\" \"-\" \"0\" #>  [91] \"-\" \"0\" \"0\" \"-\" \"-\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\" #> [109] \"?\" \"?\" \"?\" \"1\" \"?\" \"?\" \"?\" #>  Lobo.phy #> $Tubiluchus_Priapulida #>   [1] 1 1 7 7 7 7 1 1 1 1 1 7 1 2 1 2 2 2 2 1 1 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 #>  [38] 7 1 7 7 7 1 1 1 2 7 2 1 1 1 7 7 7 7 7 7 1 7 7 7 7 2 1 1 7 7 7 7 7 7 7 7 7 #>  [75] 7 7 1 7 1 7 7 1 1 7 1 1 7 7 7 7 1 1 7 7 1 1 1 7 7 1 7 7 2 2 2 7 7 1 1 1 2 #> [112] 2 2 #>  #> $Cricocosmia #>   [1]  1  1  7  7  7  7  1  1  1  1  1  7  1  2  1  2  2  2 13  1  1  7  7  7  7 #>  [26]  7  7  7  7  7  7  7  7  7  7  7  7  7  1  7  7  7  1  1  1  2  7  2  1  1 #>  [51]  2  2  1  1  7  2  1  1  2  7  1  1  2  1  1  7  7  7  7  7  7  7  7  7  7 #>  [76]  7  1  7  1  7  7  1  1  7  1  1  7  7  7  7  1  1  7  7  1 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  1 13 13 13 #>  #> $Aysheaia #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7  1  2  1 13  1 13 13 13  1  7  7  1  2 #>  [26]  1  7  1  1  7  1  7  1  7  1  1  7  7  2  1  7  2  1  1  1  2  2  2  1  1 #>  [51]  1  7  7  7  7  7  7  1  7  7  7  7  2  1  1  1  7  1  7  7  1  2  1  1  1 #>  [76]  1  1  2  1  5  1  1  1  7  1  1  7  7  7  1  1  2  2  7  2 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  1 13 13 13 #>  #> $Siberion #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7  1  2  1 13  1 13 13 13  1  7  7  1  2 #>  [26]  1  7  1  1  7  1  7  1  7  1  2  1  7 13 13 13 13  1  1  1  2  2 13  1  1 #>  [51]  1  7  7  7  7  7  7 13  7  7  7  7  2 13  1  1  7  1  7  7  1 13 13 13  1 #>  [76]  1 13 13 13 13 13 13  1  7  1  1  7  7  7 13  1 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Onychodictyon_ferox #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7  1 13 13 13  1 13 13 13  2  1  1  1  2 #>  [26]  1  7  1  1  7  1  7  1  7  1  1  7  7  2  2  2  1  1  1  1  2  2  2  2  1 #>  [51]  2  2  1  2  1  2  1 13  2  7  1  1  2  1  1  1  7  1  7  7  1  2  2  7  1 #>  [76]  1  1  2  1  2  2  1  1  7  1  1  7  7  7  1  1  2  2  7  2 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Onychodictyon_gracilis #>   [1]  2  1  7  7  7  7  1 13 13  1  1  7  1 13 13 13  1 13 13 13 13 13 13  1 13 #>  [26] 13 13  1 13  7 13  7  1  7 13 13 13 13 13 13 13 13  1  1  1  2  2  1 13  1 #>  [51]  2  2  1 13 13  2 13 13  2  7  1  1  2  1 13  1  7  1  7  7  1 13 13 13  1 #>  [76]  1  1  2  1  2 13  1  1  7  1  1 13 13  7  2  1  2  2  7  1 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Diania #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7 13 13 13 13  1 13 13 13  1  7  7  1  1 #>  [26]  7  7  1  1  7  1  7  1  7  1  1  7  7  1  7  7  7  1  1  1  2  2  1  2  1 #>  [51]  2  2  1  1  7  1 13 13  1  7  1  1  2  1  1  1  7  1  7  7  1  2  1  1  1 #>  [76]  1  1 13 13  7  7  1  1  7  1  1  7  7  7  2  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Xenusion #>   [1]  2  1  7  7  7  7  1 13  1  1 13 13 13 13 13 13 13 13 13 13  1  7  7  1  1 #>  [26]  7  7  1  1  7  1  7  1  7  1  1  7  7 13 13 13 13  1  1  1  2  2 13  2  1 #>  [51]  2  2  1  1  7  1 13 13  2  7  1  1  2 13  1  1  7  1  7  7  1  2 13 13 13 #>  [76] 13 13 13 13 13 13 13  1  7  1  1  7  7  7  2  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Paucipodia #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7 13 13 13 13  1  2 13 13  1  7  7  1  1 #>  [26]  7  7  1  1  7  1  7  1  7  1  1  7  7  1  7  7  7  1  1  1  2  2  1  1  1 #>  [51]  1  7  7  7  7  7  7 13  7  7  7  7  1  1  1  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  1  2  1  2  1  1  1  7  1  1  7  7  7  2  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Microdictyon #>   [1]  2  1  7  7  7  7  1  2  1  1  1  7 13 13 13 13  1 13 13 13  1  7  7  1  1 #>  [26]  7  7  1  1  7  1  7  1  7  1  1  7  7  1  7  7  7  1  1  1  2  2  2  2  1 #>  [51]  2  2  1  1  7  2  1 13  2  7  1  1  1  1  1  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  1  2  1  2 13  1  1  7  1  1  7  7  7  2  1  1  7  7  1 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Cardiodictyon #>   [1]  2  1  7  7  7  7  1  2  2  1 11 13 13 13 13 13  1 13 13 13  2  1 13  1 13 #>  [26] 13 13  1 13  7 13 13  1  7  1  1  7  7  1  7  7  7  1  1  1  2  2  2  2  1 #>  [51]  2  2  1  1  7  2  1 13  2  7  1  1  1  1  1  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  1  2  1  2 13  1  1  7  1  1  7  7  7  2  1  1  7  7  1 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Hallucigenia_sparsa #>   [1]  2  1  7  7  7  7  1  2  2  1  1  7  2  2  1  2  1  2  1  2  2  1  1  1  1 #>  [26]  7  7  1  1  7 11  7  1  7  1  1  7  7  1  7  7  7  1  1  1  1  7  7  7  7 #>  [51]  2  2  2  2  2  2  2  2  2  1  1  1  7  1  2  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  1  2  1  2  1  1  1  7  1  1  2  1  7  1  1  1  7  7  1 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Hallucigenia_fortis #>   [1]  2  1  7  7  7  7  1  2  2  1  1  7 13 13 13 13  1 13 13 13  2  1 13  1  1 #>  [26]  7  7  1  1  7 11  7  1  7  1  1  7  7  1  7  7  7  1  1  1  2  2  2  2 13 #>  [51]  2  2  2  2  2  2 13 13  2  1  1  1  1  1  2  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  1  2  1  2 13  1  1  7  1  1  1  1  7 13  1  1  7  7  1 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Hallucigenia_hongmeia #>   [1]  2 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13  1 13 #>  [26] 13 13  1 13  7 13 13  1  7 13 13 13 13 13 13 13 13  1  1  1  2  2 13  2 13 #>  [51]  2  2  2  2  2  2  1 13  2  1  2  1  1 13 13  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  1  2  1  1  7  1  1  7  1  1 13 13  7  2  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Luolishania #>   [1]  2  2  1  1  7  7  7 13  2  1  1  7 13 13 13 13  1 13 13 13  2  1  1  1  2 #>  [26]  1  7  1  1  7 11  7  1  7  1  1  7  7  1  7  7  7  1  1  1  2  2  2  2  1 #>  [51]  2  2  2  2  2  2 13 13  3  1  2  2  2  1  2  1  7  1  7  7  1  2  1  2  2 #>  [76]  1  1  2  1  1  7  1  1  7  1  1  3  2  7  2  1  1  7  7  1 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Collinsium #>   [1]  2  2  1  1  7  7  7  2  1  1  1  7 13 13 13 13 13 13 13 13  1  7  7  1  2 #>  [26]  1  7  1  1  7 11  7  1  7  1  1  7  7  1  7  7  7  1  1  1  2  2  1  2  1 #>  [51]  2  2  2  2  2  2  1  2  5  1  2  2  2  1  2  1  7  1  7  7  1  2  1  2  1 #>  [76]  1  1  2  1  1  7  1  1  7  1  1  4  2  7  2  1  1  7  7  1 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Collins_monster_Burgess_Shale #>   [1]  2 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13  1 13 #>  [26] 13 13  1  1  7 11  7  1  7 13 13 13 13 13 13 13 13  1  1  1  2  2 13  2  1 #>  [51]  2  2  2  2  2  2 13 13 13 13 13 13 13 13  2  1  7  1  7  7  1  2  1  2 13 #>  [76] 13 13 13 13 13 13 13  1  7  1  1  4  2  7 13  1 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Collins_monster_Emu_Bay #>   [1]  2  2  1 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13  1 13 #>  [26] 13 13  1 13  7 11  7  1  7 13 13 13 13 13 13 13 13  1  1  1  2  2 13  2  1 #>  [51]  2  2  2  2  2  2 13 13  3  1  2 13 13 13  2  1  7  1  7  7  1  2  1  2  1 #>  [76]  1  1  2  1  1  7  1  1  7  1  1  3  2  7 13  1 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Acinocrinus #>   [1]  2 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13  1 13 #>  [26] 13 13  1  1  7 11  7  1  7 13 13 13 13 13 13 13 13  1  1  1  2  2 13  2  1 #>  [51]  2  2  2  2  2  2 13 13  6  2  2 13 13  1  2  1  7  1  7  7  1  2  1  2 13 #>  [76] 13 13 13 13 13 13 13  1  7  1  1  3  2  7 13  1 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Orstenotubulus #>   [1]  2 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13  1 13 #>  [26] 13 13  1 13  7 13 13 13  7 13 13 13 13 13 13 13 13  1  1  1  2  2 13  2  2 #>  [51]  2  2  2 13 13 13 13 13  2  1  2 13  2 13 13  1  7  1  7  7  1  1  7  7  2 #>  [76]  2 13 13 13 13 13 13  1  7  1  1 13 13  7 13  1 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Tritonychus #>   [1]  2 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13  1 13 #>  [26] 13 13  1 13  7 13 13 13  7 13 13 13 13 13 13 13 13  1  1  1  2  2 13 13  2 #>  [51] 13 13 13 13 13 13 13 13 13 13 13 13  2 13 13  1  7  1  7  7  1  1  7  7  2 #>  [76]  2  1  2 13  3  1  1  1  7  1  1 13 13 13 13 13 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  1  2 13 13 #>  #> $Carbotubulus #>   [1]  2 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13  1 13 #>  [26] 13 13  1 13  7 13 13 13  7 13 13 13 13 13 13 13 13  1  1  1  1  7  7  7  7 #>  [51] 13 13 13 13 13 13 13 13 13 13 13 13  7 13  2  1  7  1  7  7  1  1  7  7  1 #>  [76]  1 13 13 13 13 13 13  1  7  1  1 13 13  7  1  1 13 12  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  1 13 13 13 #>  #> $Antennacanthopodia #>   [1]  2  1  7  7  7  7  1 13  1  1 13 13 13 13 13 13 13 13 13 13  2  1  1  1  2 #>  [26]  1  7  1  2  7  2  7  1  7  1  1  7  7  1  7  7  7  1  1  1  2 13 13 13 13 #>  [51]  1  7  7  7  7  7  7 13  7  7  7  7 13 13  1  1  7  1  7  7  1  1  7  7  2 #>  [76] 13  1  1  1  7  7  1  1  7  1  1  7  7  7  2  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Helenodora #>   [1]  2  1  7  7  7  7  1 13  1  1 13 13 13 13 13 13 13 13 13 13 13 13 13  1  2 #>  [26]  1  7  1 13  7 13 13  2  7  1  1  7  7  1  7  7  7  1  1  1 13 13 13 13 13 #>  [51]  1  7  7  7  7  7  7 13  7  7  7  7  2  1 13  1  7  1  7  7  1  1  7  7  2 #>  [76] 13  1  2  1  2  1 13  1  7  1  1 13 13  7 13 13 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Euperipatoides_Onychophora #>   [1] 2 1 7 7 7 7 1 1 1 1 2 2 2 1 7 2 1 1 7 7 2 1 1 1 2 1 7 1 2 7 3 1 2 7 1 1 7 #>  [38] 7 1 7 7 7 1 1 1 2 2 1 1 2 1 7 7 7 7 7 7 2 7 7 7 7 2 1 1 1 7 1 7 7 1 1 7 7 #>  [75] 2 2 1 2 1 2 1 2 1 7 1 1 7 7 7 2 1 1 7 7 1 1 2 2 3 1 2 2 2 2 2 1 2 1 2 1 2 #> [112] 2 2 #>  #> $Plicatoperipatus_Onychophora #>   [1] 2 1 7 7 7 7 1 1 1 1 2 2 2 1 7 2 1 1 7 7 2 1 1 1 2 1 7 1 2 7 3 2 2 7 1 1 7 #>  [38] 7 1 7 7 7 1 1 1 2 2 1 1 2 1 7 7 7 7 7 7 2 7 7 7 7 2 1 1 1 7 1 7 7 1 1 7 7 #>  [75] 2 2 1 2 1 2 1 2 1 7 1 1 7 7 7 2 1 1 7 7 1 1 2 2 3 1 2 2 2 2 2 1 2 1 2 1 2 #> [112] 2 2 #>  #> $Ooperipatellus_Onychophora #>   [1] 2 1 7 7 7 7 1 1 1 1 2 2 2 1 7 2 1 1 7 7 2 1 1 1 2 1 7 1 2 7 3 2 2 7 1 1 7 #>  [38] 7 1 7 7 7 1 1 1 2 2 1 1 2 1 7 7 7 7 7 7 2 7 7 7 7 2 1 1 1 7 1 7 7 1 1 7 7 #>  [75] 2 2 1 2 1 2 1 2 1 7 1 1 7 7 7 2 1 1 7 7 1 1 2 2 3 1 2 2 2 2 2 1 2 1 2 1 2 #> [112] 2 2 #>  #> $Actinarctus_Heterotardigrada #>   [1]  2  2  1  1  7  7  7  1  1  2  2  1  1  2  1  2  1  2  1  1  2  1  1  1  2 #>  [26]  2  1  1  1  7  1  7  1  7  2  1  7  7  1  7  7  7  1  1  1  1  7  7  7  7 #>  [51]  2  2  1  1  7  2  1  1 13 13  7  7  7  1  1  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  2  2  1  4  2  1  1  7  1  1  7  7  7  1  1  2  2  7  2  2  2  1  1  2 #> [101]  1  2  2  2  1  2  2 13  7  2  1  1  7 #>  #> $Halobiotus_Eutardigrada #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7  1  2  1  2  1  2  1  1  2  1  1  1  2 #>  [26]  2  1  1  1  7  1  7  1  7  3  1  7  7  1  7  7  7  1  1  1  1  7  7  7  7 #>  [51]  2  1  7  7  7  7  7  1 13 13  7  7  7  1  1  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  2  2  2  2  2  1  1  7  1  1  7  7  7  1  1  2  2  7  2  2  2  1  1  2 #> [101]  1  2  2  2  1  2  2  2  7  2  1  1  7 #>  #> $Siberian_Orsten_tardigrade #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7  1  2  1 13 13 13 13 13 13  9 13  1 13 #>  [26] 13 13  1 13  7 13 13 13  7 13 13 13 13 13 13 13 13  1  1  1  1  7  7  7  7 #>  [51] 13 13 13  7  7 13 13 13 13 13  7  7  7 13  1  1  7  1  7  7  1  1  7  7  1 #>  [76]  1  1  2  2  2  2  1  1  7  1  1  7  7  7  1  1  2  8  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Megadictyon #>   [1]  2  1  7  7  7  7  1 13  1  1 13 13 13  2 13 13  1 13 13 13  1  7  7  1  2 #>  [26]  1  7  1  1  7  1  7  1  7  1  1  7  7  2  1  7  2  1  1  1  2  2 13  1 13 #>  [51]  1  7  7  7  7  7  7 13  7  7  7  7  1  2  1  1  7  1  7  7  1  2  2  7  1 #>  [76]  1  1 13 13 13 13  1  1  7  1  1  7  7  7 13  1 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Jianshanopodia #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7  1  2 13  2  1  2  2  1  1  7  7  1  2 #>  [26]  1  7  1  1  7  1  7  1  7  1 13 13 13  2  1  7 13  1  1  1  2  2 13  2  1 #>  [51]  1  7  7  7  7  7  7 13  7  7  7  7  1  2  1  1  7  1  7  7  1  2  2  7  1 #>  [76]  1  1 13 13 13 13  1  1  7  1  1  7  7  7  1  1  2  1  2 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Hadranax #>   [1]  2 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13  1 13 #>  [26] 13 13  1 13  7 13 13 13  7 13 13 13 13 13 13 13 13  1  1  1  2  2 13  2  1 #>  [51]  2  2  1  1  7  1  7 13  4  7  7  1  2 13  1  1  7  1  7  7  1  1  7  7  2 #>  [76]  1 13 13 13 13 13  1  1  7  1  1  7  7  7 13  1 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Kerygmachela #>   [1]  2  1  7  7  7  7  1  1  1  1  1  7  1  2  1 13  1 13 13 13 13 13 13  1  2 #>  [26]  1  7  1  1  7  1  7  1  7  1  2  1  7  2  1  7  2  1  1  1  2  2  1  2  1 #>  [51]  2  2  1  1  7  1  7 13  4  7 13  1  2  2  1  2  1  1  2  1  1  1  7  7  1 #>  [76]  1  1  1  1  7  7  1  1  1  1  1  7  7  7  1  1  2  1  1 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  1 13 13 13 #>  #> $Pambdelurion #>   [1]  2  1  7  7  7  7  1  1  1  1  2  1  1  2  1 13  1 13 13 13  1  7  7  1  2 #>  [26]  1  7  1  1  7  1  7  1  7  2  2  1  7  2  1  7 13  1  1  1  2 13 13 13 13 #>  [51] 13 13 13 13 13 13 13 13  7  7 13  7 13  2  1  2  1  1  2  1  1  1  7  7  1 #>  [76]  1  1  1  1  7  7  1  1  1  1  1  7  7  7 13 13 13 13 13 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  2  2  1  7 #>  #> $Opabinia #>   [1]  2  1  7  7  7  7  1  1  1  1  3  2  1 13 13 13  1 13 13 13  2  2  2  1  2 #>  [26]  1  7  1  1  7  1  7  1  7  2  2  2  1  2  1  7  2  2  1  1  1  7  7  7  7 #>  [51]  1  7  7  7  7  7  7  7  7  7  7  7  7  2  1  2  1  1  2  2  1  1  7  7  1 #>  [76]  1  1  1  1  7  7  1  1  1  1  1  7  7  7 13  2  2  1  2 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Anomalocaris_canadensis #>   [1]  2  2  1  2  1  1  1  1 13  1  2  2  1  2  2  2  1 13 13 13  2  2  2  1  2 #>  [26]  2  2  2  1  7  1  7  1  7  2  2  1  7  2  2  1  2  1  1  1  1  7  7  7  7 #>  [51]  1  7  7  7  7  7  7  7  7  7  7  7  7  2  1  2  1  1  1  2  1  1  7  7  1 #>  [76]  1  1  1  1  7  7  1  2  2  1  2  7  7  7  1  2  2  1  2 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  2 13 13 13 #>  #> $Peytoia_nathorsti #>   [1]  2  2  1  2  2  1  1  1 13  1  2  2  1  2  2 13  1 13 13 13  2  2  2  1  2 #>  [26]  2  2  2  1  7  1  7  1  7  2  2  1  7  2  1  7  2  1  1  1  1  7  7  7  7 #>  [51]  1  7  7  7  7  7  7  7  7  7  7  7  7  2  1  2  1  1  2  2  1  1  7  7  1 #>  [76]  1  1  1  1  7  7  1  2  2  1  2  7  7  7  1  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Hurdia_victoria #>   [1]  2  2  1  2  2  1  2  1 13  1  2  2  1  2  2  2  1  2  2  1  2  2  2  1  2 #>  [26]  2  2  2  1  7  1  7  1  7  2 13 13 13  2  1  7  2 13  1  1  1  7  7  7  7 #>  [51]  1  7  7  7  7  7  7  7  7  7  7  7  7 13  1  2  1  1  2  2  1  1  7  7  1 #>  [76]  1  1  1  1  7  7  1  2  1  1  2  7  7  7  1  1  2  1  2 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Aegirocassis_benmoulae #>   [1]  2  2  1  2  2  1  2  1 13  1 13  2  1 13 13 13 13 13 13 13 13 13 13  1  2 #>  [26]  2  2  2  1  7  1  7  1  7  2 13 13 13  2  1  7  2  1  1  1  1  7  7  7  7 #>  [51]  1  7  7  7  7  7  7  7  7  7  7  7  7 13  1  2  1  1  2  2  1  1  7  7  1 #>  [76]  1  1  1  1  7  7  1  2  2  1 13  7  7  7  1  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Lyrarapax_unguispinus #>   [1]  2  2  1  2  1  1  1  1 13  1  2  2  1  2 13 13 13 13 13 13  2  2  2  1  2 #>  [26]  2  2  2  1  7  1  7  1  7  2  2  1  7  2  1  7  2  1  1  1  1  7  7  7  7 #>  [51]  1  7  7  7  7  7  7  7  7  7  7  7  7  1  1  2  1  1  1  2  1  1  7  7  1 #>  [76]  1  1  1  1  7  7  1 13  2  2  2  7  7  7  1  2  2  1  2 13 13  2  1  1  2 #> [101] 13 13 13 13 13 13 13 13 13  2 13 13 13 #>  #> $Schinderhannes #>   [1]  2 13 13 13 13 13 13  1 13  1  2  2  1  2 13 13 13 13 13 13  2  2  2  1  2 #>  [26]  2  2 13 13  7  1  7  1  7  2  2  1  7  2  2  1 13 13 13 13 13 13 13 13 13 #>  [51] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  [76] 13 13 13 13 13 13 13 13 13  2 13  7  7  7  1  1  2  1  2 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Fuxianhuia #>   [1]  2  2  1  2  1  2  7  1  7  7  3  2  1  1  7 13  1 13 13 13  2  2  2  2  2 #>  [26]  2  1  7  2  1  7  7  7  2  2  2  2  2  7  7  7  7  2  2  1  7  7  7  7  7 #>  [51]  7  7  7  7  7  7  7  7  7  7  7  7  7  1  7  2  2  2  7  1  1  7  7  7  7 #>  [76]  7  1  1  1  7  7  1  1  7  1  1  7  7  2  7  1  2  1  2 13 13  2  3  2  2 #> [101] 13 13 13 13 13 13 13 13  2  2  1  1  7 #>  #> $Chengjiangocaris #>   [1]  2  2  1  2  1  2  7  1  7  7  3  2  1  1  7 13  1 13 13 13  2  2  2  2  2 #>  [26]  2  1  7  2  1  7  7  7  2  2  2  2  2  7  7  7  7  2  2  1  7  7  7  7  7 #>  [51]  7  7  7  7  7  7  7  7  7  7  7  7  7  1  7  2  2  2  7  1  1  7  7  7  7 #>  [76]  7  1  1  1  7  7  1  1  7  1  1  7  7  2  7  1  2  1  2 13  2 13 13 13 13 #> [101]  1 13  2 13 13 13 13 13 13 13 13 13 13 #>  #> $Leanchoilia #>   [1]  2  2  2  1  7  7  7  1  7  7  3  2  1  1  7 13  1 13 13 13  2  2  2  2  2 #>  [26]  2  1  7  2  2  7  7  7  1  2  2  2  2  7  7  7  7  2  2 13  7  7  7  7  7 #>  [51]  7  7  7  7  7  7  7  1  7  7  7  7  7  2  7  2  2  2  7  1  2  7  7  7  7 #>  [76]  7  1  2  1 10 13  1  1  7  1  1  7  7  1  7  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13 13 13 13 13 #>  #> $Alalcomenaeus #>   [1]  2  2  2  1  7  7  7  1  7  7  3  2  1  1  7 13  1 13 13 13  2  2  2  2  2 #>  [26] 13 13  7  2  2  7  7  7  1  2  2  2  2  7  7  7  7  2  2 13  7  7  7  7  7 #>  [51]  7  7  7  7  7  7  7  1  7  7  7  7  7  2  7  2  2  2  7  1  2  7  7  7  7 #>  [76]  7  1  2  1  1  7  1  1  7  1  1  7  7  1  7  1  1  7  7 13  2  2  3  2  2 #> [101]  1  1  1  7  7 13 13 13 13 13 13 13 13 #>  #> $Misszhouia_longicaudata #>   [1]  2  2  2  2  1  2  7  1  7  7  3  2  1  1  7 13  1 13 13 13  2  2  2  2  2 #>  [26]  2  1  7  2  1  7  7  7  1  2  2  2  2  7  7  7  7  2  2  2  7  7  7  7  7 #>  [51]  7  7  7  7  7  7  7  1  7  7  7  7  7  2  7  2  3  2  7  1  2  7  7  7  7 #>  [76]  7  1  2  1  1  7  1  1  7  1  1  7  7  1  7  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  2 13 13 13 #>  #> $Kuamaia_lata #>   [1]  2  2  2  2  1  2  7  1  7  7  3  2  1  1  7 13  1 13 13 13  2  2  2  2  2 #>  [26]  2  1  7  2  1  7  7  7  1  2  2  2  2  7  7  7  7  2  2  2  7  7  7  7  7 #>  [51]  7  7  7  7  7  7  7  1  7  7  7  7  7  2  7  2  3  2  7  1  2  7  7  7  7 #>  [76]  7  1  2  1  3  2  1  1  7  1  1  7  7  1  7  1  1  7  7 13 13 13 13 13 13 #> [101] 13 13 13 13 13 13 13 13 13  2 13 13 13 #>  #> attr(,\"class\") #> [1] \"phyDat\" #> attr(,\"weight\") #>   [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [112] 1 1 #> attr(,\"nr\") #> [1] 113 #> attr(,\"nc\") #> [1] 7 #> attr(,\"index\") #>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  15  16  17 #>  [19]  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 #>  [37]  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53 #>  [55]  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71 #>  [73]  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89 #>  [91]  90  91  92  93  94  95  96  97  98  99  97 100 101 102 103 104 105 106 #> [109] 107 108 109 110 111 112 113 #> attr(,\"levels\") #> [1] \"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"-\" #> attr(,\"allLevels\") #>  [1] \"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"-\" \"a\" \"b\" \"c\" \"d\" \"e\" \"?\" #> attr(,\"type\") #> [1] \"USER\" #> attr(,\"contrast\") #>       0 1 2 3 4 5 - #>  [1,] 1 0 0 0 0 0 0 #>  [2,] 0 1 0 0 0 0 0 #>  [3,] 0 0 1 0 0 0 0 #>  [4,] 0 0 0 1 0 0 0 #>  [5,] 0 0 0 0 1 0 0 #>  [6,] 0 0 0 0 0 1 0 #>  [7,] 0 0 0 0 0 0 1 #>  [8,] 0 1 1 0 0 0 0 #>  [9,] 1 0 0 0 0 0 1 #> [10,] 1 0 1 0 0 0 0 #> [11,] 1 1 0 0 0 0 0 #> [12,] 0 1 0 0 0 0 1 #> [13,] 1 1 1 1 1 1 1"},{"path":"https://ms609.github.io/TreeTools/dev/reference/LongBranch.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify taxa with long branches — LongBranch","title":"Identify taxa with long branches — LongBranch","text":"long branch (LB) score (Struck 2014)  measures deviation average pairwise patristic distance leaf leaves tree, relative average leaf--leaf distance.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LongBranch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify taxa with long branches — LongBranch","text":"","code":"LongBranch(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/LongBranch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify taxa with long branches — LongBranch","text":"tree tree class phylo, list trees class list multiPhylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LongBranch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify taxa with long branches — LongBranch","text":"LongBranch() returns vector giving long branch score leaf tree, list vectors tree list. Results given raw deviations, without multiplying 100 proposed Struck (2014) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LongBranch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify taxa with long branches — LongBranch","text":"Struck (2014)  proposes standard deviation LB scores measure heterogeneity can compared trees; upper quartile LB scores \"representative value taxa longest branches\".","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/LongBranch.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify taxa with long branches — LongBranch","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/LongBranch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify taxa with long branches — LongBranch","text":"","code":"tree <- BalancedTree(8, lengths = c(rep(2, 4), 5:7, rep(2, 4), rep(1, 3))) lb <- LongBranch(tree) tree$tip.label <- paste(tree$tip.label, signif(lb, 3), sep = \": \") plot(tree, tip.col = SupportColour((1 - lb) / 2), font = 2)   # Standard deviation of LB scores allows comparison with other trees sd(lb) #> [1] 0.2335139 evenLengths <- BalancedTree(8, lengths = jitter(rep(1, 14))) sd(LongBranch(evenLengths)) #> [1] 0.001698709  # Upper quartile identifies taxa with longest branches threshold <- quantile(lb, 0.75) tree$tip.label[lb > threshold] #> [1] \"t3: 0.333\" \"t4: 0.403\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MRCA.html","id":null,"dir":"Reference","previous_headings":"","what":"Most recent common ancestor — MRCA","title":"Most recent common ancestor — MRCA","text":"MRCA() calculates last common ancestor specified nodes.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MRCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Most recent common ancestor — MRCA","text":"","code":"MRCA(x1, x2, ancestors)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MRCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Most recent common ancestor — MRCA","text":"x1, x2 Integer specifying index leaves nodes whose recent common ancestor found. ancestors List ancestors node tree. Perhaps produced ListAncestors().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MRCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Most recent common ancestor — MRCA","text":"MRCA() returns integer specifying node number last common ancestor x1 x2.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MRCA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Most recent common ancestor — MRCA","text":"MRCA() requires node values within tree increase away root, true trees listed Preorder. warnings given trees fulfil requirement.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/MRCA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Most recent common ancestor — MRCA","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MRCA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Most recent common ancestor — MRCA","text":"","code":"tree <- BalancedTree(7)  # Verify that node numbering increases away from root plot(tree) nodelabels()   # ListAncestors expects a tree in Preorder tree <- Preorder(tree) edge <- tree$edge ancestors <- ListAncestors(edge[, 1], edge[, 2]) MRCA(1, 4, ancestors) #> [1] 9  # If a tree must be in postorder, use: tree <- Postorder(tree) edge <- tree$edge ancestors <- lapply(seq_len(max(edge)), ListAncestors,                     parent = edge[, 1], child = edge[, 2])"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MSTEdges.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimum spanning tree — MSTEdges","title":"Minimum spanning tree — MSTEdges","text":"Calculate plot minimum spanning tree (Gower Ross 1969)  distance matrix.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MSTEdges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimum spanning tree — MSTEdges","text":"","code":"MSTEdges(distances, plot = FALSE, x = NULL, y = NULL, ...)  MSTLength(distances, mst = NULL)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MSTEdges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimum spanning tree — MSTEdges","text":"distances Either matrix can interpreted distance matrix, object class dist. plot Logical specifying whether add minimum spanning tree existing plot. x, y Numeric vectors specifying X Y coordinates element distances.  Necessary plot = TRUE. ... Additional parameters send [lines()]. mst Optional parameter specifying minimum spanning tree format returned MSTEdges(); NULL, calculated distances.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MSTEdges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimum spanning tree — MSTEdges","text":"MSTEdges() returns matrix row corresponds edge minimum spanning tree, listed non-decreasing order length. two columns contain indices entries distances edge connects, lower value listed first. MSTLength() returns length minimum spanning tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MSTEdges.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Minimum spanning tree — MSTEdges","text":"Gower JC, Ross GJS (1969). “Minimum spanning trees single linkage cluster analysis.” Journal Royal Statistical Society. Series C (Applied Statistics), 18(1), 54–64. doi:10.2307/2346439 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/MSTEdges.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Minimum spanning tree — MSTEdges","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MSTEdges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimum spanning tree — MSTEdges","text":"","code":"# Corners of an almost-regular octahedron points <- matrix(c(0, 0, 2, 2, 1.1, 1,                    0, 2, 0, 2, 1, 1.1,                    0, 0, 0, 0, 1, -1), 6) distances <- dist(points) mst <- MSTEdges(distances) MSTLength(distances, mst) #> [1] 8.496869 plot(points[, 1:2], ann = FALSE, asp = 1) MSTEdges(distances, TRUE, x = points[, 1], y = points[, 2], lwd = 2)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MakeTreeBinary.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate binary tree by collapsing polytomies — MakeTreeBinary","title":"Generate binary tree by collapsing polytomies — MakeTreeBinary","text":"MakeTreeBinary() resolves, random, polytomies tree set trees, trees compatible input topology drawn equal probability. Edge lengths yet supported, removed.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MakeTreeBinary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate binary tree by collapsing polytomies — MakeTreeBinary","text":"","code":"MakeTreeBinary(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MakeTreeBinary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate binary tree by collapsing polytomies — MakeTreeBinary","text":"tree tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MakeTreeBinary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate binary tree by collapsing polytomies — MakeTreeBinary","text":"MakeTreeBinary() returns rooted binary tree class phylo, corresponding tree uniformly selected compatible input tree topologies.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/MakeTreeBinary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate binary tree by collapsing polytomies — MakeTreeBinary","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MakeTreeBinary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate binary tree by collapsing polytomies — MakeTreeBinary","text":"","code":"MakeTreeBinary(CollapseNode(PectinateTree(7), c(9, 11, 13))) #>  #> Phylogenetic tree with 7 tips and 6 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length. UnrootTree(MakeTreeBinary(StarTree(5))) #>  #> Phylogenetic tree with 5 tips and 3 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5 #>  #> Unrooted; no branch length."},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchEdges.html","id":null,"dir":"Reference","previous_headings":"","what":"Match nodes and edges between trees — MatchEdges","title":"Match nodes and edges between trees — MatchEdges","text":"MatchNodes() MatchEdges() matches nodes edges one tree entries second denote clade identical tip labels.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchEdges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match nodes and edges between trees — MatchEdges","text":"","code":"MatchEdges(x, table, nomatch = NA_integer_)  MatchNodes(x, table, nomatch = NA_integer_, tips = FALSE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchEdges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match nodes and edges between trees — MatchEdges","text":"x Tree whose nodes matched. table Tree containing nodes matched . nomatch Integer value used place NA case match found. tips Logical specifying whether return matches tips; unless TRUE, matches internal nodes returned.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchEdges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Match nodes and edges between trees — MatchEdges","text":"current implementation potentially inefficient. Please contact maintainer request efficient implementation function proving bottleneck.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchEdges.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Match nodes and edges between trees — MatchEdges","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchEdges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match nodes and edges between trees — MatchEdges","text":"","code":"MatchNodes(BalancedTree(8), RootTree(BalancedTree(8))) #> [1]  9 10 11 12 13 14 15"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchStrings.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for mismatch between character vectors — MatchStrings","title":"Check for mismatch between character vectors — MatchStrings","text":"Checks entries one character vector occur another, suggesting corrections mismatched elements.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchStrings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for mismatch between character vectors — MatchStrings","text":"","code":"MatchStrings(x, table, Fail = stop, max.distance = 0.5, ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchStrings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for mismatch between character vectors — MatchStrings","text":"x, table Character vectors, elements x expected occur table. Fail Function call mismatch found. max.distance, ... Arguments agrep(), used propose possible matches user.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchStrings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for mismatch between character vectors — MatchStrings","text":"MatchStrings() returns elements x occur table.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchStrings.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check for mismatch between character vectors — MatchStrings","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatchStrings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check for mismatch between character vectors — MatchStrings","text":"","code":"tree <- BalancedTree(8) MatchStrings(c(\"t1\", \"tip2\", \"t3\"), TipLabels(tree), Fail = message) #> Could not find 'tip2' in TipLabels(tree).  Did you mean 't2'? #> [1] \"t1\" \"t3\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatrixToPhyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between matrices and phyDat objects — MatrixToPhyDat","title":"Convert between matrices and phyDat objects — MatrixToPhyDat","text":"MatrixToPhyDat() converts matrix tokens phyDat object; PhyDatToMatrix() converts phyDat object matrix tokens.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatrixToPhyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between matrices and phyDat objects — MatrixToPhyDat","text":"","code":"MatrixToPhyDat(tokens)  PhyDatToMatrix(   dataset,   ambigNA = FALSE,   inappNA = ambigNA,   parentheses = c(\"{\", \"}\"),   sep = \"\" )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatrixToPhyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between matrices and phyDat objects — MatrixToPhyDat","text":"tokens Matrix tokens, possibly created ReadCharacters() ReadTntCharacters(). Row names correspond leaf labels; column names may optionally correspond character labels. dataset dataset class phyDat. ambigNA, inappNA Logical specifying whether denote ambiguous / inapplicable characters NA values. parentheses Character vector specifying style parentheses enclose ambiguous characters. c(\"[\", \"]\") \"[]\" render [01]. NULL use token specified phyDat object; beware treated distinct (non-ambiguous) token re-encoding PhyDatToMatrix(). sep Character separate ambiguous tokens, e.g. ',' render [0,1].","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatrixToPhyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between matrices and phyDat objects — MatrixToPhyDat","text":"MatrixToPhyDat() returns object class phyDat. PhyDatToMatrix() returns matrix corresponding uncompressed character states within phyDat object.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatrixToPhyDat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert between matrices and phyDat objects — MatrixToPhyDat","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MatrixToPhyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between matrices and phyDat objects — MatrixToPhyDat","text":"","code":"tokens <- matrix(c(0, 0, \"0\", 0, 0,                    0, 0, \"1\", 0, 1,                    0, 0, \"1\", 0, 1,                    0, 0, \"2\", 0, 1,                    1, 1, \"-\", 1, 0,                    1, 1, \"2\", 1, \"{01}\"),                    nrow = 6, ncol = 5, byrow = TRUE,                    dimnames = list(                      paste0(\"Taxon_\", LETTERS[1:6]),                      paste0(\"Char_\", 1:5)))                     MatrixToPhyDat(tokens) #> $Taxon_A #> [1] 1 1 1 #>  #> $Taxon_B #> [1] 1 2 2 #>  #> $Taxon_C #> [1] 1 2 2 #>  #> $Taxon_D #> [1] 1 3 2 #>  #> $Taxon_E #> [1] 2 4 1 #>  #> $Taxon_F #> [1] 2 3 5 #>  #> attr(,\"weight\") #> [1] 3 1 1 #> attr(,\"nr\") #> [1] 3 #> attr(,\"nc\") #> [1] 4 #> attr(,\"index\") #> [1] 1 1 2 1 3 #> attr(,\"levels\") #> [1] \"-\" \"0\" \"1\" \"2\" #> attr(,\"allLevels\") #> [1] \"0\"    \"1\"    \"2\"    \"-\"    \"{01}\" #> attr(,\"type\") #> [1] \"USER\" #> attr(,\"contrast\") #>      - 0 1 2 #> [1,] 0 1 0 0 #> [2,] 0 0 1 0 #> [3,] 0 0 0 1 #> [4,] 1 0 0 0 #> [5,] 0 1 1 0 #> attr(,\"class\") #> [1] \"phyDat\" data(\"Lobo\", package = \"TreeTools\") head(PhyDatToMatrix(Lobo.phy)[, 91:93]) #>                        [,1] [,2] [,3] #> Tubiluchus_Priapulida  \"-\"  \"0\"  \"0\"  #> Cricocosmia            \"-\"  \"0\"  \"0\"  #> Aysheaia               \"0\"  \"0\"  \"1\"  #> Siberion               \"?\"  \"0\"  \"?\"  #> Onychodictyon_ferox    \"0\"  \"0\"  \"1\"  #> Onychodictyon_gracilis \"1\"  \"0\"  \"1\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MorphoBankDecode.html","id":null,"dir":"Reference","previous_headings":"","what":"Decode MorphoBank text — MorphoBankDecode","title":"Decode MorphoBank text — MorphoBankDecode","text":"Converts strings MorphoBank notes Latex-compatible format.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MorphoBankDecode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decode MorphoBank text — MorphoBankDecode","text":"","code":"MorphoBankDecode(string)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/MorphoBankDecode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decode MorphoBank text — MorphoBankDecode","text":"string String process","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/MorphoBankDecode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decode MorphoBank text — MorphoBankDecode","text":"MorphoBankDecode() returns string new lines punctuation reformatted.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/MorphoBankDecode.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Decode MorphoBank text — MorphoBankDecode","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/N1Spr.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of trees one SPR step away — N1Spr","title":"Number of trees one SPR step away — N1Spr","text":"N1Spr() calculates number trees one subtree prune--regraft operation away binary input tree using formula given Allen Steel (2001) ; IC1Spr() calculates information content trees distance: .e. entropy corresponding proportion possible n-tip trees whose SPR distance one specified tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/N1Spr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of trees one SPR step away — N1Spr","text":"","code":"N1Spr(n)  IC1Spr(n)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/N1Spr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of trees one SPR step away — N1Spr","text":"n Integer vector specifying number tips tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/N1Spr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of trees one SPR step away — N1Spr","text":"N1Spr() returns integer vector denoting number trees one SPR rearrangement away input tree.. IC1Spr() returns numeric vector giving phylogenetic information content trees 0 1 SPR rearrangement n-leaf tree, bits.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/N1Spr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Number of trees one SPR step away — N1Spr","text":"Allen BL, Steel MA (2001). “Subtree transfer operations induced metrics evolutionary trees.” Annals Combinatorics, 5(1), 1–15. doi:10.1007/s00026-001-8006-8 .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/N1Spr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of trees one SPR step away — N1Spr","text":"","code":"N1Spr(4:6) #> [1]  2 12 30 IC1Spr(5) #> [1] 0.2064509"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NDescendants.html","id":null,"dir":"Reference","previous_headings":"","what":"Count descendants for each node in a tree — NDescendants","title":"Count descendants for each node in a tree — NDescendants","text":"NDescendants() counts number nodes (including leaves) directly descended node tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NDescendants.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count descendants for each node in a tree — NDescendants","text":"","code":"NDescendants(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NDescendants.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count descendants for each node in a tree — NDescendants","text":"tree tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NDescendants.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count descendants for each node in a tree — NDescendants","text":"NDescendants() returns integer listing number direct descendants (leaves internal nodes) node tree.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NDescendants.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Count descendants for each node in a tree — NDescendants","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NDescendants.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count descendants for each node in a tree — NDescendants","text":"","code":"tree <- CollapseNode(BalancedTree(8), 12:15) NDescendants(tree) #> [1] 5 3 2 plot(tree) nodelabels(NDescendants(tree))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NJTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a neighbour joining tree — NJTree","title":"Generate a neighbour joining tree — NJTree","text":"NJTree() generates rooted neighbour joining tree phylogenetic dataset.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NJTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a neighbour joining tree — NJTree","text":"","code":"NJTree(dataset, edgeLengths = FALSE, ratio = TRUE, ambig = \"mean\")"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NJTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a neighbour joining tree — NJTree","text":"dataset phylogenetic data matrix phangorn class phyDat, whose names correspond labels accompanying tree. edgeLengths Logical specifying whether include edge lengths. ambig, ratio Settings ambig ratio used computing Hamming() distances sequences.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NJTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a neighbour joining tree — NJTree","text":"NJTree returns object class phylo.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NJTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a neighbour joining tree — NJTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NJTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a neighbour joining tree — NJTree","text":"","code":"data(\"Lobo\") NJTree(Lobo.phy) #>  #> Phylogenetic tree with 48 tips and 47 internal nodes. #>  #> Tip labels: #>   Tubiluchus_Priapulida, Cricocosmia, Aysheaia, Siberion, Onychodictyon_ferox, Onychodictyon_gracilis, ... #>  #> Rooted; no branch length."},{"path":"https://ms609.github.io/TreeTools/dev/reference/NPartitionPairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Distributions of tips consistent with a partition pair — NPartitionPairs","title":"Distributions of tips consistent with a partition pair — NPartitionPairs","text":"NPartitionPairs() calculates number terminal arrangements matching specified configuration two splits.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NPartitionPairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distributions of tips consistent with a partition pair — NPartitionPairs","text":"","code":"NPartitionPairs(configuration)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NPartitionPairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distributions of tips consistent with a partition pair — NPartitionPairs","text":"configuration Integer vector length four specifying number terminals occur (1) splits A1 A2; (2) splits A1 B2; (3) splits B1 A2; (4) splits B1 B2.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NPartitionPairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distributions of tips consistent with a partition pair — NPartitionPairs","text":"number ways distribute sum(configuration) taxa according specified pattern.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NPartitionPairs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distributions of tips consistent with a partition pair — NPartitionPairs","text":"Consider splits divide eight terminals, labelled H. can represented association matrix: cells matrix contain 2, 1, 1 3 terminals respectively; four-element vector (c(2, 1, 1, 3)) configuration implied pair bipartition splits.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NPartitionPairs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distributions of tips consistent with a partition pair — NPartitionPairs","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NPartitionPairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distributions of tips consistent with a partition pair — NPartitionPairs","text":"","code":"NPartitionPairs(c(2, 1, 1, 3)) #> [1] 12"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NRooted.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of trees — NRooted","title":"Number of trees — NRooted","text":"functions return number rooted unrooted binary trees consistent given pattern splits.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NRooted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of trees — NRooted","text":"","code":"NRooted(tips)  NUnrooted(tips)  NRooted64(tips)  NUnrooted64(tips)  LnUnrooted(tips)  LnUnrooted.int(tips)  Log2Unrooted(tips)  Log2Unrooted.int(tips)  LnRooted(tips)  LnRooted.int(tips)  Log2Rooted(tips)  Log2Rooted.int(tips)  LnUnrootedSplits(...)  Log2UnrootedSplits(...)  NUnrootedSplits(...)  LnUnrootedMult(...)  Log2UnrootedMult(...)  NUnrootedMult(...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NRooted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of trees — NRooted","text":"tips Integer specifying number leaves. ... Integer vector, series integers, listing number leaves split.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NRooted.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of trees — NRooted","text":"Functions starting N return number rooted unrooted trees. Replace initial N Ln natural logarithm number; Log2 base 2 logarithm. Calculations follow Cavalli-Sforza Edwards (1967)  Carter et al. (1990) , Theorem 2.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NRooted.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Number of trees — NRooted","text":"NUnrooted(): Number unrooted trees NRooted64(): Exact number rooted trees 64-bit integer (13 < nTip < 19) NUnrooted64(): Exact number unrooted trees 64-bit integer (14 < nTip < 20) LnUnrooted(): Log Number unrooted trees LnUnrooted.int(): Log Number unrooted trees (integer) LnRooted(): Log Number rooted trees LnRooted.int(): Log Number rooted trees (integer) NUnrootedSplits(): Number unrooted trees consistent bipartition split. NUnrootedMult(): Number unrooted trees consistent multi-partition split.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NRooted.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Number of trees — NRooted","text":"Carter M, Hendy M, Penny D, Székely LA, Wormald NC (1990). “distribution lengths evolutionary trees.” SIAM Journal Discrete Mathematics, 3(1), 38–47. doi:10.1137/0403005 . Cavalli-Sforza LL, Edwards AWF (1967). “Phylogenetic analysis: models estimation procedures.” Evolution, 21(3), 550–570. ISSN 00143820, doi:10.1111/j.1558-5646.1967.tb03411.x .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NRooted.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of trees — NRooted","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NRooted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of trees — NRooted","text":"","code":"NRooted(10) #> [1] 34459425 NUnrooted(10) #> [1] 2027025 LnRooted(10) #> [1] 17.35529 LnUnrooted(10) #> [1] 14.52208 Log2Unrooted(10) #> [1] 20.95093 # Number of trees consistent with a character whose states are # 00000 11111 222 NUnrootedMult(c(5,5,3)) #> [1] 694575  NUnrooted64(18) #> integer64 #> [1] 191898783962510625 LnUnrootedSplits(c(2,4)) #> [1] 2.70805 LnUnrootedSplits(3, 3) #> [1] 2.197225 Log2UnrootedSplits(c(2,4)) #> [1] 3.906891 Log2UnrootedSplits(3, 3) #> [1] 3.169925 NUnrootedSplits(c(2,4)) #> [1] 15 NUnrootedSplits(3, 3) #> [1] 9"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NSplits.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of distinct splits — NSplits","title":"Number of distinct splits — NSplits","text":"NSplits() counts unique bipartition splits tree object.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NSplits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of distinct splits — NSplits","text":"","code":"NSplits(x)  NPartitions(x)  # S3 method for class 'phylo' NSplits(x)  # S3 method for class 'list' NSplits(x)  # S3 method for class 'multiPhylo' NSplits(x)  # S3 method for class 'Splits' NSplits(x)  # S3 method for class 'numeric' NSplits(x)  # S3 method for class '`NULL`' NSplits(x)  # S3 method for class 'ClusterTable' NSplits(x)  # S3 method for class 'character' NSplits(x)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NSplits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of distinct splits — NSplits","text":"x phylogenetic tree class phylo; list trees (class list multiPhylo); Splits object; vector integers; character vector listing tips tree, character length one specifying tree Newick format.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NSplits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of distinct splits — NSplits","text":"NSplits() returns integer specifying number bipartitions specified objects, binary tree x tips.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NSplits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of distinct splits — NSplits","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NSplits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of distinct splits — NSplits","text":"","code":"NSplits(8L) #> [1] 5 NSplits(PectinateTree(8)) #> [1] 5 NSplits(as.Splits(BalancedTree(8))) #> [1] 5"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NTip.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of leaves in a phylogenetic tree — NTip","title":"Number of leaves in a phylogenetic tree — NTip","text":"NTip() extends ape::Ntip() handle objects class Splits list, edge matrices (equivalent tree$edge).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NTip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of leaves in a phylogenetic tree — NTip","text":"","code":"NTip(phy)  # Default S3 method NTip(phy)  # S3 method for class 'Splits' NTip(phy)  # S3 method for class 'list' NTip(phy)  # S3 method for class 'phylo' NTip(phy)  # S3 method for class 'multiPhylo' NTip(phy)  # S3 method for class 'phyDat' NTip(phy)  # S3 method for class 'matrix' NTip(phy)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NTip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of leaves in a phylogenetic tree — NTip","text":"phy Object representing one phylogenetic trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NTip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of leaves in a phylogenetic tree — NTip","text":"NTip() returns integer specifying number tips object phy.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NewickTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Newick Tree — NewickTree","title":"Write Newick Tree — NewickTree","text":"NewickTree() encodes tree Newick-format string. differs write.tree() encoding spaces spaces, rather underscores.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NewickTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Newick Tree — NewickTree","text":"","code":"NewickTree(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NewickTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Newick Tree — NewickTree","text":"tree tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NewickTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write Newick Tree — NewickTree","text":"NewickTree() returns character string denoting tree Newick format.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NewickTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write Newick Tree — NewickTree","text":"","code":"NewickTree(BalancedTree(LETTERS[4:9])) #> [1] \"(((D,E),F),((G,H),I));\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Neworder.html","id":null,"dir":"Reference","previous_headings":"","what":"Reorder edges of a phylogenetic tree — Neworder","title":"Reorder edges of a phylogenetic tree — Neworder","text":"Wrappers C functions called ape::reorder.phylo. call C functions directly, faster – perform many checks user input.  Bad input crash R.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Neworder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reorder edges of a phylogenetic tree — Neworder","text":"","code":"NeworderPruningwise(nTip, nNode, parent, child, nEdge)  NeworderPhylo(nTip, parent, child, nEdge, whichwise)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Neworder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reorder edges of a phylogenetic tree — Neworder","text":"nTip, nNode, nEdge Integer specifying number tips, nodes edges input tree. parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 1] child Integer vector corresponding second column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 2]. whichwise Integer specifying whether order edges (1) cladewise; (2) postorder.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Neworder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reorder edges of a phylogenetic tree — Neworder","text":"NeworderPruningwise returns integer vector specifying pruningwise order edges within tree. NeworderPhylo returns integer vector specifying order edges ordering sequence specified whichwise.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Neworder.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reorder edges of a phylogenetic tree — Neworder","text":"C algorithm: Emmanuel Paradis R wrapper: Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Neworder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reorder edges of a phylogenetic tree — Neworder","text":"","code":"nTip <- 8L tree <- BalancedTree(nTip) edge <- tree[[\"edge\"]] pruningwise <- NeworderPruningwise(nTip, tree$Nnode, edge[, 1], edge[, 2],                                    dim(edge)[1]) cladewise <- NeworderPhylo(nTip, edge[, 1], edge[, 2], dim(edge)[1], 1L) postorder <- NeworderPhylo(nTip, edge[, 1], edge[, 2], dim(edge)[1], 2L)  tree[[\"edge\"]] <- tree[[\"edge\"]][pruningwise, ]"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeDepth.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance of each node from tree exterior — NodeDepth","title":"Distance of each node from tree exterior — NodeDepth","text":"NodeDepth() evaluates \"deep\" node within tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeDepth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance of each node from tree exterior — NodeDepth","text":"","code":"NodeDepth(x, shortest = FALSE, includeTips = TRUE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeDepth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance of each node from tree exterior — NodeDepth","text":"x tree class phylo, $edge property, list thereof. shortest Logical specifying whether calculate length shortest away--root path leaf.  FALSE, length longest route returned. includeTips Logical specifying whether include leaves (depth zero) return value.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeDepth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance of each node from tree exterior — NodeDepth","text":"NodeDepth() returns integer vector specifying depth external internal node x.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeDepth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distance of each node from tree exterior — NodeDepth","text":"rooted tree, depth node minimum (shortest = TRUE) maximum  (shortest = FALSE) number edges must traversed, moving away root, reach leaf. Unrooted trees treated root node occurs \"middle\" tree, meaning position minimise maximum node depth.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeDepth.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distance of each node from tree exterior — NodeDepth","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeDepth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance of each node from tree exterior — NodeDepth","text":"","code":"tree <- CollapseNode(BalancedTree(10), c(12:13, 19)) plot(tree) nodelabels(NodeDepth(tree, includeTips = FALSE))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeNumbers.html","id":null,"dir":"Reference","previous_headings":"","what":"Numeric index of each node in a tree NodeNumbers() returns a sequence corresponding to the nodes in a tree — NodeNumbers","title":"Numeric index of each node in a tree NodeNumbers() returns a sequence corresponding to the nodes in a tree — NodeNumbers","text":"Numeric index node tree NodeNumbers() returns sequence corresponding nodes tree","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeNumbers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numeric index of each node in a tree NodeNumbers() returns a sequence corresponding to the nodes in a tree — NodeNumbers","text":"","code":"NodeNumbers(tree, tips = FALSE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeNumbers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numeric index of each node in a tree NodeNumbers() returns a sequence corresponding to the nodes in a tree — NodeNumbers","text":"tree tree class phylo. tips Logical specifying whether also include indices leaves.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeNumbers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numeric index of each node in a tree NodeNumbers() returns a sequence corresponding to the nodes in a tree — NodeNumbers","text":"NodeNumbers() returns integer vector corresponding indices nodes within tree.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeNumbers.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Numeric index of each node in a tree NodeNumbers() returns a sequence corresponding to the nodes in a tree — NodeNumbers","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeOrder.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of edges incident to each node in a tree — NodeOrder","title":"Number of edges incident to each node in a tree — NodeOrder","text":"NodeOrder() calculates order node: number edges incident tree. value includes root edge rooted trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeOrder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of edges incident to each node in a tree — NodeOrder","text":"","code":"NodeOrder(x, includeAncestor = TRUE, internalOnly = FALSE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeOrder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of edges incident to each node in a tree — NodeOrder","text":"x tree class phylo, $edge property, list thereof. includeAncestor Logical specifying whether count edge leading ancestral node calculation order. internalOnly Logical specifying whether restrict results internal nodes, .e. omit leaves. Irrelevant includeAncestor = FALSE.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeOrder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of edges incident to each node in a tree — NodeOrder","text":"NodeOrder() returns integer listing order node; entries named number node.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeOrder.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of edges incident to each node in a tree — NodeOrder","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/NodeOrder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of edges incident to each node in a tree — NodeOrder","text":"","code":"tree <- CollapseNode(BalancedTree(8), 12:15) NodeOrder(tree) #>  [1] 1 1 1 1 1 1 1 1 5 4 3 plot(tree) nodelabels(NodeOrder(tree, internalOnly = TRUE))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/PairwiseDistances.html","id":null,"dir":"Reference","previous_headings":"","what":"Distances between each pair of trees — PairwiseDistances","title":"Distances between each pair of trees — PairwiseDistances","text":"Distances pair trees","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PairwiseDistances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distances between each pair of trees — PairwiseDistances","text":"","code":"PairwiseDistances(trees, Func, valueLength = 1L, ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/PairwiseDistances.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distances between each pair of trees — PairwiseDistances","text":"trees List trees class phylo. Func Function returning distance two trees. valueLength Integer specifying expected length value returned Func. ... Additional arguments Func.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PairwiseDistances.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distances between each pair of trees — PairwiseDistances","text":"Matrix detailing distance pair trees. Identical trees assumed zero distance.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PairwiseDistances.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distances between each pair of trees — PairwiseDistances","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PairwiseDistances.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distances between each pair of trees — PairwiseDistances","text":"","code":"trees <- list(BalancedTree(8), PectinateTree(8), StarTree(8)) TCIDiff <- function(tree1, tree2) {   TotalCopheneticIndex(tree1) - TotalCopheneticIndex(tree2) } PairwiseDistances(trees, TCIDiff, 1) #>     1   2   3 #> 1     -40  16 #> 2 -40      56 #> 3  16  56     TCIRange <- function(tree1, tree2) {   range(TotalCopheneticIndex(tree1), TotalCopheneticIndex(tree2)) } PairwiseDistances(trees, TCIRange, 2) #> [[1]] #>    1  2  3 #> 1    16  0 #> 2 16     0 #> 3  0  0    #>  #> [[2]] #>    1  2  3 #> 1    56 16 #> 2 56    56 #> 3 16 56    #>"},{"path":"https://ms609.github.io/TreeTools/dev/reference/PathLengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate length of paths between each pair of vertices within tree — PathLengths","title":"Calculate length of paths between each pair of vertices within tree — PathLengths","text":"Given weighted rooted tree tree, PathLengths() returns distance vertex descendant vertices.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PathLengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate length of paths between each pair of vertices within tree — PathLengths","text":"","code":"PathLengths(tree, fullMatrix = FALSE, use.na = TRUE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/PathLengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate length of paths between each pair of vertices within tree — PathLengths","text":"tree Original tree class phylo, Preorder. fullMatrix Logical specifying return format; see \"value\" section`. use.na Logical specifying whether set non-existent paths NA, leave uninitialized.  Set FALSE maximize performance.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PathLengths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate length of paths between each pair of vertices within tree — PathLengths","text":"fullMatrix = TRUE, PathLengths() returns square matrix entry [, j] denotes distance internal node descendant vertex j. Vertex pairs without continuous directed path denoted NA use.na TRUE. fullMatrix = FALSE, PathLengths() returns data.frame three columns: start lists deepest node path (.e. closest root); end lists shallowest node (.e. closest leaf); length lists total length path.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/PathLengths.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate length of paths between each pair of vertices within tree — PathLengths","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PathLengths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate length of paths between each pair of vertices within tree — PathLengths","text":"","code":"tree <- rtree(6) plot(tree) add.scale.bar() nodelabels() tiplabels()  PathLengths(tree) #>    start end    length #> 1      7   1 1.1269270 #> 2      8   1 0.3082923 #> 3      7   2 1.4682141 #> 4      8   2 0.6495795 #> 5      7   3 2.2470673 #> 6      9   3 1.2937119 #> 7     10   3 0.3399792 #> 8      7   4 2.3350161 #> 9      9   4 1.3816607 #> 10    10   4 0.4279280 #> 11    11   4 0.1654539 #> 12     7   5 2.4917303 #> 13     9   5 1.5383748 #> 14    10   5 0.5846422 #> 15    11   5 0.3221681 #> 16     7   6 1.4634807 #> 17     9   6 0.5101252 #> 18     7   8 0.8186347 #> 19     7   9 0.9533555 #> 20     7  10 1.9070881 #> 21     9  10 0.9537327 #> 22     7  11 2.1695622 #> 23     9  11 1.2162068 #> 24    10  11 0.2624741"},{"path":"https://ms609.github.io/TreeTools/dev/reference/PhyToString.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between strings and phyDat objects — StringToPhyDat","title":"Convert between strings and phyDat objects — StringToPhyDat","text":"PhyDatToString() converts phyDat object string; StringToPhyDat() converts string character data phyDat object.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PhyToString.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between strings and phyDat objects — StringToPhyDat","text":"","code":"StringToPhyDat(string, tips, byTaxon = TRUE)  StringToPhydat(string, tips, byTaxon = TRUE)  PhyToString(   phy,   parentheses = \"{\",   collapse = \"\",   ps = \"\",   useIndex = TRUE,   byTaxon = TRUE,   concatenate = TRUE )  PhyDatToString(   phy,   parentheses = \"{\",   collapse = \"\",   ps = \"\",   useIndex = TRUE,   byTaxon = TRUE,   concatenate = TRUE )  PhydatToString(   phy,   parentheses = \"{\",   collapse = \"\",   ps = \"\",   useIndex = TRUE,   byTaxon = TRUE,   concatenate = TRUE )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/PhyToString.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between strings and phyDat objects — StringToPhyDat","text":"string String tokens, optionally containing whitespace, terminating semi-colon. tips (Optional) Character vector corresponding names (order) taxon matrix, object tree tip labels can extracted. byTaxon Logical. TRUE, write one taxon followed next. FALSE, write one character followed next. phy object class phyDat. parentheses Character specifying format parentheses surround ambiguous tokens.  Choose : { (default), [, (, <. collapse Character specifying text, perhaps ,, separate multiple tokens within parentheses. ps Character specifying text, perhaps ;, append end string. useIndex Logical (default: TRUE) specifying whether print duplicate characters multiple times, appeared original matrix. concatenate Logical specifying whether concatenate characters/taxa single string, return separate string entry.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PhyToString.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between strings and phyDat objects — StringToPhyDat","text":"StringToPhyDat() returns object class phyDat. PhyToString() returns character vector listing text representation phylogenetic character state taxon turn.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/PhyToString.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert between strings and phyDat objects — StringToPhyDat","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PhyToString.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between strings and phyDat objects — StringToPhyDat","text":"","code":"StringToPhyDat(\"-?01231230?-\", c(\"Lion\", \"Gazelle\"), byTaxon = TRUE) #> $Lion #> [1] 1 3 5 2 4 6 #>  #> $Gazelle #> [1] 2 4 6 5 3 1 #>  #> attr(,\"weight\") #> [1] 1 1 1 1 1 1 #> attr(,\"nr\") #> [1] 6 #> attr(,\"nc\") #> [1] 5 #> attr(,\"index\") #> [1] 1 2 3 4 5 6 #> attr(,\"levels\") #> [1] \"-\" \"0\" \"1\" \"2\" \"3\" #> attr(,\"levels\")attr(,\".match.hash\") #> <hash table> #> attr(,\"allLevels\") #> [1] \"-\" \"1\" \"?\" \"2\" \"0\" \"3\" #> attr(,\"type\") #> [1] \"USER\" #> attr(,\"contrast\") #>      - 0 1 2 3 #> [1,] 1 0 0 0 0 #> [2,] 0 0 1 0 0 #> [3,] 1 1 1 1 1 #> [4,] 0 0 0 1 0 #> [5,] 0 1 0 0 0 #> [6,] 0 0 0 0 1 #> attr(,\"class\") #> [1] \"phyDat\" # encodes the following matrix: # Lion     -?0123 # Gazelle  1230?-  fileName <- paste0(system.file(package = \"TreeTools\"),                    \"/extdata/input/dataset.nex\") phyDat <- ReadAsPhyDat(fileName) PhyToString(phyDat, concatenate = FALSE) #> [1] \"0000000\" \"0000000\" \"1111?00\" \"111??11\" \"1111?11\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PolarizeSplits.html","id":null,"dir":"Reference","previous_headings":"","what":"Polarize splits on a single taxon — PolarizeSplits","title":"Polarize splits on a single taxon — PolarizeSplits","text":"Polarize splits single taxon","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PolarizeSplits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polarize splits on a single taxon — PolarizeSplits","text":"","code":"PolarizeSplits(x, pole = 1L)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/PolarizeSplits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Polarize splits on a single taxon — PolarizeSplits","text":"x Object class Splits. pole Numeric character identifying tip polarize split.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/PolarizeSplits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Polarize splits on a single taxon — PolarizeSplits","text":"PolarizeSplits() returns Splits object pole represented zero bit","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":null,"dir":"Reference","previous_headings":"","what":"Read phylogenetic characters from file — ReadCharacters","title":"Read phylogenetic characters from file — ReadCharacters","text":"Parse Nexus (Maddison et al. 1997)  TNT (Goloboff et al. 2008)  file, reading character states names.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read phylogenetic characters from file — ReadCharacters","text":"","code":"ReadCharacters(filepath, character_num = NULL, encoding = \"UTF8\")  ReadTntCharacters(   filepath,   character_num = NULL,   type = NULL,   encoding = \"UTF8\" )  ReadTNTCharacters(   filepath,   character_num = NULL,   type = NULL,   encoding = \"UTF8\" )  ReadNotes(filepath, encoding = \"UTF8\")  ReadAsPhyDat(...)  ReadTntAsPhyDat(...)  ReadTNTAsPhyDat(...)  PhyDat(dataset)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read phylogenetic characters from file — ReadCharacters","text":"filepath character string specifying location file, connection file. character_num Index character(s) return. NULL, default, returns characters. encoding Character encoding input file. type Character vector specifying categories data extract file. Setting type = c(\"num\", \"dna\") return characters following &[num] &[dna] tag TNT input file, listing num character blocks dna characters. Leave NULL (default) return characters original sequence. ... Parameters pass Read[Tnt]Characters(). dataset list taxa characters, format produced read.nexus.data(): list sequences made single character vector, named taxon name.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read phylogenetic characters from file — ReadCharacters","text":"ReadCharacters() ReadTNTCharacters() return matrix whose row names correspond tip labels, column names correspond character labels, attribute state.labels listing state labels character; list length one containing character string explaining function call unsuccessful. ReadAsPhyDat() ReadTntAsPhyDat() return phyDat object. ReadNotes() returns list entry corresponds single character, contains list two elements: single character object listing notes associated character named character vector listing notes associated taxon character, named names note-bearing taxon.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read phylogenetic characters from file — ReadCharacters","text":"Tested matrices downloaded MorphoBank (O’Leary Kaufman 2011) , also work widely; please report incompletely incorrectly parsed files. Matrices must contain continuous discrete characters; maximum one matrix per file.  Continuous characters read strings (.e. base type \"character\"). encoding input file automatically determined R. Errors pertaining invalid multibyte string string invalid locale indicate R failed detect appropriate encoding.  Either re-save file supported encoding (UTF-8 good choice) specify file encoding (can find , example, opening Notepad++ identifying highlighted option \"Encoding\" menu) following example .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Read phylogenetic characters from file — ReadCharacters","text":"PhyDat(): convenient wrapper phangorn's phyDat(), converts list morphological characters phyDat object. morphological characters form matrix, perhaps read using read.table(), try MatrixToPhyDat() instead.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Read phylogenetic characters from file — ReadCharacters","text":"Goloboff PA, Farris JS, Nixon KC (2008). “TNT, free program phylogenetic analysis.” Cladistics, 24(5), 774–786. Maddison DR, Swofford DL, Maddison WP (1997). “Nexus: extensible file format systematic information.” Systematic Biology, 46, 590–621. doi:10.1093/sysbio/46.4.590 . O’Leary MA, Kaufman S (2011). “MorphoBank: phylophenomics \"cloud\".” Cladistics, 27(5), 529–537.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read phylogenetic characters from file — ReadCharacters","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadCharacters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read phylogenetic characters from file — ReadCharacters","text":"","code":"fileName <- paste0(system.file(package = \"TreeTools\"),                    \"/extdata/input/dataset.nex\") ReadCharacters(fileName) #>         Character one Character two lots-of-punctuation, and \"so on\"! #> taxon_a \"0\"           \"0\"           \"0\"                               #> taxon_b \"0\"           \"0\"           \"0\"                               #> taxon_c \"1\"           \"1\"           \"1\"                               #> taxon_d \"1\"           \"1\"           \"1\"                               #> taxon_e \"1\"           \"1\"           \"1\"                               #>         Character n Character 5 Character 6 final character #> taxon_a \"0\"         \"0\"         \"0\"         \"0\"             #> taxon_b \"0\"         \"0\"         \"0\"         \"0\"             #> taxon_c \"1\"         \"?\"         \"0\"         \"0\"             #> taxon_d \"?\"         \"?\"         \"1\"         \"1\"             #> taxon_e \"1\"         \"?\"         \"1\"         \"1\"             #> attr(,\"state.labels\") #> attr(,\"state.labels\")[[1]] #> [1] \"absent\"  \"present\" #>  #> attr(,\"state.labels\")[[2]] #> [1] \"absent\"  \"present\" #>  #> attr(,\"state.labels\")[[3]] #> [1] \"here\"       \"there\"      \"everywhere\" #>  #> attr(,\"state.labels\")[[4]] #> [1] \"a long description\" \"present\"            #>  #> attr(,\"state.labels\")[[5]] #> [1] \"simple\"                \"more complex\"          \"with (parentheses)\"    #> [4] \"more complex, 6 still\" #>  #> attr(,\"state.labels\")[[6]] #> [1] \"this one has\"   \"multiple lines\" #>  #> attr(,\"state.labels\")[[7]] #> [1] \"absent\"  \"present\" #>   fileName <- paste0(system.file(package = \"TreeTools\"),                    \"/extdata/tests/continuous.nex\")  continuous <- ReadCharacters(fileName, encoding = \"UTF8\")  # To convert from strings to numbers: at <- attributes(continuous) continuous <- suppressWarnings(as.numeric(continuous)) attributes(continuous) <- at continuous #>            [,1]  [,2]  [,3]  [,4]  [,5]  [,6] #> A_taxon   1.111 1.000 1.330 1.444 1.555 1.666 #> B_alienus 2.111 2.222 2.333    NA 2.550 2.666 #> C_andinus 3.111 3.222 3.333 3.444 3.555 3.666"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadMrBayesTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Read posterior tree sample produced by MrBayes — ReadMrBayesTrees","title":"Read posterior tree sample produced by MrBayes — ReadMrBayesTrees","text":"Read posterior trees 'MrBayes' output files, discarding burn-generations.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadMrBayesTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read posterior tree sample produced by MrBayes — ReadMrBayesTrees","text":"","code":"ReadMrBayesTrees(filepath, n = NULL, burninFrac = NULL)  ReadMrBayes(filepath, n = NULL, burninFrac = NULL)  MrBayesTrees(filepath, n = NULL, burninFrac = NULL)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadMrBayesTrees.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read posterior tree sample produced by MrBayes — ReadMrBayesTrees","text":"filepath character string specifying path .nex input file used initialize MrBayes analysis, relative R working directory (visible getwd()). n Integer specifying number trees sample posterior. burninFrac Fraction trees discard run burn-. NULL (default), read last mcmc mcmcp command filepath.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadMrBayesTrees.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read posterior tree sample produced by MrBayes — ReadMrBayesTrees","text":"ReadMrBayesTrees() returns 'multiPhylo' object containing n trees sampled evenly runs generated analysis filepath, NULL trees found.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadMrBayesTrees.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read posterior tree sample produced by MrBayes — ReadMrBayesTrees","text":"ReadMrBayesTrees() samples trees posterior distributions computed using Bayesian inference software 'MrBayes'","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadMrBayesTrees.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read posterior tree sample produced by MrBayes — ReadMrBayesTrees","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadMrBayesTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read posterior tree sample produced by MrBayes — ReadMrBayesTrees","text":"","code":"if (FALSE)  # Download will take a few seconds   url <-    \"https://raw.githubusercontent.com/ms609/hyoliths/master/MrBayes/hyo.nex\"   trees <- ReadMrBayesTrees(url, n = 40) #> Error in readLines(filepath, warn = FALSE): 'con' is not a connection   plot(Consensus(trees, p = 0.5)) #> Error in Consensus(trees, p = 0.5): Expecting `trees` to be a list.  # \\dontrun{}"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadTntTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse TNT Tree — ReadTntTree","title":"Parse TNT Tree — ReadTntTree","text":"Read tree TNT's parenthetical output.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadTntTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse TNT Tree — ReadTntTree","text":"","code":"ReadTntTree(filepath, relativePath = NULL, keepEnd = 1L, tipLabels = NULL)  TntText2Tree(treeText)  TNTText2Tree(treeText)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadTntTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse TNT Tree — ReadTntTree","text":"filepath character string specifying path TNT .tre file, relative R working directory (visible getwd()). relativePath (discouraged) character string specifying location matrix file used generate TNT results, relative current working directory.  Taxon names read file specified tipLabels. keepEnd (optional, default 1) integer specifying many elements file path conserve creating relative path (see examples). tipLabels (optional) character vector specifying names taxa, sequence appear TNT file.  specified, taxon names loaded data file linked first line .tre file specified filepath. treeText Character string describing one trees, parenthetical format output TNT.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadTntTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse TNT Tree — ReadTntTree","text":"ReadTntTree() returns tree class phylo TNT order, corresponding tree filepath, NULL trees found.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadTntTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse TNT Tree — ReadTntTree","text":"ReadTntTree() imports trees generated parsimony analysis program TNT R, including node labels written ttags command. Tree files must saved TNT parenthetical notation, using TNT command tsave *. Trees easiest load R taxa saved using names (TNT command taxname =).  case, TNT .tre file contains tip labels can parsed directly.  downside uncompressed .tre files larger file size. ReadTntTree() can also read .tre files taxa saved using numbers (taxname -).  files contain hard-coded link matrix file used generate trees, first line .tre file.  poses problems portability: matrix file moved, .tre file accessed another computer, taxon names may lost.  , important check matrix file exists expected location – , either use relativePath argument point new location, specify tipLabels manually specify tip labels. TntText2Tree() converts text representation tree TNT object class phylo.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadTntTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parse TNT Tree — ReadTntTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/ReadTntTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse TNT Tree — ReadTntTree","text":"","code":"# In the examples below, TNT has read a matrix from # \"c:/TreeTools/input/dataset.nex\" # The results of an analysis were written to # \"c:/TreeTools/output/results1.tnt\" # # results1.tnt will contain a hard-coded reference to # \"c:/TreeTools/input/dataset.nex\".  # On the original machine (but not elsewhere), it would be possible to read # this hard-coded reference from results.tnt: # ReadTntTree(\"output/results1.tnt\")  # These datasets are provided with the \"TreeTools\" package, which will # probably not be located at c:/TreeTools on your machine:  oldWD <- getwd() # Remember the current working directory setwd(system.file(package = \"TreeTools\"))  # If taxon names were saved within the file (using `taxname=` in TNT), # then our job is easy: ReadTntTree(\"extdata/output/named.tre\") #>  #> Phylogenetic tree with 5 tips and 4 internal nodes. #>  #> Tip labels: #>   taxon_a, taxon_b, taxon_c, taxon_d, taxon_e #>  #> Rooted; no branch length.  # But if taxa were compressed to numbers (using `taxname-`), we need to # look up the original matrix in order to dereference the tip names. # # We need to extract the relevant file path from the end of the # hard-coded path in the original file. # # We are interested in the last two elements of # c:/TreeTools/input/dataset.nex #                2      1 # # \".\" means \"relative to the current directory\" ReadTntTree(\"extdata/output/numbered.tre\", \"./extdata\", 2) #> 2 phylogenetic trees  # If working in a lower subdirectory setwd(\"./extdata/otherfolder\")  # then it will be necessary to navigate up the directory path with \"..\": ReadTntTree(\"../output/numbered.tre\", \"..\", 2) #> 2 phylogenetic trees   setwd(oldWD) # Restore original working directory  TNTText2Tree(\"(A (B (C (D E ))));\") #>  #> Phylogenetic tree with 5 tips and 4 internal nodes. #>  #> Tip labels: #>   A, B, C, D, E #>  #> Rooted; no branch length."},{"path":"https://ms609.github.io/TreeTools/dev/reference/Renumber.html","id":null,"dir":"Reference","previous_headings":"","what":"Renumber a tree's nodes and tips — Renumber","title":"Renumber a tree's nodes and tips — Renumber","text":"Renumber() numbers nodes tips tree conform phylo standards.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Renumber.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Renumber a tree's nodes and tips — Renumber","text":"","code":"Renumber(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Renumber.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Renumber a tree's nodes and tips — Renumber","text":"tree tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Renumber.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Renumber a tree's nodes and tips — Renumber","text":"Renumber() returns tree class phylo, numbered Cladewise fashion consistent expectations ape functions.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Renumber.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Renumber a tree's nodes and tips — Renumber","text":"ape class phylo formally defined, expects trees' internal representation conform certain principles: example, nodes numbered sequentially, values increasing away root. Renumber() attempts reformat tree representation cause ape functions produce unwanted results crash R.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Renumber.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Renumber a tree's nodes and tips — Renumber","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Renumber.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Renumber a tree's nodes and tips — Renumber","text":"","code":"tree <- RandomTree(letters[1:10]) Renumber(tree) #>  #> Phylogenetic tree with 10 tips and 8 internal nodes. #>  #> Tip labels: #>   d, g, c, i, f, j, ... #>  #> Unrooted; no branch length."},{"path":"https://ms609.github.io/TreeTools/dev/reference/RenumberTips.html","id":null,"dir":"Reference","previous_headings":"","what":"Renumber a tree's tips — RenumberTips","title":"Renumber a tree's tips — RenumberTips","text":"RenumberTips(tree, tipOrder) sorts tips phylogenetic tree tree indices tree[[\"edge\"]][, 2] correspond order leaves given tipOrder.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RenumberTips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Renumber a tree's tips — RenumberTips","text":"","code":"RenumberTips(tree, tipOrder)  # S3 method for class 'phylo' RenumberTips(tree, tipOrder)  # S3 method for class 'multiPhylo' RenumberTips(tree, tipOrder)  # S3 method for class 'list' RenumberTips(tree, tipOrder)  # S3 method for class '`NULL`' RenumberTips(tree, tipOrder)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/RenumberTips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Renumber a tree's tips — RenumberTips","text":"tree tree class phylo. tipOrder character vector containing values tree[[\"tip.label\"]] desired sort order, object (perhaps class phylo Splits) tip labels.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RenumberTips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Renumber a tree's tips — RenumberTips","text":"RenumberTips() returns tree, tips' internal representation numbered match tipOrder.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/RenumberTips.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Renumber a tree's tips — RenumberTips","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RenumberTips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Renumber a tree's tips — RenumberTips","text":"","code":"data(\"Lobo\") # Loads the phyDat object Lobo.phy tree <- RandomTree(Lobo.phy) tree <- RenumberTips(tree, names(Lobo.phy))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reorder.html","id":null,"dir":"Reference","previous_headings":"","what":"Reorder tree edges and nodes — RenumberTree","title":"Reorder tree edges and nodes — RenumberTree","text":"Functions systematically ordering internal edges trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reorder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reorder tree edges and nodes — RenumberTree","text":"","code":"RenumberTree(parent, child, weight)  RenumberEdges(parent, child, ...)  Cladewise(tree, nTip, edge)  # S3 method for class 'phylo' Cladewise(tree, nTip = NTip(tree), edge = tree[[\"edge\"]])  # S3 method for class 'list' Cladewise(tree, nTip, edge)  # S3 method for class 'multiPhylo' Cladewise(tree, nTip, edge)  # S3 method for class 'matrix' Cladewise(tree, nTip = min(tree[, 1]) - 1L, edge)  # S3 method for class '`NULL`' Cladewise(tree, nTip = min(tree[, 1]) - 1L, edge)  ApePostorder(tree, nTip, edge)  # S3 method for class 'phylo' ApePostorder(tree, nTip = NTip(tree), edge = tree[[\"edge\"]])  # S3 method for class 'list' ApePostorder(tree, nTip, edge)  # S3 method for class '`NULL`' ApePostorder(tree, nTip, edge)  # S3 method for class 'multiPhylo' ApePostorder(tree, nTip, edge)  Postorder(tree, force = FALSE)  # S3 method for class 'phylo' Postorder(tree, force = FALSE)  # S3 method for class '`NULL`' Postorder(tree, force = FALSE)  # S3 method for class 'list' Postorder(tree, force = FALSE)  # S3 method for class 'multiPhylo' Postorder(tree, force = FALSE)  # S3 method for class 'numeric' Postorder(tree, force = FALSE)  PostorderOrder(tree)  # S3 method for class 'phylo' PostorderOrder(tree)  # S3 method for class 'numeric' PostorderOrder(tree)  Pruningwise(tree, nTip, edge)  # S3 method for class 'phylo' Pruningwise(tree, nTip = NTip(tree), edge = tree[[\"edge\"]])  # S3 method for class 'list' Pruningwise(tree, nTip, edge)  # S3 method for class 'multiPhylo' Pruningwise(tree, nTip, edge)  # S3 method for class '`NULL`' Pruningwise(tree, nTip, edge)  Preorder(tree, topologyOnly = FALSE)  # S3 method for class 'phylo' Preorder(tree, topologyOnly = FALSE)  # S3 method for class 'numeric' Preorder(tree, topologyOnly = FALSE)  # S3 method for class 'multiPhylo' Preorder(tree, topologyOnly = FALSE)  # S3 method for class 'list' Preorder(tree, topologyOnly = FALSE)  # S3 method for class '`NULL`' Preorder(tree, topologyOnly = FALSE)  TntOrder(tree)  TNTOrder(tree)  # S3 method for class 'phylo' TntOrder(tree)  # S3 method for class 'numeric' TntOrder(tree)  # S3 method for class 'multiPhylo' TntOrder(tree)  # S3 method for class 'list' TntOrder(tree)  # S3 method for class '`NULL`' TntOrder(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reorder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reorder tree edges and nodes — RenumberTree","text":"parent Integer vector corresponding first column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 1] child Integer vector corresponding second column edge matrix tree class phylo, .e. tree[[\"edge\"]][, 2]. weight Optional vector specifying weight edge, corresponding edge.length property phylo object. ... Deprecated; included compatibility previous versions. tree tree class phylo. nTip Integer specifying number tips (leaves). edge Two-column matrix listing parent child edge tree, corresponding tree[[\"edge\"]]. Optional Cladewise(). force Logical specifying whether rearrange trees already postorder, order ensure edges ordered \"TreeTools\" fashion. topologyOnly Logical; TRUE, edge weights may retained.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reorder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reorder tree edges and nodes — RenumberTree","text":"RenumberTree() returns edge matrix tree class phylo following preorder convention edge node numbering. RenumberEdges() formats output RenumberTree() list whose two entries correspond new parent child vectors, preorder. ApePostorder(), Cladewise(), Postorder(), Preorder() Pruningwise() return tree class phylo nodes following specified numbering scheme. Postorder.numeric accepts numeric matrix corresponding edge entry tree class phylo, returns two-column array corresponding tree, edges listed postorder PostorderOrder() returns integer vector. Visiting edges order traverse tree postorder.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reorder.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reorder tree edges and nodes — RenumberTree","text":"Reorder() wrapper ape:::.reorder_ape. Calling C function directly approximately twice fast using ape::cladewise ape::postorder Cladewise(), ApePostorder() Pruningwise() convenience functions corresponding functions \"ape\". Single nodes may need collapsed using ape::collapse.singles first. \"ape\" functions can cause crashes nodes numbered unconventionally – sometimes arising using tree rearrangement functions, e.g. phangorn::SPR(). Preorder() robust: supports polytomies, nodes may numbered sequence, edges may listed order input tree. output guaranteed identical tree equivalent leaf labelling (see RenumberTips()) topology, allowing unique trees detected comparing sorted edge matrices alone. Nodes edges preorder tree numbered starting deepest node. node numbered sequence encountered, edge listed sequence visited. node, child edges sorted left right order lowest-numbered leaf subtree subtended edge; .e. edge leads eventually tip 1 left edge leading subtree containing tip 2. Numbering begins following leftmost edge root node, sorting descendant subtree preorder. , next edge root node followed, descendants sorted preorder, edge visited. RenumberTree() RenumberEdges() wrappers C function preorder_edges_and_nodes(); perform checks input Preorder() intended use performance premium. Postorder() numbers nodes Preorder(), lists edges descending order parent node number, breaking ties listing child nodes increasing order.  tree already postorder, rearranged unless force = TRUE. Methods applied numeric inputs check input sanity, used caution: malformed input may cause undefined results, including crashing R. Trees >8191 leaves require additional memory handled Postorder() present. need process large trees, please contact maintainer advice.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reorder.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Reorder tree edges and nodes — RenumberTree","text":"Cladewise(): Reorder tree cladewise. ApePostorder(): Reorder tree Postorder using ape's postorder function, robust unconventional node numbering. Pruningwise(): Reorder tree Pruningwise. Preorder(): Reorder tree Preorder (special case cladewise). TntOrder(): Reorder tree postorder, numbering internal nodes according TNT's rules, number root node nTip + 1, remaining nodes sequence encountered traversing tree postorder, starting tip sequence.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reorder.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reorder tree edges and nodes — RenumberTree","text":"Preorder() Postorder(): Martin R. Smith. Cladewise(), ApePostorder() Pruningwise(): modified Martin R. Smith .reorder_ape() ape (Emmanuel Paradis).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reweight.html","id":null,"dir":"Reference","previous_headings":"","what":"Reweight phylogenetic characters — Reweight","title":"Reweight phylogenetic characters — Reweight","text":"Reweight() allows weights specific characters phylogenetic datasets arbitrarily adjusted.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reweight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reweight phylogenetic characters — Reweight","text":"","code":"Reweight(dataset, weights)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reweight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reweight phylogenetic characters — Reweight","text":"dataset phylogenetic data matrix phangorn class phyDat, matrix format produced PhyDatToMatrix(). weights Unnamed integer vector specifying desired weight character turn; named integer vector specifying weights character; unnamed entries assigned weight 1.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reweight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reweight phylogenetic characters — Reweight","text":"Reweight() returns dataset adjusting weights specified characters. matrix, attained repeating column weights times. phyDat object, \"weight\" attribute modified.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reweight.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reweight phylogenetic characters — Reweight","text":"functionality employed care. underlying principle parsimony evolutionary steps equivalent. Setting different weights different characters odds principle, analysis re-weighted matrix using parsimony-based framework arguably longer parsimony analysis; permissive view, criteria used determine weighting scheme always arbitrary. can useful relax criterion evolutionary steps equivalent – example, implied weighting (Goloboff 1997)  typically recovers better trees equal-weights parsimony (Smith 2019) . said, assigning different weights different characters tacitly imposes model evolution differs implicit equal-weights parsimony.  Whereas probabilistic models can evaluated various methods (e.g. fit, marginal likelihood, posterior predictive power), principled methods comparing different models parsimony framework. , Reweight() likely useful narrow set uses. Examples may include: informal robustness testing, explore whether certain characters less influential resulting tree; Imposing constraints dataset, adding constraint column dataset whose weight exceeds total amount data.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reweight.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reweight phylogenetic characters — Reweight","text":"Goloboff PA (1997). “Self-Weighted Optimization: Tree Searches Character State Reconstructions Implied Transformation Costs.” Cladistics, 13(3), 225–245. doi:10.1111/j.1096-0031.1997.tb00317.x . Smith MR (2019). “Bayesian Parsimony Approaches Reconstruct Informative Trees Simulated Morphological Datasets.” Biology Letters, 15(2), 20180632. doi:10.1098/rsbl.2018.0632 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reweight.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reweight phylogenetic characters — Reweight","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Reweight.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reweight phylogenetic characters — Reweight","text":"","code":"mat <- rbind(a = c(0, 2, 0), b = c(0, 2, 0), c = c(1, 3, 0), d = c(1, 3, 0)) dat <- MatrixToPhyDat(mat)   # Set character 1 to weight 1, character 2 to weight 2; omit character 3 Reweight(mat, c(1, 2, 0)) #>   _1 _1 _2 #> a  0  2  2 #> b  0  2  2 #> c  1  3  3 #> d  1  3  3 # Equivalently: Reweight(dat, c(\"3\" = 0, \"2\" = 2)) #> $a #> [1] 1 3 1 #>  #> $b #> [1] 1 3 1 #>  #> $c #> [1] 2 4 1 #>  #> $d #> [1] 2 4 1 #>  #> attr(,\"weight\") #> [1] 1 2 0 #> attr(,\"nr\") #> [1] 3 #> attr(,\"nc\") #> [1] 4 #> attr(,\"index\") #> [1] 1 2 3 #> attr(,\"levels\") #> [1] \"0\" \"1\" \"2\" \"3\" #> attr(,\"allLevels\") #> [1] \"0\" \"1\" \"2\" \"3\" #> attr(,\"type\") #> [1] \"USER\" #> attr(,\"contrast\") #>      0 1 2 3 #> [1,] 1 0 0 0 #> [2,] 0 1 0 0 #> [3,] 0 0 1 0 #> [4,] 0 0 0 1 #> attr(,\"class\") #> [1] \"phyDat\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RightmostCharacter.html","id":null,"dir":"Reference","previous_headings":"","what":"Rightmost character of string — RightmostCharacter","title":"Rightmost character of string — RightmostCharacter","text":"RightmostCharacter() convenience function returns final character string.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RightmostCharacter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rightmost character of string — RightmostCharacter","text":"","code":"RightmostCharacter(string, len = nchar(string))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/RightmostCharacter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rightmost character of string — RightmostCharacter","text":"string Character string. len (Optional) Integer specifying number characters string.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RightmostCharacter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rightmost character of string — RightmostCharacter","text":"RightmostCharacter() returns rightmost character string.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/RightmostCharacter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rightmost character of string — RightmostCharacter","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RightmostCharacter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rightmost character of string — RightmostCharacter","text":"","code":"RightmostCharacter(\"Hello, World!\") #> [1] \"!\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RoguePlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize position of rogue taxa — RoguePlot","title":"Visualize position of rogue taxa — RoguePlot","text":"Plots consensus trees rogue taxon omitted, edges coloured according proportion trees taxon attaches edge, Klopfstein Spasojevic (2019) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RoguePlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize position of rogue taxa — RoguePlot","text":"","code":"RoguePlot(   trees,   tip,   p = 1,   plot = TRUE,   Palette = colorRampPalette(c(par(\"fg\"), \"#009E73\"), space = \"Lab\"),   nullCol = rgb(colorRamp(unlist(par(c(\"fg\", \"bg\"))), space = \"Lab\")(0.8)/255),   edgeLength = NULL,   thin = par(\"lwd\"),   fat = thin + 1L,   outgroupTips,   sort = FALSE,   legend = \"none\",   legend.inset = 0,   ... )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/RoguePlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize position of rogue taxa — RoguePlot","text":"trees List multiPhylo object containing phylogenetic trees class phylo summarized. tip Numeric character identifying rogue leaf, format accepted DropTip(). p numeric value 0.5 1 giving proportion clade represented consensus tree (see Consensus()). plot Logical specifying whether plot tree. Palette Function takes parameter n generates colour palette n entries. nullCol Colour paint regions tree rogue never found. edgeLength Numeric specifying edge lengths consensus tree; NULL aligns tips scaling edges proportional clade size; 1 sets edges unit length. thin, fat Numeric specifying width plot edges rogue tip never / sometimes attach . outgroupTips Vector type character, integer logical, specifying names indices tips include outgroup. outgroupTips type character, tree contains multiple tips matching label, first used. sort Logical specifying whether sort consensus tree using SortTree(). legend Character vector specifying position legend (e.g. \"bottomleft\"), \"none\" suppress legend. fine-grained control legend, use PlotTools::SpectrumLegend(). legend.inset Numeric specifying fraction plot width / height legend's position inset. ... Additional parameters plot.phylo().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RoguePlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize position of rogue taxa — RoguePlot","text":"RoguePlot() invisibly returns list whose elements : cons: reduced consensus tree, preorder; onEdge: vector integers specifying number trees trees rogue leaf attached edge turn consensus tree; atNode: vector integers specifying number trees trees rogue leaf attached edge collapsed node consensus tree. legendLabels: character vector suggesting labels plot legend; suitable PlotTools::SpectrumLegend(legend = x$legendLabels).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RoguePlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize position of rogue taxa — RoguePlot","text":"Rogue taxa can identified using package Rogue (Smith 2022) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RoguePlot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Visualize position of rogue taxa — RoguePlot","text":"Klopfstein S, Spasojevic T (2019). “Illustrating phylogenetic placement fossils using RoguePlots: example ichneumonid parasitoid wasps (Hymenoptera, Ichneumonidae) extensive morphological matrix.” PLOS ONE, 14(4), e0212942. doi:10.1371/journal.pone.0212942 . Smith MR (2022). “Using information theory detect rogue taxa improve consensus trees.” Systematic Biology, 71(5), 986–1008. doi:10.1093/sysbio/syab099 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/RoguePlot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize position of rogue taxa — RoguePlot","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RoguePlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize position of rogue taxa — RoguePlot","text":"","code":"trees <- list(read.tree(text = \"(a, (b, (c, (rogue, (d, (e, f))))));\"),               read.tree(text = \"(a, (b, (c, (rogue, (d, (e, f))))));\"),               read.tree(text = \"(a, (b, (c, (rogue, (d, (e, f))))));\"),               read.tree(text = \"(a, (b, (c, (rogue, (d, (e, f))))));\"),               read.tree(text = \"(rogue, (a, (b, (c, (d, (e, f))))));\"),               read.tree(text = \"((rogue, a), (b, (c, (d, (e, f)))));\"),               read.tree(text = \"(a, (b, ((c, d), (rogue, (e, f)))));\"),               read.tree(text = \"(a, (b, ((c, (rogue, d)), (e, f))));\"),               read.tree(text = \"(a, (b, (c, (d, (rogue, (e, f))))));\")) plotted <- RoguePlot(trees, \"rogue\", legend = \"topleft\", legend.inset = 0.02) PlotTools::SpectrumLegend(   \"bottomleft\",   palette = colorRampPalette(c(par(\"fg\"), \"#009E73\"), space = \"Lab\")(100),   legend = plotted$legendLabels,   cex = 0.4 )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootNode.html","id":null,"dir":"Reference","previous_headings":"","what":"Which node is a tree's root? — RootNode","title":"Which node is a tree's root? — RootNode","text":"RootNode() identifies root node (rooted unrooted) phylogenetic tree. Unrooted trees represented internally rooted tree polytomy root.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootNode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Which node is a tree's root? — RootNode","text":"","code":"RootNode(x)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootNode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Which node is a tree's root? — RootNode","text":"x tree class phylo, edge matrix; list multiPhylo object containing multiple trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootNode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Which node is a tree's root? — RootNode","text":"RootNode() returns integer denoting root node tree. Badly conformed trees trigger error.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootNode.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Which node is a tree's root? — RootNode","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootNode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Which node is a tree's root? — RootNode","text":"","code":"RootNode(BalancedTree(8)) #> [1] 9 RootNode(UnrootTree(BalancedTree(8))) #> [1] 9"},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Root or unroot a phylogenetic tree — RootTree","title":"Root or unroot a phylogenetic tree — RootTree","text":"RootTree() roots tree smallest clade containing specified tips; RootOnNode() roots tree specified internal node; UnrootTree() collapses root node, without undefined behaviour encountered using ape::unroot() trees preorder.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Root or unroot a phylogenetic tree — RootTree","text":"","code":"RootTree(tree, outgroupTips, fallback = NULL)  RootOnNode(tree, node, resolveRoot = FALSE)  UnrootTree(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Root or unroot a phylogenetic tree — RootTree","text":"tree tree class phylo, list trees class list multiPhylo. outgroupTips Vector type character, integer logical, specifying names indices tips include outgroup. outgroupTips type character, tree contains multiple tips matching label, first used. fallback Vector corresponding outgroupTips determining behaviour outgroupTips root tree. smallest clade contains outgroupTips includes taxa, RootTree() change topology tree. fallback = NULL, RootTree() return tree. Otherwise, taxa excluded outgroupTips sequence specified (fallback[1] first) clade containing outgroup tips smaller tree. node Integer specifying node (internal tip) set root. resolveRoot Logical specifying whether resolve root node.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Root or unroot a phylogenetic tree — RootTree","text":"RootTree() returns tree class phylo, rooted smallest clade contains specified tips, edges nodes numbered preorder. Node labels retained. RootOnNode() returns tree class phylo, rooted requested node ordered Preorder. UnrootTree() returns tree, preorder, collapsed first child root node tree.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Root or unroot a phylogenetic tree — RootTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/RootTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Root or unroot a phylogenetic tree — RootTree","text":"","code":"tree <- PectinateTree(8) plot(tree) ape::nodelabels()   plot(RootTree(tree, c(\"t6\", \"t7\")))   plot(RootOnNode(tree, 12))  plot(RootOnNode(tree, 2))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SampleOne.html","id":null,"dir":"Reference","previous_headings":"","what":"Select element at random — SampleOne","title":"Select element at random — SampleOne","text":"SampleOne() fast alternative  sample() avoids checks.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SampleOne.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select element at random — SampleOne","text":"","code":"SampleOne(x, len = length(x))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SampleOne.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select element at random — SampleOne","text":"x vector sample. len (Optional) Integer specifying length x.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SampleOne.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select element at random — SampleOne","text":"SampleOne() returns length one vector, randomly sampled x.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/SampleOne.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Select element at random — SampleOne","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SampleOne.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select element at random — SampleOne","text":"","code":"SampleOne(9:10) #> [1] 9 SampleOne(letters[1:4]) #> [1] \"a\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SortTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Sort tree — SortTree","title":"Sort tree — SortTree","text":"SortTree() sorts node consistent order, node rotation obscure similarities similar trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SortTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sort tree — SortTree","text":"","code":"SortTree(tree, how = \"cladesize\", order = TipLabels(tree))  # S3 method for class 'phylo' SortTree(tree, how = \"cladesize\", order = TipLabels(tree))  # S3 method for class 'list' SortTree(tree, how = \"cladesize\", order = TipLabels(tree[[1]]))  # S3 method for class 'multiPhylo' SortTree(tree, how = \"cladesize\", order = TipLabels(tree[[1]]))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SortTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sort tree — SortTree","text":"tree One trees class phylo, optionally list multiPhylo object. Character vector specifying sort method: \"Cladesize\" rotates node larger clade first, thus appearing lower plotted; \"TipLabels\" rotates nodes labels listed sooner order listed first, thus plot lower. order Character vector listing tip labels sequence appear tree. Clades containing taxon earlier list listed sooner thus plot lower tree.  Taxa listed order treated last list.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SortTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sort tree — SortTree","text":"SortTree() returns tree format tree, node tree sorted","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SortTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sort tree — SortTree","text":"node, clades listed tree[[\"edge\"]] decreasing size order. Clades contain number leaves sorted decreasing order minimum leaf number, (2, 3) occur (1, 4). trees plotted \"bottom \", largest clades \"sink\" bottom plotted tree.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/SortTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sort tree — SortTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SortTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sort tree — SortTree","text":"","code":"messyTree <- as.phylo(10, 6) plot(messyTree)   sorted <- SortTree(messyTree) plot(sorted) ape::nodelabels() ape::edgelabels() ape::tiplabels(adj = c(2, 1/3))   plot(SortTree(messyTree, how = \"tip\"))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SpectrumLegend.html","id":null,"dir":"Reference","previous_headings":"","what":"Produce a legend for continuous gradient scales — SpectrumLegend","title":"Produce a legend for continuous gradient scales — SpectrumLegend","text":"Prints annotated vertical bar coloured according continuous palette.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SpectrumLegend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Produce a legend for continuous gradient scales — SpectrumLegend","text":"","code":"SpectrumLegend(   x0 = 0.05,   y0 = 0.05,   x1 = x0,   y1 = y0 + 0.2,   absolute = FALSE,   legend = character(0),   palette,   lwd = 4,   lty = 1,   lend = \"square\",   cex = 1,   text.col = par(\"col\"),   font = NULL,   text.font = font,   title = NULL,   title.col = text.col[1],   title.cex = cex[1],   title.adj = 0.5,   title.font = 2,   pos = 4,   ... )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SpectrumLegend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Produce a legend for continuous gradient scales — SpectrumLegend","text":"x0, y0, x1, y1 Coordinates bottom-left top-right end bar. absolute Logical specifying whether x y values denote coordinates (TRUE) relative position, (0, 0) denotes bottom-left plot area (1, 1) top right. legend Character vector label points palette. palette Colour palette depict. lwd, lty, lend Additional parameters segments(), controlling line style. cex Character expansion factor relative current par(\"cex\"). text.col Colour used legend text. font, text.font Font used legend text; see text(). title Text display title.col Colour title; defaults text.col[1]. title.cex Expansion factor(s) title, defaults cex[1]. title.adj Horizontal adjustment title: see help par(\"adj\"). title.font Font used legend title. pos, ... Additional parameters text().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SpectrumLegend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Produce a legend for continuous gradient scales — SpectrumLegend","text":"function now deprecated; superseded capable PlotTools::SpectrumLegend() removed future release.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SpectrumLegend.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Produce a legend for continuous gradient scales — SpectrumLegend","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitConsistent.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify consistent / conflicting splits — SplitConsistent","title":"Identify consistent / conflicting splits — SplitConsistent","text":"SplitConsistent() SplitConflict() determine whether series splits haystack consistent contradict focal split needle.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitConsistent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify consistent / conflicting splits — SplitConsistent","text":"","code":"SplitConsistent(needle, haystack)  SplitConflicts(needle, haystack)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitConsistent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify consistent / conflicting splits — SplitConsistent","text":"needle Splits object containing single split evaluate haystack Splits object, list thereof, containing splits compare needle.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitConsistent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify consistent / conflicting splits — SplitConsistent","text":"SplitConsistent() returns list logical vectors. list item corresponds entry haystack, reporting whether split consistent (TRUE) conflict (FALSE) needle. SplitConflicts() returns inverse.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitConsistent.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify consistent / conflicting splits — SplitConsistent","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitConsistent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify consistent / conflicting splits — SplitConsistent","text":"","code":"splits1 <- as.Splits(BalancedTree(8)) splits2 <- as.Splits(PectinateTree(8)) summary(splits1[[4]]) #> 1 bipartition split dividing 8 tips, t1 .. t8 #>      12345678 #>  14  ....**.. #>  #>  Tip 1: t1\t Tip 2: t2\t Tip 3: t3\t Tip 4: t4\t Tip 5: t5\t #>  Tip 6: t6\t Tip 7: t7\t Tip 8: t8\t SplitConsistent(splits1[[4]], splits2) #> [[1]] #> [1]  TRUE  TRUE  TRUE FALSE  TRUE #>  SplitConflicts(splits1[[4]], list(splits1, splits2)) #> [[1]] #> [1] FALSE FALSE FALSE FALSE FALSE #>  #> [[2]] #> [1] FALSE FALSE FALSE  TRUE FALSE #>"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitFrequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Frequency of splits — SplitFrequency","title":"Frequency of splits — SplitFrequency","text":"SplitFrequency() provides simple way count number times bipartition splits, defined reference tree, occur forest trees. May used calculate edge (\"node\") support majority consensus bootstrap trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitFrequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Frequency of splits — SplitFrequency","text":"","code":"SplitFrequency(reference, forest)  SplitNumber(tips, tree, tipIndex, powersOf2)  ForestSplits(forest, powersOf2)  TreeSplits(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitFrequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Frequency of splits — SplitFrequency","text":"reference tree class phylo, Splits object. forest list trees class phylo, multiPhylo object; Splits object. See vignette possible methods loading trees R. tips Integer vector specifying tips tree within chosen split. tree tree class phylo. tipIndex Character vector tip names, fixed order. powersOf2 Integer vector length tipIndex, specifying power 2 associated tip turn.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitFrequency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Frequency of splits — SplitFrequency","text":"SplitFrequency() returns number trees forest contain split reference. reference tree class phylo, sequence correspond order nodes (use ape::nodelabels() view). Note three nodes root tree correspond single split; see example might plotted tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitFrequency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Frequency of splits — SplitFrequency","text":"multiple calculations required, time can saved using constituent functions (see examples).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitFrequency.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Frequency of splits — SplitFrequency","text":"SplitNumber(): Assign unique integer split ForestSplits(): Frequency splits given forest trees TreeSplits(): Deprecated. Listed splits given tree. Use .Splits instead.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitFrequency.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Frequency of splits — SplitFrequency","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitFrequency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Frequency of splits — SplitFrequency","text":"","code":"# An example forest of 100 trees, some identical forest <- as.phylo(c(1, rep(10, 79), rep(100, 15), rep(1000, 5)), nTip = 9)  # Generate an 80% consensus tree cons <- ape::consensus(forest, p = 0.8) plot(cons)   # Calculate split frequencies splitFreqs <- SplitFrequency(cons, forest)  # Optionally, colour edges by corresponding frequency. # Note that not all edges are associated with a unique split # (and two root edges may be associated with one split - not handled here) edgeSupport <- rep(1, nrow(cons$edge)) # Initialize trivial splits to 1 childNode <- cons$edge[, 2] edgeSupport[match(names(splitFreqs), childNode)] <- splitFreqs / 100  plot(cons, edge.col = SupportColour(edgeSupport), edge.width = 3)  # Annotate nodes by frequency  LabelSplits(cons, splitFreqs, unit = \"%\",             col = SupportColor(splitFreqs / 100),             frame = \"none\", pos = 3L)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitInformation.html","id":null,"dir":"Reference","previous_headings":"","what":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","title":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","text":"Calculate phylogenetic information content (sensu Steel Penny 2006 ) split, reflects probability uniformly selected random tree contain# split: split consistent smaller number trees higher information content.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitInformation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","text":"","code":"SplitInformation(A, B = A[1])  MultiSplitInformation(partitionSizes)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitInformation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","text":", B Integer specifying number taxa partition. partitionSizes Integer vector specifying number taxa partition multi-partition split.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitInformation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","text":"SplitInformation() MultiSplitInformation() return phylogenetic information content, bits, split subdivides leaves partitions specified sizes.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitInformation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","text":"SplitInformation() addresses bipartition splits, correspond edges unrooted phylogeny; MultiSplitInformation() supports splits subdivide taxa multiple partitions, may correspond multi-state characters phylogenetic matrix. simple way characterise trees count number edges. (Edges almost, quite, equivalent nodes.) Counting edges (nodes) provides quick measure tree's resolution, underpins Robinson-Foulds tree distance measure. edges, however, created equal. edge splits leaves tree two subdivisions.  equal subdivisions size, instructive edge . Intuitively, division mammals reptiles profound revelation underpins much zoology; recognizing two species bat closely related mammal reptile still instructive, somewhat less fundamental. Formally, phylogenetic (Shannon) information content split S, h(S), corresponds probability uniformly selected random tree contain split, P(S): h(S) = -log P(S). Base 2 logarithms typically employed yield information content bits. example, split AB|CDEF occurs 15 105 six-leaf trees; h(AB|CDEF) = -log P(AB|CDEF) = -log(15/105) ~ 2.81 bits.  split ABC|DEF subdivides leaves evenly, thus instructive: occurs just nine 105 six-leaf trees, h(ABC|DEF) = -log(9/105) ~ 3.54 bits. number leaves increases, single even split may contain information multiple uneven splits – see examples section . Summing information content splits within tree, perhaps using 'TreeDist' function SplitwiseInfo(), arguably gives instructive picture resolution simply counting number splits present – though caveat splits within tree independent one another, information may double counted.  (charge applies simply counting nodes, .) Alternatives count number quartets resolved, perhaps using 'Quartet' function QuartetStates(), use different take information contained within split, clustering information: see 'TreeDist' function ClusteringInfo() details.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitInformation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","text":"Steel MA, Penny D (2006). “Maximum parsimony phylogenetic information multistate characters.” Albert VA (ed.), Parsimony, Phylogeny, Genomics, 163–178. Oxford University Press, Oxford.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitInformation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitInformation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Phylogenetic information content of splitting leaves into two partitions — SplitInformation","text":"","code":"# Eight leaves can be split evenly: SplitInformation(4, 4) #> [1] 5.529821  # or unevenly, which is less informative: SplitInformation(2, 6) #> [1] 3.459432  # A single split that evenly subdivides 50 leaves contains more information # that seven maximally uneven splits on the same leaves: SplitInformation(25, 25) #> [1] 47.50376 7 * SplitInformation(2, 48) #> [1] 45.98899 # Three ways to split eight leaves into multiple partitions: MultiSplitInformation(c(2, 2, 4)) #> [1] 5.97728 MultiSplitInformation(c(2, 3, 3)) #> [1] 6.714246 MultiSplitInformation(rep(2, 4)) #> [1] 6.714246"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitMatchProbability.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability of matching this well — SplitMatchProbability","title":"Probability of matching this well — SplitMatchProbability","text":"(Ln)SplitMatchProbability()calculates probability two random splits sizes provided least similar two specified.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitMatchProbability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability of matching this well — SplitMatchProbability","text":"","code":"SplitMatchProbability(split1, split2)  LnSplitMatchProbability(split1, split2)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitMatchProbability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability of matching this well — SplitMatchProbability","text":"split1, split2 Logical vectors listing terminals order, terminal identified member ingroup (TRUE) outgroup (FALSE) respective bipartition split.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitMatchProbability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability of matching this well — SplitMatchProbability","text":"SplitMatchProbability() returns numeric giving proportion permissible non-trivial splits divide terminals bipartitions sizes given, match well split1 split2 . LnSplitMatchProbability() returns natural logarithm probability.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitMatchProbability.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Probability of matching this well — SplitMatchProbability","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitMatchProbability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability of matching this well — SplitMatchProbability","text":"","code":"split1 <- as.Splits(c(rep(TRUE, 4), rep(FALSE, 4))) split2 <- as.Splits(c(rep(TRUE, 3), rep(FALSE, 5))) SplitMatchProbability(split1, split2) #> [1] 0.1428571 LnSplitMatchProbability(split1, split2) #> [1] -1.94591"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Splits.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert object to Splits — Splits","title":"Convert object to Splits — Splits","text":".Splits() converts phylogenetic tree Splits object representing constituent bipartition splits.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert object to Splits — Splits","text":"","code":"as.Splits(x, tipLabels = NULL, ...)  # S3 method for class 'phylo' as.Splits(x, tipLabels = NULL, asSplits = TRUE, ...)  # S3 method for class 'multiPhylo' as.Splits(x, tipLabels = unique(unlist(TipLabels(x))), asSplits = TRUE, ...)  # S3 method for class 'Splits' as.Splits(x, tipLabels = NULL, ...)  # S3 method for class 'list' as.Splits(x, tipLabels = NULL, asSplits = TRUE, ...)  # S3 method for class 'matrix' as.Splits(x, tipLabels = NULL, ...)  # S3 method for class 'logical' as.Splits(x, tipLabels = NULL, ...)  # S3 method for class 'character' as.Splits(x, tipLabels = NULL, ...)  # S3 method for class 'Splits' as.logical(x, tipLabels = attr(x, \"tip.label\"), ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Splits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert object to Splits — Splits","text":"x Object convert splits: perhaps tree class phylo. logical matrix provided, row considered separate split. tipLabels Character vector specifying sequence order tip labels.  Label order must (currently) match combine compare separate Splits objects. ... Presently unused. asSplits Logical specifying whether return Splits object, unannotated two-dimensional array (useful performance paramount).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Splits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert object to Splits — Splits","text":".Splits() returns object class Splits, (asSplits = FALSE) two-dimensional array raw objects, bit specifying whether leaf corresponding respective bit position member split. Splits named according node non-root end edge defines . rooted trees, child rightmost root edge names split.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Splits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert object to Splits — Splits","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Splits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert object to Splits — Splits","text":"","code":"splits <- as.Splits(BalancedTree(letters[1:6])) summary(splits) #> 3 bipartition splits dividing 6 tips, a .. f #>      123456 #>  8   ***... #>  9   **.... #>  11  ...**. #>  #>  Tip 1: a\t Tip 2: b\t Tip 3: c\t Tip 4: d\t Tip 5: e\t #>  Tip 6: f\t TipsInSplits(splits) #>  8  9 11  #>  3  2  2  summary(!splits) #> 3 bipartition splits dividing 6 tips, a .. f #>      123456 #>  8   ...*** #>  9   ..**** #>  11  ***..* #>  #>  Tip 1: a\t Tip 2: b\t Tip 3: c\t Tip 4: d\t Tip 5: e\t #>  Tip 6: f\t TipsInSplits(!splits) #>  8  9 11  #>  3  4  4   length(splits + !splits) #> [1] 6 length(unique(splits + !splits)) #> [1] 3  summary(c(splits[[2:3]], !splits[[1:2]])) #> 4 bipartition splits dividing 6 tips, a .. f #>      123456 #>  9   **.... #>  11  ...**. #>  8   ...*** #>  9   ..**** #>  #>  Tip 1: a\t Tip 2: b\t Tip 3: c\t Tip 4: d\t Tip 5: e\t #>  Tip 6: f\t  moreSplits <- as.Splits(PectinateTree(letters[6:1]), tipLabel = splits) print(moreSplits, details = TRUE) #> 3 bipartition splits dividing 6 tips, a .. f #>      123456 #>  9   ****.. #>  10  ***... #>  11  **.... match(splits, moreSplits) #> [1]  2  3 NA moreSplits %in% splits #>     9    10    11  #> FALSE  TRUE  TRUE   as.Splits(\"....**\", letters[1:6]) #> 1 bipartition split dividing 6 tips, a .. f"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitsInBinaryTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum splits in an n-leaf tree — SplitsInBinaryTree","title":"Maximum splits in an n-leaf tree — SplitsInBinaryTree","text":"SplitsInBinaryTree() convenience function calculate number splits fully-resolved (binary) tree n leaves.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitsInBinaryTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum splits in an n-leaf tree — SplitsInBinaryTree","text":"","code":"SplitsInBinaryTree(tree)  # S3 method for class 'list' SplitsInBinaryTree(tree)  # S3 method for class 'multiPhylo' SplitsInBinaryTree(tree)  # S3 method for class 'numeric' SplitsInBinaryTree(tree)  # S3 method for class '`NULL`' SplitsInBinaryTree(tree)  # Default S3 method SplitsInBinaryTree(tree)  # S3 method for class 'Splits' SplitsInBinaryTree(tree)  # S3 method for class 'phylo' SplitsInBinaryTree(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitsInBinaryTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum splits in an n-leaf tree — SplitsInBinaryTree","text":"tree object supported format represents tree set trees, number leaves calculated.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitsInBinaryTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum splits in an n-leaf tree — SplitsInBinaryTree","text":"SplitsInBinaryTree() returns integer vector detailing number unique non-trivial splits binary tree n leaves.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitsInBinaryTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Maximum splits in an n-leaf tree — SplitsInBinaryTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SplitsInBinaryTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum splits in an n-leaf tree — SplitsInBinaryTree","text":"","code":"tree <- BalancedTree(8) SplitsInBinaryTree(tree) #> [1] 5 SplitsInBinaryTree(as.Splits(tree)) #> [1] 5 SplitsInBinaryTree(8) #> [1] 5 SplitsInBinaryTree(list(tree, tree)) #> [1] 5 5"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Stemwardness.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"Functions describe position leaf relative root. \"Stemmier\" leaves exhibit smaller root-node distance larger sister size.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Stemwardness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"SisterSize(tree, tip)  # S3 method for class 'numeric' SisterSize(tree, tip)  # S3 method for class 'character' SisterSize(tree, tip)  RootNodeDistance(tree, tip)  # S3 method for class 'numeric' RootNodeDistance(tree, tip)  # S3 method for class 'character' RootNodeDistance(tree, tip)  RootNodeDist(tree, tip)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Stemwardness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"tree tree class phylo. tip Either numeric specifying index single tip, character specifying label.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Stemwardness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"SisterSize() returns integer specifying number leaves clade sister tip. RootNodeDist() returns integer specifying number nodes tip root node tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Stemwardness.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"","text":"RootNodeDistance() calculates number nodes chosen leaf root tree. unsatisfactory measure, range possible distances function shape tree (Asher Smith 2022) . example, leaf X1 tree (.,(.,(.,(.,(X1,(,b)))))) falls outside clade (, b) root-node distance 4, whereas leaf X2 tree (.,((.,(.,.)),(b,(X2,)))) falls within clade (, b), considered \"crownwards\", yet smaller root-node distance (3).  SisterSize() measures number leaves clade sister chosen leaf, proposed Asher Smith (2022) . examples , X1 sister size 2 leaves, whereas X2, \"crownwards\", smaller sister size (1 leaf), desired.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Stemwardness.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"","text":"Asher R, Smith MR (2022). “Phylogenetic signal bias paleontology.” Systematic Biology, 71(4), 986–1008. doi:10.1093/sysbio/syab072 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Stemwardness.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Stemwardness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"bal8 <- BalancedTree(8) pec8 <- PectinateTree(8)  SisterSize(bal8, 3) #> [1] 1 SisterSize(pec8, \"t3\") #> [1] 5 SisterSize(RootTree(pec8, \"t3\"), \"t3\") #> [1] 7  RootNodeDist(bal8, 3) #> [1] 2 RootNodeDist(pec8, \"t3\") #> [1] 2 RootNodeDist(RootTree(pec8, \"t3\"), \"t3\") #> [1] 0"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subsplit.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset of a split on fewer leaves — Subsplit","title":"Subset of a split on fewer leaves — Subsplit","text":"Subsplit() removes leaves Splits object.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subsplit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset of a split on fewer leaves — Subsplit","text":"","code":"Subsplit(splits, tips, keepAll = FALSE, unique = TRUE)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subsplit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset of a split on fewer leaves — Subsplit","text":"splits object class Splits. tips vector specifying subset leaf labels applied split. keepAll logical specifying whether keep entries define trivial splits (.e. splits zero one leaf) subset leaves. unique logical specifying whether remove duplicate splits.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subsplit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset of a split on fewer leaves — Subsplit","text":"Subsplit() returns object class Splits, defined leaves tips.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subsplit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Subset of a split on fewer leaves — Subsplit","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subsplit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset of a split on fewer leaves — Subsplit","text":"","code":"splits <- as.Splits(PectinateTree(letters[1:9])) splits #> 6 bipartition splits dividing 9 tips, a .. i efgh <- Subsplit(splits, tips = letters[5:8], keepAll = TRUE) summary(efgh) #> 4 bipartition splits (3 trivial) dividing 4 tips, e .. h #>      1234 #>  12  **** #>  15  .*** #>  16  ..** #>  17  ...* #>  #>  Tip 1: e\t Tip 2: f\t Tip 3: g\t Tip 4: h\t  TrivialSplits(efgh) #>    12    15    16    17  #>  TRUE  TRUE FALSE  TRUE   summary(Subsplit(splits, tips = letters[5:8], keepAll = FALSE)) #> 1 bipartition split dividing 4 tips, e .. h #>      1234 #>  16  ..** #>  #>  Tip 1: e\t Tip 2: f\t Tip 3: g\t Tip 4: h"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subtree.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a subtree — Subtree","title":"Extract a subtree — Subtree","text":"Subtree() safely extracts clade phylogenetic tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subtree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a subtree — Subtree","text":"","code":"Subtree(tree, node)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subtree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a subtree — Subtree","text":"tree tree class phylo, internal numbering cladewise order (use Preorder(tree) (slower) Cladewise(tree)) . node number node base clade extracted.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subtree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a subtree — Subtree","text":"Subtree() returns tree class phylo represents clade extracted original tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subtree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract a subtree — Subtree","text":"Modified ape function extract.clade, sometimes behaves unpredictably. Unlike extract.clade, function supports extraction \"clades\" constitute single tip.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subtree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract a subtree — Subtree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Subtree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a subtree — Subtree","text":"","code":"tree <- Preorder(BalancedTree(8)) plot(tree) ape::nodelabels() ape::nodelabels(13, 13, bg=\"yellow\")   plot(Subtree(tree, 13))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SupportColour.html","id":null,"dir":"Reference","previous_headings":"","what":"Colour for node support value — SupportColour","title":"Colour for node support value — SupportColour","text":"Colour value display node support.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SupportColour.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Colour for node support value — SupportColour","text":"","code":"SupportColour(   support,   show1 = TRUE,   scale = rev(diverge_hcl(101, h = c(260, 0), c = 100, l = c(50, 90), power = 1)),   outOfRange = \"red\" )  SupportColor(   support,   show1 = TRUE,   scale = rev(diverge_hcl(101, h = c(260, 0), c = 100, l = c(50, 90), power = 1)),   outOfRange = \"red\" )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/SupportColour.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Colour for node support value — SupportColour","text":"support numeric vector values range 0–1. show1 Logical specifying whether display values 1. transparent white returned FALSE. scale 101-element vector listing colours sequence. Defaults diverging HCL scale. outOfRange Colour use results outside range 0–1.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/SupportColour.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Colour for node support value — SupportColour","text":"SupportColour() returns appropriate value scale, outOfRange value outwith valid range.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/SupportColour.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Colour for node support value — SupportColour","text":"","code":"SupportColour((-1):4 / 4, show1 = FALSE) #> [1] \"red\"       \"#D33F6A\"   \"#E495A5\"   \"#E2E2E2\"   \"#9DA8E2\"   \"#ffffff00\"  # An example forest of 100 trees, some identical forest <- as.phylo(c(1, rep(10, 79), rep(100, 15), rep(1000, 5)), nTip = 9)  # Generate an 80% consensus tree cons <- ape::consensus(forest, p = 0.8) plot(cons)   # Calculate split frequencies splitFreqs <- SplitFrequency(cons, forest)  # Optionally, colour edges by corresponding frequency. # Note that not all edges are associated with a unique split # (and two root edges may be associated with one split - not handled here) edgeSupport <- rep(1, nrow(cons$edge)) # Initialize trivial splits to 1 childNode <- cons$edge[, 2] edgeSupport[match(names(splitFreqs), childNode)] <- splitFreqs / 100  plot(cons, edge.col = SupportColour(edgeSupport), edge.width = 3)  # Annotate nodes by frequency  LabelSplits(cons, splitFreqs, unit = \"%\",             col = SupportColor(splitFreqs / 100),             frame = \"none\", pos = 3L)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipLabels.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract tip labels — TipLabels","title":"Extract tip labels — TipLabels","text":"TipLabels() extracts labels object: example, names taxa phylogenetic tree data matrix.  AllTipLabels() extracts labels, entries list trees may pertain different taxa.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipLabels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract tip labels — TipLabels","text":"","code":"TipLabels(x, single = TRUE)  # Default S3 method TipLabels(x, single = TRUE)  # S3 method for class 'matrix' TipLabels(x, single = TRUE)  # S3 method for class 'logical' TipLabels(x, single = TRUE)  # S3 method for class 'phylo' TipLabels(x, single = TRUE)  # S3 method for class 'phyDat' TipLabels(x, single = TRUE)  # S3 method for class 'MixedBase' TipLabels(x, single = TRUE)  # S3 method for class 'TreeNumber' TipLabels(x, single = TRUE)  # S3 method for class 'Splits' TipLabels(x, single = TRUE)  # S3 method for class 'list' TipLabels(x, single = FALSE)  # S3 method for class 'multiPhylo' TipLabels(x, single = FALSE)  # S3 method for class 'character' TipLabels(x, single = TRUE)  # S3 method for class 'numeric' TipLabels(x, single = TRUE)  # S3 method for class 'phyDat' TipLabels(x, single = TRUE)  AllTipLabels(x)  # S3 method for class 'list' AllTipLabels(x)  # S3 method for class 'multiPhylo' AllTipLabels(x)  # S3 method for class 'phylo' AllTipLabels(x)  # S3 method for class 'Splits' AllTipLabels(x)  # S3 method for class 'TreeNumber' AllTipLabels(x)  # S3 method for class 'matrix' AllTipLabels(x)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipLabels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract tip labels — TipLabels","text":"x object supported class (see Usage section ). single Logical specifying whether report labels first object (TRUE), object list (FALSE).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipLabels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract tip labels — TipLabels","text":"TipLabels() returns character vector listing tip labels appropriate x. x single integer, vector t1, t2 ... tx, match default rtree().","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipLabels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract tip labels — TipLabels","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipLabels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract tip labels — TipLabels","text":"","code":"TipLabels(BalancedTree(letters[5:1])) #> [1] \"e\" \"d\" \"c\" \"b\" \"a\" TipLabels(5) #> [1] \"t1\" \"t2\" \"t3\" \"t4\" \"t5\"  data(\"Lobo\") head(TipLabels(Lobo.phy)) #> [1] \"Tubiluchus_Priapulida\"  \"Cricocosmia\"            \"Aysheaia\"               #> [4] \"Siberion\"               \"Onychodictyon_ferox\"    \"Onychodictyon_gracilis\"  AllTipLabels(c(BalancedTree(4), PectinateTree(8))) #> [1] \"t1\" \"t2\" \"t3\" \"t4\" \"t5\" \"t6\" \"t7\" \"t8\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipTimedTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Display time-calibrated tree using tip information only — TipTimedTree","title":"Display time-calibrated tree using tip information only — TipTimedTree","text":"TipTimedTree() plots phylogenetic tree time using ad hoc approach based dates associated leaves. Nodes dated youngest possible value, plus additional \"buffer\" (specified minEdge) ensure branching order readable.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipTimedTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display time-calibrated tree using tip information only — TipTimedTree","text":"","code":"TipTimedTree(tree, tipAge, minEdge = 1)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipTimedTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display time-calibrated tree using tip information only — TipTimedTree","text":"tree tree class phylo. tipAge Numeric vector specifying age (units--time ago) associated tip tree$tip.label turn. Older ages signify earlier tips. minEdge Minimum length edge allow (units--time)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipTimedTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display time-calibrated tree using tip information only — TipTimedTree","text":"TipTimedTree() returns tree edge lengths set based ages tip.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipTimedTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Display time-calibrated tree using tip information only — TipTimedTree","text":"experimental function liable change behaviour, deprecated, coming releases. Please contact maintainer find useful, production-ready version can prioritized.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipTimedTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display time-calibrated tree using tip information only — TipTimedTree","text":"","code":"tree <- BalancedTree(6) plot(TipTimedTree(tree, tipAge = 1:6, minEdge = 2))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipsInSplits.html","id":null,"dir":"Reference","previous_headings":"","what":"Tips contained within splits — TipsInSplits","title":"Tips contained within splits — TipsInSplits","text":"TipsInSplits() specifies number tips occur within bipartition split Splits object.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipsInSplits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tips contained within splits — TipsInSplits","text":"","code":"TipsInSplits(splits, keep.names = TRUE, smallest = FALSE, ...)  # S3 method for class 'Splits' TipsInSplits(splits, keep.names = TRUE, smallest = FALSE, ...)  # S3 method for class 'phylo' TipsInSplits(splits, keep.names = TRUE, smallest = FALSE, ...)  SplitImbalance(splits, keep.names = TRUE, ...)  # S3 method for class 'Splits' SplitImbalance(splits, keep.names = TRUE, ...)  # S3 method for class 'phylo' SplitImbalance(splits, keep.names = TRUE, ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipsInSplits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tips contained within splits — TipsInSplits","text":"splits Object class Splits phylo. keep.names Logical specifying whether include names splits output. smallest Logical; TRUE, return number leaves smaller bipartition. ... Additional parameters pass .Splits().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipsInSplits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tips contained within splits — TipsInSplits","text":"TipsInSplits() returns named vector integers, specifying number tips contained within split splits. SplitImbalance() returns named vector integers, specifying number leaves within split \"balanced\" leaf outside ; .e. split divides leaves evenly imbalance zero; one splits two tips ten imbalance 10 - 2 = 8.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TipsInSplits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tips contained within splits — TipsInSplits","text":"","code":"tree <- PectinateTree(8) splits <- as.Splits(tree) TipsInSplits(splits) #> 11 12 13 14 15  #>  6  5  4  3  2   plot(tree) LabelSplits(tree, as.character(splits), frame = \"none\", pos = 3L, cex = 0.7) LabelSplits(tree, TipsInSplits(splits), unit = \" tips\", frame = \"none\",             pos = 1L)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TopologyOnly.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove metadata from trees — TopologyOnly","title":"Remove metadata from trees — TopologyOnly","text":"TopologyOnly() removes information trees except topologies leaf labels.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TopologyOnly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove metadata from trees — TopologyOnly","text":"","code":"TopologyOnly(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TopologyOnly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove metadata from trees — TopologyOnly","text":"tree tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TopologyOnly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove metadata from trees — TopologyOnly","text":"Returns tree, tree Preorder, edge lengths, node labels attributes removed.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TopologyOnly.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Remove metadata from trees — TopologyOnly","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TotalCopheneticIndex.html","id":null,"dir":"Reference","previous_headings":"","what":"Total Cophenetic Index — TotalCopheneticIndex","title":"Total Cophenetic Index — TotalCopheneticIndex","text":"TotalCopheneticIndex() calculates total cophenetic index (Mir et al. 2013)  tree, measure balance; TCIContext() lists possible values.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TotalCopheneticIndex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Total Cophenetic Index — TotalCopheneticIndex","text":"","code":"TotalCopheneticIndex(x)  TCIContext(x)  # S3 method for class 'numeric' TCIContext(x)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TotalCopheneticIndex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Total Cophenetic Index — TotalCopheneticIndex","text":"x tree class phylo, $edge property, list thereof.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TotalCopheneticIndex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Total Cophenetic Index — TotalCopheneticIndex","text":"TotalCopheneticIndex() returns integer denoting total cophenetic index. TCIContext() returns data frame detailing maximum minimum value obtainable Total Cophenetic Index rooted binary trees number leaves given tree, expected value Yule Uniform models. variance expected value given Yule model, obtained calculation Uniform model.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TotalCopheneticIndex.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Total Cophenetic Index — TotalCopheneticIndex","text":"Total Cophenetic Index measure tree balance – .e. whether (phylogenetic) tree comprises symmetric pairs nodes, pectinate \"caterpillar\" shape. index greater resolution power Sackin's Colless' indices, can applied trees perfectly resolved. tree n leaves, Total Cophenetic Index can take values 0 choose(n, 3). minimum value higher perfectly resolved (.e. dichotomous) tree (see Lemma 14 Mir et al. 2013). Formulae calculate expected values Yule Uniform models evolution given Theorems 17 23. Full details provided Mir et al. (2013) . J1 index (Lemant et al. 2022)  advantages Total Cophenetic Index, particularly comparing trees different numbers leaves, population size nodes meaningful; see J1Index().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TotalCopheneticIndex.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Total Cophenetic Index — TotalCopheneticIndex","text":"Lemant J, Le Sueur C, Manojlović V, Noble R (2022). “Robust, Universal Tree Balance Indices.” Systematic Biology, 71(5), 1210–1224. doi:10.1093/sysbio/syac027 . Mir , Rosselló F, Rotger LA (2013). “new balance index phylogenetic trees.” Mathematical Biosciences, 241(1), 125–136. doi:10.1016/j.mbs.2012.10.005 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TotalCopheneticIndex.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Total Cophenetic Index — TotalCopheneticIndex","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TotalCopheneticIndex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Total Cophenetic Index — TotalCopheneticIndex","text":"","code":"# Balanced trees have the minimum index for a binary tree; # Pectinate trees the maximum: TCIContext(8) #>   maximum minimum uniform.expected yule.expected yule.variance #> 1      56      16          38.8345      28.51429      90.52281 TotalCopheneticIndex(PectinateTree(8)) #> [1] 56 TotalCopheneticIndex(BalancedTree(8)) #> [1] 16 TotalCopheneticIndex(StarTree(8)) #> [1] 0   # Examples from Mir et al. (2013): tree12 <- ape::read.tree(text=\"(1, (2, (3, (4, 5))));\")  #Fig. 4, tree 12 TotalCopheneticIndex(tree12) # 10 #> [1] 10 tree8  <- ape::read.tree(text=\"((1, 2, 3, 4), 5);\")      #Fig. 4, tree 8 TotalCopheneticIndex(tree8)  # 6 #> [1] 6 TCIContext(tree8) #>   maximum minimum uniform.expected yule.expected yule.variance #> 1      10       5         8.285714      7.166667      5.138889 TCIContext(5L) # Context for a tree with 5 leaves. #>   maximum minimum uniform.expected yule.expected yule.variance #> 1      10       5         8.285714      7.166667      5.138889"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeIsRooted.html","id":null,"dir":"Reference","previous_headings":"","what":"Is tree rooted? — TreeIsRooted","title":"Is tree rooted? — TreeIsRooted","text":"TreeIsRooted() fast alternative ape::.rooted().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeIsRooted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is tree rooted? — TreeIsRooted","text":"","code":"TreeIsRooted(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeIsRooted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is tree rooted? — TreeIsRooted","text":"tree phylogenetic tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeIsRooted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is tree rooted? — TreeIsRooted","text":"TreeIsRooted() returns logical specifying whether root node resolved.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeIsRooted.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Is tree rooted? — TreeIsRooted","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeIsRooted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is tree rooted? — TreeIsRooted","text":"","code":"TreeIsRooted(BalancedTree(6)) #> [1] TRUE TreeIsRooted(UnrootTree(BalancedTree(6))) #> [1] FALSE"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeNumber.html","id":null,"dir":"Reference","previous_headings":"","what":"Unique integer indices for bifurcating tree topologies — TreeNumber","title":"Unique integer indices for bifurcating tree topologies — TreeNumber","text":"Functions converting phylogenetic trees unique decimal representation, based concept John Tromp, employed (Li et al. 1996) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeNumber.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unique integer indices for bifurcating tree topologies — TreeNumber","text":"","code":"as.TreeNumber(x, ...)  # S3 method for class 'phylo' as.TreeNumber(x, ...)  # S3 method for class 'multiPhylo' as.TreeNumber(x, ...)  # S3 method for class 'character' as.TreeNumber(x, nTip, tipLabels = TipLabels(nTip), ...)  # S3 method for class 'TreeNumber' as.TreeNumber(x, ...)  # S3 method for class 'MixedBase' as.TreeNumber(x, ...)  # S3 method for class 'TreeNumber' as.MixedBase(x, ...)  # S3 method for class 'integer64' as.MixedBase(x, tipLabels = NULL, ...)  # S3 method for class 'numeric' as.MixedBase(x, tipLabels = NULL, ...)  # S3 method for class 'numeric' as.phylo(x, nTip = attr(x, \"nTip\"), tipLabels = attr(x, \"tip.label\"), ...)  # S3 method for class 'TreeNumber' as.phylo(x, nTip = attr(x, \"nTip\"), tipLabels = attr(x, \"tip.label\"), ...)  as.MixedBase(x, ...)  # S3 method for class 'MixedBase' as.MixedBase(x, ...)  # S3 method for class 'phylo' as.MixedBase(x, ...)  # S3 method for class 'multiPhylo' as.MixedBase(x, ...)  # S3 method for class 'MixedBase' as.phylo(x, nTip = attr(x, \"nTip\"), tipLabels = attr(x, \"tip.label\"), ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeNumber.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unique integer indices for bifurcating tree topologies — TreeNumber","text":"x Integer identifying tree (see details). ... Additional parameters consistency S3 methods (unused). nTip Integer specifying number leaves tree. tipLabels Character vector listing labels assigned tip tree, perhaps obtained using TipLabels().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeNumber.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unique integer indices for bifurcating tree topologies — TreeNumber","text":".TreeNumber() returns object class TreeNumber, comprises numeric vector, whose elements represent successive nine-digit chunks decimal integer corresponding tree topology (big endian order).  TreeNumber object attributes nTip tip.label.  x list trees multiPhylo object, .TreeNumber() returns corresponding list TreeNumber objects. .phylo.numeric() returns tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeNumber.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Unique integer indices for bifurcating tree topologies — TreeNumber","text":"NUnrooted(n) unrooted trees n leaves. , n-leaf tree can uniquely identified non-negative integer x < NUnrooted(n). integer can converted tree treating mixed-base number, bases 1, 3, 5, 7, … (2 n - 5). digit mixed base number corresponds leaf, determines location growing tree leaf added. start two-leaf tree, treat 0 origin tree.   add leaf 2 breaking edge inserting node (numbered 2 + nTip - 1). example, work six-leaf tree; node numbered 2 + 6 - 1 = 7. one edge leaf 2 can added.  add node 7 leaf 2:   now three edges leaf 3 can added.  options : Option 0: edge leading 1; Option 1: edge leading 2; Option 2: edge leading 7. select option 1, produce:   1 now final digit mixed-base number. five places add leaf 4: Option 0: edge leading 1; Option 1: edge leading 2; Option 2: edge leading 3; Option 3: edge leading 7; Option 4: edge leading 8. chose option 3, 3 penultimate digit mixed-base number. chose option 0 next two additions, specify tree mixed-base number 0021.  can convert decimal: 0 × (1 × 3 × 5 × 9) + 0 × (1 × 3 × 5) + 3 × (1 × 3) + 1 × (1) = 10 Note hyperexponential nature tree space means > 2^64 unique 20-leaf trees.  TreeNumber 64-bit integer, trees 19 leaves can accommodated.","code":"0 ---- 1 0 ---- 7 ---- 1        |        |        2 0 ---- 7 ---- 1        |        |        8 ---- 2        |        |        3"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeNumber.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Unique integer indices for bifurcating tree topologies — TreeNumber","text":"Li M, Tromp J, Zhang L (1996). “notes nearest neighbour interchange distance.” Goos G, Hartmanis J, Leeuwen J, Cai J, Wong CK (eds.), Computing Combinatorics, volume 1090, 343–351. Springer, Berlin, Heidelberg. ISBN 978-3-540-61332-9, doi:10.1007/3-540-61332-3_168 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeNumber.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Unique integer indices for bifurcating tree topologies — TreeNumber","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeNumber.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unique integer indices for bifurcating tree topologies — TreeNumber","text":"","code":"tree <- as.phylo(10, nTip = 6) plot(tree)  as.TreeNumber(tree) #> Phylogenetic tree number 10 of 105  #>  6 tips: t1 t2 t3 t4 t5 t6  # Larger trees: as.TreeNumber(BalancedTree(19)) #> Phylogenetic tree number 3259279213732796827 of 6332659870762850625  #>  19 tips: t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19  # If > 9 digits, represent the tree number as a string. treeNumber <- as.TreeNumber(\"1234567890123\", nTip = 14) tree <- as.phylo(treeNumber) as.phylo(0:2, nTip = 6, tipLabels = letters[1:6]) #> 3 phylogenetic trees"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeShape.html","id":null,"dir":"Reference","previous_headings":"","what":"Integer representing shape of a tree — unrootedKeys","title":"Integer representing shape of a tree — unrootedKeys","text":"Returns integer uniquely represents shape n-tip binary tree, ignoring tip labels.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeShape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integer representing shape of a tree — unrootedKeys","text":"","code":"unrootedKeys  RootedTreeShape(tree)  RootedTreeWithShape(shape, nTip, tipLabels)  UnrootedTreeWithShape(shape, nTip, tipLabels = character(nTip))  UnrootedTreeWithKey(key, nTip, tipLabels = character(nTip))  UnrootedTreeShape(tree)  UnrootedTreeKey(tree, asInteger = FALSE)  .UnrootedKeys(nTip)  UnrootedKeys(..., envir = parent.frame())  NUnrootedShapes(nTip)  NRootedShapes(nTip)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeShape.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Integer representing shape of a tree — unrootedKeys","text":"unrootedKeys list length 22; entry vector integers corresponding keys (shape numbers) different unrooted tree shapes nTip leaves.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeShape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integer representing shape of a tree — unrootedKeys","text":"tree tree class phylo. shape Integer specifying shape tree, perhaps generated TreeShape(). nTip Integer specifying number tips. tipLabels Character vector listing labels assigned tip tree, perhaps obtained using TipLabels(). key Integer specifying key (number) unrooted tree. asInteger Logical specifying whether coerce return value mode integer: possible values < 2^31. FALSE, values class integer64. ... Value nTip, pass memoized .UnrootedKeys. envir Unused; passed addMemoization().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeShape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integer representing shape of a tree — unrootedKeys","text":"TreeShape() returns integer specifying shape tree, ignoring tip labels. RootedTreeWithShape() returns tree class phylo corresponding shape provided.  Tips unlabelled. UnrootedTreeWithShape() returns tree class phylo corresponding shape provided.  Tips unlabelled. UnrootedTreeWithKey() returns tree class phylo corresponding key provided.  Tips unlabelled. UnrootedKeys() returns vector integers corresponding keys (shape numbers) unrooted tree shapes nTip tips. wrapper .UnrootedKeys(), memoization, meaning results calculated cached need calculated future calls function. NUnrootedShapes() returns object class integer64 specifying number unique unrooted tree shapes nTip (< 61) tips. NRootedShapes() returns object class integer64 specifying number unique rooted tree shapes nTip (< 56) leaves.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeShape.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Integer representing shape of a tree — unrootedKeys","text":"Rooted trees numbered working root. root node divides n tips two subtrees.  smaller subtree may contain $= 1, 2, ..., n/2$ tips, leaving $b = n - $ tips options worked turn. first shape smaller subtree, work possible shape larger subtree.  , move next shape smaller subtree, work possible shape larger subtree. Stop desired topology encountered. Unrooted trees numbered less elegantly.  cherry (.e. node subtending pair tips) treated turn.  subtended tips removed, node treated root rooted tree.  number rooted tree calculated.  tree assigned key corresponding lowest value.  keys unrooted tree shapes n tips ranked, unrooted tree shape assigned number based rank order key among possible keys, counting zero. UnrootedTreeShape() UnrootedTreeKey() passed rooted tree, position root ignored. number unlabelled binary rooted trees corresponds Wedderburn-Etherington numbers.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeShape.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Integer representing shape of a tree — unrootedKeys","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeShape.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integer representing shape of a tree — unrootedKeys","text":"","code":"RootedTreeShape(PectinateTree(8)) #> integer64 #> [1] 0 plot(RootedTreeWithShape(0, nTip = 8L))   NRootedShapes(8L) #> integer64 #> [1] 23 # Shapes are numbered from 0 to NRootedShapes(n) - 1.  The maximum shape is: RootedTreeShape(BalancedTree(8)) #> integer64 #> [1] 22  # Unique shapes of unrooted trees: NUnrootedShapes(8L) #> integer64 #> [1] 4  # Keys of these trees: UnrootedKeys(8L) #> [1] 0 1 2 4  # A tree may be represented by multiple keys. # For a one-to-one correspondence, use a number instead: unrootedShapes8 <- as.integer(NUnrootedShapes(8L)) allShapes <- lapply(seq_len(unrootedShapes8) - 1L,                     UnrootedTreeWithShape, 8L) plot(allShapes[[1]])  sapply(allShapes, UnrootedTreeShape) #> [1] 0 1 2 3 sapply(allShapes, UnrootedTreeKey, asInteger = TRUE) # Key >= number #> [1] 0 1 2 4  # If numbers larger than 2>31 are required, sapply needs a little help # with 64-bit integers: structure(sapply(allShapes, UnrootedTreeKey), class = \"integer64\") #> integer64 #> [1] 0 1 2 4"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeTools-package.html","id":null,"dir":"Reference","previous_headings":"","what":"TreeTools — TreeTools-package","title":"TreeTools — TreeTools-package","text":"\"TreeTools\" R package provides functions creating, modifying analysing phylogenetic trees. complements packages ape, phangorn phytools, aiming efficient robust implementations functions, typically applied unweighted trees (.e. without edge lengths).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeTools-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"TreeTools — TreeTools-package","text":"Full documentation available online.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreeTools-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"TreeTools — TreeTools-package","text":"Maintainer: Martin R. Smith martin.smith@durham.ac.uk (ORCID) [copyright holder] contributors: Emmanuel Paradis (ORCID) [copyright holder] Robert Noble (ORCID) [copyright holder]","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Treeness.html","id":null,"dir":"Reference","previous_headings":"","what":"Relative length of internal branches — Treeness","title":"Relative length of internal branches — Treeness","text":"Treeness (also termed stemminess) proportion tree's length found internal branches (Lanyon 1988) . Insofar external branches contain phylogenetic (grouping) signal, trees high treeness can interpreted containing higher signal:noise ratio (Phillips Penny 2003-08) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Treeness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relative length of internal branches — Treeness","text":"","code":"Treeness(tree)  Stemminess(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Treeness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relative length of internal branches — Treeness","text":"tree tree class phylo, list trees class list multiPhylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Treeness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relative length of internal branches — Treeness","text":"Treeness() returns numeric vector reporting treeness tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Treeness.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Relative length of internal branches — Treeness","text":"Lanyon SM (1988). “Stochastic Mode Molecular Evolution: Consequences Systematic Investigations?” Auk, 105(3), 565–573. doi:10.1093/auk/105.3.565 . Phillips MJ, Penny D (2003-08). “Root Mammalian Tree Inferred Whole Mitochondrial Genomes.” Molecular Phylogenetics Evolution, 28(2), 171–185. doi:10.1016/S1055-7903(03)00057-5 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Treeness.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Relative length of internal branches — Treeness","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Treeness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relative length of internal branches — Treeness","text":"","code":"lowTree <- BalancedTree(6, lengths = c(1, 1, 4, 4, 4, 1, 1, 4, 4, 4)) plot(lowTree)  Treeness(lowTree) #> [1] 0.1428571 highTree <- BalancedTree(6, lengths = c(6, 6, 1, 1, 1, 6, 6, 1, 1, 1)) plot(highTree)  Treeness(c(lowTree, highTree)) #> [1] 0.1428571 0.8000000"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingSplit.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of trees matching a bipartition split — TreesMatchingSplit","title":"Number of trees matching a bipartition split — TreesMatchingSplit","text":"Calculates number unrooted bifurcated trees consistent bipartition split divides taxa groups size B.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingSplit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of trees matching a bipartition split — TreesMatchingSplit","text":"","code":"TreesMatchingSplit(A, B = A[2])  LnTreesMatchingSplit(A, B = A[2])  Log2TreesMatchingSplit(A, B = A[2])"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingSplit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of trees matching a bipartition split — TreesMatchingSplit","text":", B Integer specifying number taxa partition.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingSplit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of trees matching a bipartition split — TreesMatchingSplit","text":"TreesMatchingSplit() returns numeric specifying number trees compatible given split. LnTreesMatchingSplit() Log2TreesMatchingSplit() give natural base-2 logarithms number.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingSplit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of trees matching a bipartition split — TreesMatchingSplit","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingSplit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of trees matching a bipartition split — TreesMatchingSplit","text":"","code":"TreesMatchingSplit(5, 6) #> [1] 99225 LnTreesMatchingSplit(5, 6) #> [1] 11.50515 Log2TreesMatchingSplit(5, 6) #> [1] 16.59842"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of trees containing a tree — TreesMatchingTree","title":"Number of trees containing a tree — TreesMatchingTree","text":"TreesMatchingTree() calculates number unrooted binary trees consistent tree topology leaves.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of trees containing a tree — TreesMatchingTree","text":"","code":"TreesMatchingTree(tree)  LnTreesMatchingTree(tree)  Log2TreesMatchingTree(tree)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of trees containing a tree — TreesMatchingTree","text":"tree tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of trees containing a tree — TreesMatchingTree","text":"TreesMatchingTree() returns numeric specifying number unrooted binary trees contain edges present input tree. LnTreesMatchingTree() gives natural logarithm number.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of trees containing a tree — TreesMatchingTree","text":"Remember unroot tree first position root arbitrary.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of trees containing a tree — TreesMatchingTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TreesMatchingTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of trees containing a tree — TreesMatchingTree","text":"","code":"partiallyResolvedTree <- CollapseNode(BalancedTree(8), 12:15) TreesMatchingTree(partiallyResolvedTree) #> [1] 45 LnTreesMatchingTree(partiallyResolvedTree) #> [1] 3.806662  # Number of rooted trees: rootedTree <- AddTip(partiallyResolvedTree, where = 0) TreesMatchingTree(partiallyResolvedTree) #> [1] 45"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialSplits.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify and remove trivial splits — TrivialSplits","title":"Identify and remove trivial splits — TrivialSplits","text":"TrivialSplits() identifies trivial splits (separate one zero leaves others); WithoutTrivialSplits() removes Splits object.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialSplits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify and remove trivial splits — TrivialSplits","text":"","code":"TrivialSplits(splits, nTip = attr(splits, \"nTip\"))  WithoutTrivialSplits(splits, nTip = attr(splits, \"nTip\"))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialSplits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify and remove trivial splits — TrivialSplits","text":"splits object class Splits. nTip Integer specifying number tips (leaves).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialSplits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify and remove trivial splits — TrivialSplits","text":"TrivialSplits() returns logical vector specifying whether split splits trivial, .e. includes excludes single tip tips . WithoutTrivialSplits() returns Splits object trivial splits removed.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialSplits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify and remove trivial splits — TrivialSplits","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialSplits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify and remove trivial splits — TrivialSplits","text":"","code":"splits <- as.Splits(PectinateTree(letters[1:9])) efgh <- Subsplit(splits, tips = letters[5:8], keepAll = TRUE) summary(efgh) #> 4 bipartition splits (3 trivial) dividing 4 tips, e .. h #>      1234 #>  12  **** #>  15  .*** #>  16  ..** #>  17  ...* #>  #>  Tip 1: e\t Tip 2: f\t Tip 3: g\t Tip 4: h\t  TrivialSplits(efgh) #>    12    15    16    17  #>  TRUE  TRUE FALSE  TRUE  summary(WithoutTrivialSplits(efgh)) #> 1 bipartition split dividing 4 tips, e .. h #>      1234 #>  16  ..** #>  #>  Tip 1: e\t Tip 2: f\t Tip 3: g\t Tip 4: h"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate trivial trees — TrivialTree","title":"Generate trivial trees — TrivialTree","text":"SingleTaxonTree() creates phylogenetic \"tree\" contains single taxon. ZeroTaxonTree() creates empty phylo object zero leaves edges.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate trivial trees — TrivialTree","text":"","code":"SingleTaxonTree(label = \"t1\", lengths = NULL)  ZeroTaxonTree()"},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate trivial trees — TrivialTree","text":"label character vector specifying label tip. lengths numeric vector specifying edge lengths tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate trivial trees — TrivialTree","text":"SingleTaxonTree() returns phylo object containing single tip specified label. ZeroTaxonTree() returns empty phylo object.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/TrivialTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate trivial trees — TrivialTree","text":"","code":"SingleTaxonTree(\"Homo_sapiens\") #>  #> Phylogenetic tree with 1 tip and 1 internal node. #>  #> Tip label: #>   Homo_sapiens #>  #> Rooted; no branch length. plot(SingleTaxonTree(\"root\") + BalancedTree(4))   ZeroTaxonTree() #>  #> Phylogenetic tree with 0 tips and 0 internal nodes. #>  #> Tip labels: #>    #>  #> Rooted; no branch length."},{"path":"https://ms609.github.io/TreeTools/dev/reference/Unquote.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove quotation marks from a string — Unquote","title":"Remove quotation marks from a string — Unquote","text":"Remove quotation marks string","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Unquote.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove quotation marks from a string — Unquote","text":"","code":"Unquote(string)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/Unquote.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove quotation marks from a string — Unquote","text":"string Input string","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Unquote.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove quotation marks from a string — Unquote","text":"Unquote() returns string, matched punctuation marks trailing whitespace removed.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/Unquote.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Remove quotation marks from a string — Unquote","text":"Martin R. Smith","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/Unquote.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove quotation marks from a string — Unquote","text":"","code":"Unquote(\"'Hello World'\") #> [1] \"Hello World\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnrootedTreesMatchingSplit.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of trees consistent with split — UnrootedTreesMatchingSplit","title":"Number of trees consistent with split — UnrootedTreesMatchingSplit","text":"Calculates number unrooted bifurcating trees consistent specified multi-partition split, using theorem two Carter et al. (1990) .","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnrootedTreesMatchingSplit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of trees consistent with split — UnrootedTreesMatchingSplit","text":"","code":"UnrootedTreesMatchingSplit(...)  LnUnrootedTreesMatchingSplit(...)  Log2UnrootedTreesMatchingSplit(...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnrootedTreesMatchingSplit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of trees consistent with split — UnrootedTreesMatchingSplit","text":"... series vector integers listing number tips number tree splits (e.g. bipartitions). example, 3, 5 states character divides set eight tips group three group five.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnrootedTreesMatchingSplit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of trees consistent with split — UnrootedTreesMatchingSplit","text":"UnrootedTreesMatchingSplit() returns integer specifying number unrooted bifurcating trees consistent specified split.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnrootedTreesMatchingSplit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Number of trees consistent with split — UnrootedTreesMatchingSplit","text":"Carter M, Hendy M, Penny D, Székely LA, Wormald NC (1990). “distribution lengths evolutionary trees.” SIAM Journal Discrete Mathematics, 3(1), 38–47. doi:10.1137/0403005 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnrootedTreesMatchingSplit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of trees consistent with split — UnrootedTreesMatchingSplit","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnrootedTreesMatchingSplit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of trees consistent with split — UnrootedTreesMatchingSplit","text":"","code":"UnrootedTreesMatchingSplit(c(3, 5)) #> [1] 315 UnrootedTreesMatchingSplit(3, 2, 1, 2) #> [1] 297"},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnshiftTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Add tree to start of list — UnshiftTree","title":"Add tree to start of list — UnshiftTree","text":"UnshiftTree() adds phylogenetic tree start list trees. useful class list trees unknown, names trees retained.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnshiftTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add tree to start of list — UnshiftTree","text":"","code":"UnshiftTree(add, treeList)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnshiftTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add tree to start of list — UnshiftTree","text":"add Tree add list, class phylo. treeList list trees, class list, multiPhylo, , single tree, phylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnshiftTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add tree to start of list — UnshiftTree","text":"UnshiftTree() returns list class list multiPhylo (following original class treeList), whose first element tree specified `add.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnshiftTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add tree to start of list — UnshiftTree","text":"Caution: adding tree multiPhylo object whose attributes apply trees, example trees read Nexus file, causes data lost.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnshiftTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add tree to start of list — UnshiftTree","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/UnshiftTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add tree to start of list — UnshiftTree","text":"","code":"forest <- as.phylo(0:5, 6) tree <- BalancedTree(6)  UnshiftTree(tree, forest) #> 7 phylogenetic trees UnshiftTree(tree, tree) #> 2 phylogenetic trees"},{"path":"https://ms609.github.io/TreeTools/dev/reference/WriteTntCharacters.html","id":null,"dir":"Reference","previous_headings":"","what":"Write morphological character matrix to TNT file — WriteTntCharacters","title":"Write morphological character matrix to TNT file — WriteTntCharacters","text":"Write morphological character matrix TNT file","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/WriteTntCharacters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write morphological character matrix to TNT file — WriteTntCharacters","text":"","code":"WriteTntCharacters(   dataset,   filepath = NULL,   comment = \"Dataset written by `TreeTools::WriteTntCharacters()`\",   types = NULL,   pre = \"\",   post = \"\" )  # S3 method for class 'phyDat' WriteTntCharacters(   dataset,   filepath = NULL,   comment = \"Dataset written by `TreeTools::WriteTntCharacters()`\",   types = NULL,   pre = \"\",   post = \"\" )  # S3 method for class 'matrix' WriteTntCharacters(   dataset,   filepath = NULL,   comment = \"Dataset written by `TreeTools::WriteTntCharacters()`\",   types = NULL,   pre = \"\",   post = \"\" )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/WriteTntCharacters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write morphological character matrix to TNT file — WriteTntCharacters","text":"dataset Morphological dataset class phyDat matrix. filepath Path file; NULL, returns character vector. comment Optional comment entitle matrix. types Optional list specifying different data types begin. c(num = 1, dna = 10) sets characters 1..9 numeric, 10..end DNA. pre, post Character vector listing text print character matrix.  Specify pre = 'piwe=; matrix analysed using extended implied weighting (xpiwe=).","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/WriteTntCharacters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Write morphological character matrix to TNT file — WriteTntCharacters","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/WriteTntCharacters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write morphological character matrix to TNT file — WriteTntCharacters","text":"","code":"data(\"Lobo\", package = \"TreeTools\")  WriteTntCharacters(Lobo.phy) #> [1] \"\\nxread 'Dataset written by `TreeTools::WriteTntCharacters()`'\\n115 48\\nTubiluchus_Priapulida 0 0 - - - - 0 0 0 0 0 - 0 1 0 0 1 1 1 1 0 0 - - - - - - - - - - - - - - - - - 0 - - - 0 0 0 1 - 1 0 0 0 - - - - - - 0 - - - - 1 0 0 - - - - - - - - - - - 0 - 0 - - 0 0 - 0 0 - - - - 0 0 - - 0 0 0 - - 0 0 - - 1 1 1 - - 0 0 0 1 1 1\\nCricocosmia 0 0 - - - - 0 0 0 0 0 - 0 1 0 0 1 1 1 ? 0 0 - - - - - - - - - - - - - - - - - 0 - - - 0 0 0 1 - 1 0 0 1 1 0 0 - 1 0 0 1 - 0 0 1 0 0 - - - - - - - - - - - 0 - 0 - - 0 0 - 0 0 - - - - 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ?\\nAysheaia 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 ? 0 ? ? ? 0 - - 0 1 0 - 0 0 - 0 - 0 - 0 0 - - 1 0 - 1 0 0 0 1 1 1 0 0 0 - - - - - - 0 - - - - 1 0 0 0 - 0 - - 0 1 0 0 0 0 0 1 0 4 0 0 0 - 0 0 - - - 0 0 1 1 - 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ?\\nSiberion 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 ? 0 ? ? ? 0 - - 0 1 0 - 0 0 - 0 - 0 - 0 1 0 - ? ? ? ? 0 0 0 1 1 ? 0 0 0 - - - - - - ? - - - - 1 ? 0 0 - 0 - - 0 ? ? ? 0 0 ? ? ? ? ? ? 0 - 0 0 - - - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nOnychodictyon_ferox 1 0 - - - - 0 0 0 0 0 - 0 ? ? ? ? 0 ? ? ? 1 0 0 0 1 0 - 0 0 - 0 - 0 - 0 0 - - 1 1 1 0 0 0 0 1 1 1 1 0 1 1 0 1 0 1 0 ? 1 - 0 0 1 0 0 0 - 0 - - 0 1 1 - 0 0 0 1 0 1 1 0 0 - 0 0 - - - 0 0 1 1 - 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nOnychodictyon_gracilis 1 0 - - - - 0 ? ? 0 0 - 0 ? ? ? ? 0 ? ? ? ? ? ? 0 ? ? ? 0 ? - ? - 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 0 ? 0 1 1 0 ? ? 1 ? ? 1 - 0 0 1 0 ? 0 - 0 - - 0 ? ? ? 0 0 0 1 0 1 ? 0 0 - 0 0 ? ? - 1 0 1 1 - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nDiania 1 0 - - - - 0 0 0 0 0 - ? ? ? ? ? 0 ? ? ? 0 - - 0 0 - - 0 0 - 0 - 0 - 0 0 - - 0 - - - 0 0 0 1 1 0 1 0 1 1 0 0 - 0 ? ? 0 - 0 0 1 0 0 0 - 0 - - 0 1 0 0 0 0 0 ? ? - - 0 0 - 0 0 - - - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nXenusion 1 0 - - - - 0 ? 0 0 ? ? ? ? ? ? ? ? ? ? ? 0 - - 0 0 - - 0 0 - 0 - 0 - 0 0 - - ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 0 0 - 0 ? ? 1 - 0 0 1 ? 0 0 - 0 - - 0 1 ? ? ? ? ? ? ? ? ? ? 0 - 0 0 - - - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nPaucipodia 1 0 - - - - 0 0 0 0 0 - ? ? ? ? ? 0 1 ? ? 0 - - 0 0 - - 0 0 - 0 - 0 - 0 0 - - 0 - - - 0 0 0 1 1 0 0 0 0 - - - - - - ? - - - - 0 0 0 0 - 0 - - 0 0 - - 0 0 0 1 0 1 0 0 0 - 0 0 - - - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nMicrodictyon 1 0 - - - - 0 1 0 0 0 - ? ? ? ? ? 0 ? ? ? 0 - - 0 0 - - 0 0 - 0 - 0 - 0 0 - - 0 - - - 0 0 0 1 1 1 1 0 1 1 0 0 - 1 0 ? 1 - 0 0 0 0 0 0 - 0 - - 0 0 - - 0 0 0 1 0 1 ? 0 0 - 0 0 - - - 1 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nCardiodictyon 1 0 - - - - 0 1 1 0 [01] ? ? ? ? ? ? 0 ? ? ? 1 0 ? 0 ? ? ? 0 ? - ? ? 0 - 0 0 - - 0 - - - 0 0 0 1 1 1 1 0 1 1 0 0 - 1 0 ? 1 - 0 0 0 0 0 0 - 0 - - 0 0 - - 0 0 0 1 0 1 ? 0 0 - 0 0 - - - 1 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHallucigenia_sparsa 1 0 - - - - 0 1 1 0 0 - 1 1 0 0 1 0 1 0 1 1 0 0 0 0 - - 0 0 - [01] - 0 - 0 0 - - 0 - - - 0 0 0 0 - - - - 1 1 1 1 1 1 1 1 1 0 0 0 - 0 1 0 - 0 - - 0 0 - - 0 0 0 1 0 1 0 0 0 - 0 0 1 0 - 0 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHallucigenia_fortis 1 0 - - - - 0 1 1 0 0 - ? ? ? ? ? 0 ? ? ? 1 0 ? 0 0 - - 0 0 - [01] - 0 - 0 0 - - 0 - - - 0 0 0 1 1 1 1 ? 1 1 1 1 1 1 ? ? 1 0 0 0 0 0 1 0 - 0 - - 0 0 - - 0 0 0 1 0 1 ? 0 0 - 0 0 0 0 - ? 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHallucigenia_hongmeia 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 ? 1 1 1 1 1 1 0 ? 1 0 1 0 0 ? ? 0 - 0 - - 0 0 - - 0 0 0 1 0 0 - 0 0 - 0 0 ? ? - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nLuolishania 1 1 0 0 - - - ? 1 0 0 - ? ? ? ? ? 0 ? ? ? 1 0 0 0 1 0 - 0 0 - [01] - 0 - 0 0 - - 0 - - - 0 0 0 1 1 1 1 0 1 1 1 1 1 1 ? ? 2 0 1 1 1 0 1 0 - 0 - - 0 1 0 1 1 0 0 1 0 0 - 0 0 - 0 0 2 1 - 1 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nCollinsium 1 1 0 0 - - - 1 0 0 0 - ? ? ? ? ? ? ? ? ? 0 - - 0 1 0 - 0 0 - [01] - 0 - 0 0 - - 0 - - - 0 0 0 1 1 0 1 0 1 1 1 1 1 1 0 1 4 0 1 1 1 0 1 0 - 0 - - 0 1 0 1 0 0 0 1 0 0 - 0 0 - 0 0 3 1 - 1 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nCollins_monster_Burgess_Shale 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 0 - [01] - 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 1 1 1 1 ? ? ? ? ? ? ? ? 1 0 - 0 - - 0 1 0 1 ? ? ? ? ? ? ? ? 0 - 0 0 3 1 - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nCollins_monster_Emu_Bay 1 1 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - [01] - 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 1 1 1 1 ? ? 2 0 1 ? ? ? 1 0 - 0 - - 0 1 0 1 0 0 0 1 0 0 - 0 0 - 0 0 2 1 - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nAcinocrinus 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 0 - [01] - 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 1 1 1 1 ? ? 5 1 1 ? ? 0 1 0 - 0 - - 0 1 0 1 ? ? ? ? ? ? ? ? 0 - 0 0 2 1 - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nOrstenotubulus 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 1 1 1 1 ? ? ? ? ? 1 0 1 ? 1 ? ? 0 - 0 - - 0 0 - - 1 1 ? ? ? ? ? ? 0 - 0 0 ? ? - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nTritonychus 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? ? 1 ? ? ? ? ? ? ? ? ? ? ? ? 1 ? ? 0 - 0 - - 0 0 - - 1 1 0 1 ? 2 0 0 0 - 0 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 1 ? ?\\nCarbotubulus 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 0 - - - - ? ? ? ? ? ? ? ? ? ? ? ? - ? 1 0 - 0 - - 0 0 - - 0 0 ? ? ? ? ? ? 0 - 0 0 ? ? - 0 0 ? [1-] - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ?\\nAntennacanthopodia 1 0 - - - - 0 ? 0 0 ? ? ? ? ? ? ? ? ? ? ? 1 0 0 0 1 0 - 0 1 - 1 - 0 - 0 0 - - 0 - - - 0 0 0 1 ? ? ? ? 0 - - - - - - ? - - - - ? ? 0 0 - 0 - - 0 0 - - 1 ? 0 0 0 - - 0 0 - 0 0 - - - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHelenodora 1 0 - - - - 0 ? 0 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 1 0 - 0 ? - ? ? 1 - 0 0 - - 0 - - - 0 0 0 ? ? ? ? ? 0 - - - - - - ? - - - - 1 0 ? 0 - 0 - - 0 0 - - 1 ? 0 1 0 1 0 ? 0 - 0 0 ? ? - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nEuperipatoides_Onychophora 1 0 - - - - 0 0 0 0 1 1 1 0 - - 1 0 0 - - 1 0 0 0 1 0 - 0 1 - 2 0 1 - 0 0 - - 0 - - - 0 0 0 1 1 0 0 1 0 - - - - - - 1 - - - - 1 0 0 0 - 0 - - 0 0 - - 1 1 0 1 0 1 0 1 0 - 0 0 - - - 1 0 0 - - 0 0 1 1 2 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1\\nPlicatoperipatus_Onychophora 1 0 - - - - 0 0 0 0 1 1 1 0 - - 1 0 0 - - 1 0 0 0 1 0 - 0 1 - 2 1 1 - 0 0 - - 0 - - - 0 0 0 1 1 0 0 1 0 - - - - - - 1 - - - - 1 0 0 0 - 0 - - 0 0 - - 1 1 0 1 0 1 0 1 0 - 0 0 - - - 1 0 0 - - 0 0 1 1 2 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1\\nOoperipatellus_Onychophora 1 0 - - - - 0 0 0 0 1 1 1 0 - - 1 0 0 - - 1 0 0 0 1 0 - 0 1 - 2 1 1 - 0 0 - - 0 - - - 0 0 0 1 1 0 0 1 0 - - - - - - 1 - - - - 1 0 0 0 - 0 - - 0 0 - - 1 1 0 1 0 1 0 1 0 - 0 0 - - - 1 0 0 - - 0 0 1 1 2 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1\\nActinarctus_Heterotardigrada 1 1 0 0 - - - 0 0 1 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0 1 1 0 0 0 - 0 - 0 - 1 0 - - 0 - - - 0 0 0 0 - - - - 1 1 0 0 - 1 0 0 ? ? - - - 0 0 0 - 0 - - 0 0 - - 0 0 1 1 0 3 1 0 0 - 0 0 - - - 0 0 1 1 - 1 1 1 0 0 1 1 0 1 1 1 0 1 1 ? - 1 0 0 -\\nHalobiotus_Eutardigrada 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 1 0 1 0 0 1 0 0 0 1 1 0 0 0 - 0 - 0 - 2 0 - - 0 - - - 0 0 0 0 - - - - 1 0 - - - - - 0 ? ? - - - 0 0 0 - 0 - - 0 0 - - 0 0 1 1 1 1 1 0 0 - 0 0 - - - 0 0 1 1 - 1 1 1 0 0 1 1 0 1 1 1 0 1 1 1 - 1 0 0 -\\nSiberian_Orsten_tardigrade 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 ? ? ? ? ? ? [0-] ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 0 - - - - ? ? ? - - ? ? ? ? ? - - - ? 0 0 - 0 - - 0 0 - - 0 0 0 1 1 1 1 0 0 - 0 0 - - - 0 0 1 [12] - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nMegadictyon 1 0 - - - - 0 ? 0 0 ? ? ? 1 ? ? ? 0 ? ? ? 0 - - 0 1 0 - 0 0 - 0 - 0 - 0 0 - - 1 0 - 1 0 0 0 1 1 ? 0 ? 0 - - - - - - ? - - - - 0 1 0 0 - 0 - - 0 1 1 - 0 0 0 ? ? ? ? 0 0 - 0 0 - - - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nJianshanopodia 1 0 - - - - 0 0 0 0 0 - 0 1 ? ? 1 0 1 1 0 0 - - 0 1 0 - 0 0 - 0 - 0 - 0 ? ? ? 1 0 - ? 0 0 0 1 1 ? 1 0 0 - - - - - - ? - - - - 0 1 0 0 - 0 - - 0 1 1 - 0 0 0 ? ? ? ? 0 0 - 0 0 - - - 0 0 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHadranax 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 0 0 - 0 - ? 3 - - 0 1 ? 0 0 - 0 - - 0 0 - - 1 0 ? ? ? ? ? 0 0 - 0 0 - - - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nKerygmachela 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 ? 0 ? ? ? ? ? ? 0 1 0 - 0 0 - 0 - 0 - 0 1 0 - 1 0 - 1 0 0 0 1 1 0 1 0 1 1 0 0 - 0 - ? 3 - ? 0 1 1 0 1 0 0 1 0 0 0 - - 0 0 0 0 0 - - 0 0 0 0 0 - - - 0 0 1 0 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ?\\nPambdelurion 1 0 - - - - 0 0 0 0 1 0 0 1 0 0 ? 0 ? ? ? 0 - - 0 1 0 - 0 0 - 0 - 0 - 1 1 0 - 1 0 - ? 0 0 0 1 ? ? ? ? ? ? ? ? ? ? ? ? - - ? - ? 1 0 1 0 0 1 0 0 0 - - 0 0 0 0 0 - - 0 0 0 0 0 - - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 1 0 -\\nOpabinia 1 0 - - - - 0 0 0 0 2 1 0 ? ? ? ? 0 ? ? ? 1 1 1 0 1 0 - 0 0 - 0 - 0 - 1 1 1 0 1 0 - 1 1 0 0 0 - - - - 0 - - - - - - - - - - - - 1 0 1 0 0 1 1 0 0 - - 0 0 0 0 0 - - 0 0 0 0 0 - - - ? 1 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nAnomalocaris_canadensis 1 1 0 1 0 0 0 0 ? 0 1 1 0 1 1 1 1 0 ? ? ? 1 1 1 0 1 1 1 1 0 - 0 - 0 - 1 1 0 - 1 1 0 1 0 0 0 0 - - - - 0 - - - - - - - - - - - - 1 0 1 0 0 0 1 0 0 - - 0 0 0 0 0 - - 0 1 1 0 1 - - - 0 1 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 ? ? ?\\nPeytoia_nathorsti 1 1 0 1 1 0 0 0 ? 0 1 1 0 1 1 1 ? 0 ? ? ? 1 1 1 0 1 1 1 1 0 - 0 - 0 - 1 1 0 - 1 0 - 1 0 0 0 0 - - - - 0 - - - - - - - - - - - - 1 0 1 0 0 1 1 0 0 - - 0 0 0 0 0 - - 0 1 1 0 1 - - - 0 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHurdia_victoria 1 1 0 1 1 0 1 0 ? 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 0 1 1 1 1 0 - 0 - 0 - 1 ? ? ? 1 0 - 1 ? 0 0 0 - - - - 0 - - - - - - - - - - - - ? 0 1 0 0 1 1 0 0 - - 0 0 0 0 0 - - 0 1 0 0 1 - - - 0 0 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nAegirocassis_benmoulae 1 1 0 1 1 0 1 0 ? 0 ? 1 0 ? ? ? ? ? ? ? ? ? ? ? 0 1 1 1 1 0 - 0 - 0 - 1 ? ? ? 1 0 - 1 0 0 0 0 - - - - 0 - - - - - - - - - - - - ? 0 1 0 0 1 1 0 0 - - 0 0 0 0 0 - - 0 1 1 0 ? - - - 0 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nLyrarapax_unguispinus 1 1 0 1 0 0 0 0 ? 0 1 1 0 1 ? ? ? ? ? ? ? 1 1 1 0 1 1 1 1 0 - 0 - 0 - 1 1 0 - 1 0 - 1 0 0 0 0 - - - - 0 - - - - - - - - - - - - 0 0 1 0 0 0 1 0 0 - - 0 0 0 0 0 - - 0 ? 1 1 1 - - - 0 1 1 0 1 ? ? 1 0 0 1 1 ? ? ? ? ? ? ? ? ? 1 ? ? ?\\nSchinderhannes 1 ? ? ? ? ? ? 0 ? 0 1 1 0 1 ? ? ? ? ? ? ? 1 1 1 0 1 1 1 ? ? - 0 - 0 - 1 1 0 - 1 1 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 ? - - - 0 0 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nFuxianhuia 1 1 0 1 0 1 - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 0 - - - 1 1 1 1 1 - - - - 1 1 0 - - - - - - - - - - - - - - - - - - 0 - 1 1 1 - 0 0 - - - - - 0 0 0 - - 0 0 - 0 0 - - 1 - 0 1 0 1 ? ? 1 2 1 1 1 ? ? ? ? ? ? ? ? 1 1 0 0 -\\nChengjiangocaris 1 1 0 1 0 1 - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 0 - - - 1 1 1 1 1 - - - - 1 1 0 - - - - - - - - - - - - - - - - - - 0 - 1 1 1 - 0 0 - - - - - 0 0 0 - - 0 0 - 0 0 - - 1 - 0 1 0 1 ? 1 ? ? ? ? ? 0 ? 1 ? ? ? ? ? ? ? ? ? ?\\nLeanchoilia 1 1 1 0 - - - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 1 - - - 0 1 1 1 1 - - - - 1 1 ? - - - - - - - - - - - - 0 - - - - - 1 - 1 1 1 - 0 1 - - - - - 0 1 0 [02] ? 0 0 - 0 0 - - 0 - 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nAlalcomenaeus 1 1 1 0 - - - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 ? ? - 1 1 - - - 0 1 1 1 1 - - - - 1 1 ? - - - - - - - - - - - - 0 - - - - - 1 - 1 1 1 - 0 1 - - - - - 0 1 0 0 - 0 0 - 0 0 - - 0 - 0 0 - - ? 1 1 2 1 1 1 0 0 0 - - ? ? ? ? ? ? ? ?\\nMisszhouia_longicaudata 1 1 1 1 0 1 - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 0 - - - 0 1 1 1 1 - - - - 1 1 1 - - - - - - - - - - - - 0 - - - - - 1 - 1 2 1 - 0 1 - - - - - 0 1 0 0 - 0 0 - 0 0 - - 0 - 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 ? ? ?\\nKuamaia_lata 1 1 1 1 0 1 - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 0 - - - 0 1 1 1 1 - - - - 1 1 1 - - - - - - - - - - - - 0 - - - - - 1 - 1 2 1 - 0 1 - - - - - 0 1 0 2 1 0 0 - 0 0 - - 0 - 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 ? ? ?\\n;\\n\"  # Read with extended implied weighting WriteTntCharacters(Lobo.phy, pre = \"piwe=10;\", post = \"xpiwe=;\") #> [1] \"piwe=10;\\nxread 'Dataset written by `TreeTools::WriteTntCharacters()`'\\n115 48\\nTubiluchus_Priapulida 0 0 - - - - 0 0 0 0 0 - 0 1 0 0 1 1 1 1 0 0 - - - - - - - - - - - - - - - - - 0 - - - 0 0 0 1 - 1 0 0 0 - - - - - - 0 - - - - 1 0 0 - - - - - - - - - - - 0 - 0 - - 0 0 - 0 0 - - - - 0 0 - - 0 0 0 - - 0 0 - - 1 1 1 - - 0 0 0 1 1 1\\nCricocosmia 0 0 - - - - 0 0 0 0 0 - 0 1 0 0 1 1 1 ? 0 0 - - - - - - - - - - - - - - - - - 0 - - - 0 0 0 1 - 1 0 0 1 1 0 0 - 1 0 0 1 - 0 0 1 0 0 - - - - - - - - - - - 0 - 0 - - 0 0 - 0 0 - - - - 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ?\\nAysheaia 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 ? 0 ? ? ? 0 - - 0 1 0 - 0 0 - 0 - 0 - 0 0 - - 1 0 - 1 0 0 0 1 1 1 0 0 0 - - - - - - 0 - - - - 1 0 0 0 - 0 - - 0 1 0 0 0 0 0 1 0 4 0 0 0 - 0 0 - - - 0 0 1 1 - 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ?\\nSiberion 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 ? 0 ? ? ? 0 - - 0 1 0 - 0 0 - 0 - 0 - 0 1 0 - ? ? ? ? 0 0 0 1 1 ? 0 0 0 - - - - - - ? - - - - 1 ? 0 0 - 0 - - 0 ? ? ? 0 0 ? ? ? ? ? ? 0 - 0 0 - - - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nOnychodictyon_ferox 1 0 - - - - 0 0 0 0 0 - 0 ? ? ? ? 0 ? ? ? 1 0 0 0 1 0 - 0 0 - 0 - 0 - 0 0 - - 1 1 1 0 0 0 0 1 1 1 1 0 1 1 0 1 0 1 0 ? 1 - 0 0 1 0 0 0 - 0 - - 0 1 1 - 0 0 0 1 0 1 1 0 0 - 0 0 - - - 0 0 1 1 - 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nOnychodictyon_gracilis 1 0 - - - - 0 ? ? 0 0 - 0 ? ? ? ? 0 ? ? ? ? ? ? 0 ? ? ? 0 ? - ? - 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 0 ? 0 1 1 0 ? ? 1 ? ? 1 - 0 0 1 0 ? 0 - 0 - - 0 ? ? ? 0 0 0 1 0 1 ? 0 0 - 0 0 ? ? - 1 0 1 1 - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nDiania 1 0 - - - - 0 0 0 0 0 - ? ? ? ? ? 0 ? ? ? 0 - - 0 0 - - 0 0 - 0 - 0 - 0 0 - - 0 - - - 0 0 0 1 1 0 1 0 1 1 0 0 - 0 ? ? 0 - 0 0 1 0 0 0 - 0 - - 0 1 0 0 0 0 0 ? ? - - 0 0 - 0 0 - - - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nXenusion 1 0 - - - - 0 ? 0 0 ? ? ? ? ? ? ? ? ? ? ? 0 - - 0 0 - - 0 0 - 0 - 0 - 0 0 - - ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 0 0 - 0 ? ? 1 - 0 0 1 ? 0 0 - 0 - - 0 1 ? ? ? ? ? ? ? ? ? ? 0 - 0 0 - - - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nPaucipodia 1 0 - - - - 0 0 0 0 0 - ? ? ? ? ? 0 1 ? ? 0 - - 0 0 - - 0 0 - 0 - 0 - 0 0 - - 0 - - - 0 0 0 1 1 0 0 0 0 - - - - - - ? - - - - 0 0 0 0 - 0 - - 0 0 - - 0 0 0 1 0 1 0 0 0 - 0 0 - - - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nMicrodictyon 1 0 - - - - 0 1 0 0 0 - ? ? ? ? ? 0 ? ? ? 0 - - 0 0 - - 0 0 - 0 - 0 - 0 0 - - 0 - - - 0 0 0 1 1 1 1 0 1 1 0 0 - 1 0 ? 1 - 0 0 0 0 0 0 - 0 - - 0 0 - - 0 0 0 1 0 1 ? 0 0 - 0 0 - - - 1 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nCardiodictyon 1 0 - - - - 0 1 1 0 [01] ? ? ? ? ? ? 0 ? ? ? 1 0 ? 0 ? ? ? 0 ? - ? ? 0 - 0 0 - - 0 - - - 0 0 0 1 1 1 1 0 1 1 0 0 - 1 0 ? 1 - 0 0 0 0 0 0 - 0 - - 0 0 - - 0 0 0 1 0 1 ? 0 0 - 0 0 - - - 1 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHallucigenia_sparsa 1 0 - - - - 0 1 1 0 0 - 1 1 0 0 1 0 1 0 1 1 0 0 0 0 - - 0 0 - [01] - 0 - 0 0 - - 0 - - - 0 0 0 0 - - - - 1 1 1 1 1 1 1 1 1 0 0 0 - 0 1 0 - 0 - - 0 0 - - 0 0 0 1 0 1 0 0 0 - 0 0 1 0 - 0 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHallucigenia_fortis 1 0 - - - - 0 1 1 0 0 - ? ? ? ? ? 0 ? ? ? 1 0 ? 0 0 - - 0 0 - [01] - 0 - 0 0 - - 0 - - - 0 0 0 1 1 1 1 ? 1 1 1 1 1 1 ? ? 1 0 0 0 0 0 1 0 - 0 - - 0 0 - - 0 0 0 1 0 1 ? 0 0 - 0 0 0 0 - ? 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHallucigenia_hongmeia 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 ? 1 1 1 1 1 1 0 ? 1 0 1 0 0 ? ? 0 - 0 - - 0 0 - - 0 0 0 1 0 0 - 0 0 - 0 0 ? ? - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nLuolishania 1 1 0 0 - - - ? 1 0 0 - ? ? ? ? ? 0 ? ? ? 1 0 0 0 1 0 - 0 0 - [01] - 0 - 0 0 - - 0 - - - 0 0 0 1 1 1 1 0 1 1 1 1 1 1 ? ? 2 0 1 1 1 0 1 0 - 0 - - 0 1 0 1 1 0 0 1 0 0 - 0 0 - 0 0 2 1 - 1 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nCollinsium 1 1 0 0 - - - 1 0 0 0 - ? ? ? ? ? ? ? ? ? 0 - - 0 1 0 - 0 0 - [01] - 0 - 0 0 - - 0 - - - 0 0 0 1 1 0 1 0 1 1 1 1 1 1 0 1 4 0 1 1 1 0 1 0 - 0 - - 0 1 0 1 0 0 0 1 0 0 - 0 0 - 0 0 3 1 - 1 0 0 - - 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nCollins_monster_Burgess_Shale 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 0 - [01] - 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 1 1 1 1 ? ? ? ? ? ? ? ? 1 0 - 0 - - 0 1 0 1 ? ? ? ? ? ? ? ? 0 - 0 0 3 1 - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nCollins_monster_Emu_Bay 1 1 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - [01] - 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 1 1 1 1 ? ? 2 0 1 ? ? ? 1 0 - 0 - - 0 1 0 1 0 0 0 1 0 0 - 0 0 - 0 0 2 1 - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nAcinocrinus 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 0 - [01] - 0 - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 1 1 1 1 ? ? 5 1 1 ? ? 0 1 0 - 0 - - 0 1 0 1 ? ? ? ? ? ? ? ? 0 - 0 0 2 1 - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nOrstenotubulus 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 1 1 1 1 ? ? ? ? ? 1 0 1 ? 1 ? ? 0 - 0 - - 0 0 - - 1 1 ? ? ? ? ? ? 0 - 0 0 ? ? - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nTritonychus 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? ? 1 ? ? ? ? ? ? ? ? ? ? ? ? 1 ? ? 0 - 0 - - 0 0 - - 1 1 0 1 ? 2 0 0 0 - 0 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 1 ? ?\\nCarbotubulus 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 0 - - - - ? ? ? ? ? ? ? ? ? ? ? ? - ? 1 0 - 0 - - 0 0 - - 0 0 ? ? ? ? ? ? 0 - 0 0 ? ? - 0 0 ? [1-] - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ?\\nAntennacanthopodia 1 0 - - - - 0 ? 0 0 ? ? ? ? ? ? ? ? ? ? ? 1 0 0 0 1 0 - 0 1 - 1 - 0 - 0 0 - - 0 - - - 0 0 0 1 ? ? ? ? 0 - - - - - - ? - - - - ? ? 0 0 - 0 - - 0 0 - - 1 ? 0 0 0 - - 0 0 - 0 0 - - - 1 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHelenodora 1 0 - - - - 0 ? 0 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 1 0 - 0 ? - ? ? 1 - 0 0 - - 0 - - - 0 0 0 ? ? ? ? ? 0 - - - - - - ? - - - - 1 0 ? 0 - 0 - - 0 0 - - 1 ? 0 1 0 1 0 ? 0 - 0 0 ? ? - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nEuperipatoides_Onychophora 1 0 - - - - 0 0 0 0 1 1 1 0 - - 1 0 0 - - 1 0 0 0 1 0 - 0 1 - 2 0 1 - 0 0 - - 0 - - - 0 0 0 1 1 0 0 1 0 - - - - - - 1 - - - - 1 0 0 0 - 0 - - 0 0 - - 1 1 0 1 0 1 0 1 0 - 0 0 - - - 1 0 0 - - 0 0 1 1 2 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1\\nPlicatoperipatus_Onychophora 1 0 - - - - 0 0 0 0 1 1 1 0 - - 1 0 0 - - 1 0 0 0 1 0 - 0 1 - 2 1 1 - 0 0 - - 0 - - - 0 0 0 1 1 0 0 1 0 - - - - - - 1 - - - - 1 0 0 0 - 0 - - 0 0 - - 1 1 0 1 0 1 0 1 0 - 0 0 - - - 1 0 0 - - 0 0 1 1 2 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1\\nOoperipatellus_Onychophora 1 0 - - - - 0 0 0 0 1 1 1 0 - - 1 0 0 - - 1 0 0 0 1 0 - 0 1 - 2 1 1 - 0 0 - - 0 - - - 0 0 0 1 1 0 0 1 0 - - - - - - 1 - - - - 1 0 0 0 - 0 - - 0 0 - - 1 1 0 1 0 1 0 1 0 - 0 0 - - - 1 0 0 - - 0 0 1 1 2 1 0 1 1 1 1 1 0 1 0 1 0 1 1 1\\nActinarctus_Heterotardigrada 1 1 0 0 - - - 0 0 1 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0 1 1 0 0 0 - 0 - 0 - 1 0 - - 0 - - - 0 0 0 0 - - - - 1 1 0 0 - 1 0 0 ? ? - - - 0 0 0 - 0 - - 0 0 - - 0 0 1 1 0 3 1 0 0 - 0 0 - - - 0 0 1 1 - 1 1 1 0 0 1 1 0 1 1 1 0 1 1 ? - 1 0 0 -\\nHalobiotus_Eutardigrada 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 1 0 1 0 0 1 0 0 0 1 1 0 0 0 - 0 - 0 - 2 0 - - 0 - - - 0 0 0 0 - - - - 1 0 - - - - - 0 ? ? - - - 0 0 0 - 0 - - 0 0 - - 0 0 1 1 1 1 1 0 0 - 0 0 - - - 0 0 1 1 - 1 1 1 0 0 1 1 0 1 1 1 0 1 1 1 - 1 0 0 -\\nSiberian_Orsten_tardigrade 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 ? ? ? ? ? ? [0-] ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 0 - - - - ? ? ? - - ? ? ? ? ? - - - ? 0 0 - 0 - - 0 0 - - 0 0 0 1 1 1 1 0 0 - 0 0 - - - 0 0 1 [12] - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nMegadictyon 1 0 - - - - 0 ? 0 0 ? ? ? 1 ? ? ? 0 ? ? ? 0 - - 0 1 0 - 0 0 - 0 - 0 - 0 0 - - 1 0 - 1 0 0 0 1 1 ? 0 ? 0 - - - - - - ? - - - - 0 1 0 0 - 0 - - 0 1 1 - 0 0 0 ? ? ? ? 0 0 - 0 0 - - - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nJianshanopodia 1 0 - - - - 0 0 0 0 0 - 0 1 ? ? 1 0 1 1 0 0 - - 0 1 0 - 0 0 - 0 - 0 - 0 ? ? ? 1 0 - ? 0 0 0 1 1 ? 1 0 0 - - - - - - ? - - - - 0 1 0 0 - 0 - - 0 1 1 - 0 0 0 ? ? ? ? 0 0 - 0 0 - - - 0 0 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHadranax 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ? 0 ? - ? ? ? - ? ? ? ? ? ? ? ? 0 0 0 1 1 ? 1 0 1 1 0 0 - 0 - ? 3 - - 0 1 ? 0 0 - 0 - - 0 0 - - 1 0 ? ? ? ? ? 0 0 - 0 0 - - - ? 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nKerygmachela 1 0 - - - - 0 0 0 0 0 - 0 1 0 0 ? 0 ? ? ? ? ? ? 0 1 0 - 0 0 - 0 - 0 - 0 1 0 - 1 0 - 1 0 0 0 1 1 0 1 0 1 1 0 0 - 0 - ? 3 - ? 0 1 1 0 1 0 0 1 0 0 0 - - 0 0 0 0 0 - - 0 0 0 0 0 - - - 0 0 1 0 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0 ? ? ?\\nPambdelurion 1 0 - - - - 0 0 0 0 1 0 0 1 0 0 ? 0 ? ? ? 0 - - 0 1 0 - 0 0 - 0 - 0 - 1 1 0 - 1 0 - ? 0 0 0 1 ? ? ? ? ? ? ? ? ? ? ? ? - - ? - ? 1 0 1 0 0 1 0 0 0 - - 0 0 0 0 0 - - 0 0 0 0 0 - - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 1 0 -\\nOpabinia 1 0 - - - - 0 0 0 0 2 1 0 ? ? ? ? 0 ? ? ? 1 1 1 0 1 0 - 0 0 - 0 - 0 - 1 1 1 0 1 0 - 1 1 0 0 0 - - - - 0 - - - - - - - - - - - - 1 0 1 0 0 1 1 0 0 - - 0 0 0 0 0 - - 0 0 0 0 0 - - - ? 1 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nAnomalocaris_canadensis 1 1 0 1 0 0 0 0 ? 0 1 1 0 1 1 1 1 0 ? ? ? 1 1 1 0 1 1 1 1 0 - 0 - 0 - 1 1 0 - 1 1 0 1 0 0 0 0 - - - - 0 - - - - - - - - - - - - 1 0 1 0 0 0 1 0 0 - - 0 0 0 0 0 - - 0 1 1 0 1 - - - 0 1 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 ? ? ?\\nPeytoia_nathorsti 1 1 0 1 1 0 0 0 ? 0 1 1 0 1 1 1 ? 0 ? ? ? 1 1 1 0 1 1 1 1 0 - 0 - 0 - 1 1 0 - 1 0 - 1 0 0 0 0 - - - - 0 - - - - - - - - - - - - 1 0 1 0 0 1 1 0 0 - - 0 0 0 0 0 - - 0 1 1 0 1 - - - 0 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nHurdia_victoria 1 1 0 1 1 0 1 0 ? 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 0 1 1 1 1 0 - 0 - 0 - 1 ? ? ? 1 0 - 1 ? 0 0 0 - - - - 0 - - - - - - - - - - - - ? 0 1 0 0 1 1 0 0 - - 0 0 0 0 0 - - 0 1 0 0 1 - - - 0 0 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nAegirocassis_benmoulae 1 1 0 1 1 0 1 0 ? 0 ? 1 0 ? ? ? ? ? ? ? ? ? ? ? 0 1 1 1 1 0 - 0 - 0 - 1 ? ? ? 1 0 - 1 0 0 0 0 - - - - 0 - - - - - - - - - - - - ? 0 1 0 0 1 1 0 0 - - 0 0 0 0 0 - - 0 1 1 0 ? - - - 0 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nLyrarapax_unguispinus 1 1 0 1 0 0 0 0 ? 0 1 1 0 1 ? ? ? ? ? ? ? 1 1 1 0 1 1 1 1 0 - 0 - 0 - 1 1 0 - 1 0 - 1 0 0 0 0 - - - - 0 - - - - - - - - - - - - 0 0 1 0 0 0 1 0 0 - - 0 0 0 0 0 - - 0 ? 1 1 1 - - - 0 1 1 0 1 ? ? 1 0 0 1 1 ? ? ? ? ? ? ? ? ? 1 ? ? ?\\nSchinderhannes 1 ? ? ? ? ? ? 0 ? 0 1 1 0 1 ? ? ? ? ? ? ? 1 1 1 0 1 1 1 ? ? - 0 - 0 - 1 1 0 - 1 1 0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 ? - - - 0 0 1 0 1 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nFuxianhuia 1 1 0 1 0 1 - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 0 - - - 1 1 1 1 1 - - - - 1 1 0 - - - - - - - - - - - - - - - - - - 0 - 1 1 1 - 0 0 - - - - - 0 0 0 - - 0 0 - 0 0 - - 1 - 0 1 0 1 ? ? 1 2 1 1 1 ? ? ? ? ? ? ? ? 1 1 0 0 -\\nChengjiangocaris 1 1 0 1 0 1 - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 0 - - - 1 1 1 1 1 - - - - 1 1 0 - - - - - - - - - - - - - - - - - - 0 - 1 1 1 - 0 0 - - - - - 0 0 0 - - 0 0 - 0 0 - - 1 - 0 1 0 1 ? 1 ? ? ? ? ? 0 ? 1 ? ? ? ? ? ? ? ? ? ?\\nLeanchoilia 1 1 1 0 - - - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 1 - - - 0 1 1 1 1 - - - - 1 1 ? - - - - - - - - - - - - 0 - - - - - 1 - 1 1 1 - 0 1 - - - - - 0 1 0 [02] ? 0 0 - 0 0 - - 0 - 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\\nAlalcomenaeus 1 1 1 0 - - - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 ? ? - 1 1 - - - 0 1 1 1 1 - - - - 1 1 ? - - - - - - - - - - - - 0 - - - - - 1 - 1 1 1 - 0 1 - - - - - 0 1 0 0 - 0 0 - 0 0 - - 0 - 0 0 - - ? 1 1 2 1 1 1 0 0 0 - - ? ? ? ? ? ? ? ?\\nMisszhouia_longicaudata 1 1 1 1 0 1 - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 0 - - - 0 1 1 1 1 - - - - 1 1 1 - - - - - - - - - - - - 0 - - - - - 1 - 1 2 1 - 0 1 - - - - - 0 1 0 0 - 0 0 - 0 0 - - 0 - 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 ? ? ?\\nKuamaia_lata 1 1 1 1 0 1 - 0 - - 2 1 0 0 - - ? 0 ? ? ? 1 1 1 1 1 1 0 - 1 0 - - - 0 1 1 1 1 - - - - 1 1 1 - - - - - - - - - - - - 0 - - - - - 1 - 1 2 1 - 0 1 - - - - - 0 1 0 2 1 0 0 - 0 0 - - 0 - 0 0 - - ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 1 ? ? ?\\n;\\nxpiwe=;\"  # Write to a file with: # WriteTntCharacters(Lobo.phy, \"example_file.tnt\")"},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.Newick.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a phylogenetic tree in Newick format — as.Newick","title":"Write a phylogenetic tree in Newick format — as.Newick","text":".Newick() creates character string representation phylogenetic tree, Newick format, using R's internal tip numbering. Use RenumberTips() ensure internal numbering follows order expect.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.Newick.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a phylogenetic tree in Newick format — as.Newick","text":"","code":"as.Newick(x)  # S3 method for class 'phylo' as.Newick(x)  # S3 method for class 'list' as.Newick(x)  # S3 method for class 'multiPhylo' as.Newick(x)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.Newick.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a phylogenetic tree in Newick format — as.Newick","text":"x Object convert Newick format. See Usage section supported classes.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.Newick.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write a phylogenetic tree in Newick format — as.Newick","text":".Newick() returns character string representing tree Newick format.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.Newick.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Write a phylogenetic tree in Newick format — as.Newick","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.Newick.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write a phylogenetic tree in Newick format — as.Newick","text":"","code":"trees <- list(BalancedTree(1:8), PectinateTree(8:1)) trees <- lapply(trees, RenumberTips, 1:8) as.Newick(trees) #> [1] \"(((0,1),(2,3)),((4,5),(6,7)));\" \"(((((((0,1),2),3),4),5),6),7);\""},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.multiPhylo.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert object to multiPhylo class — as.multiPhylo","title":"Convert object to multiPhylo class — as.multiPhylo","text":"Converts representations phylogenetic trees object \"ape\" class multiPhylo.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.multiPhylo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert object to multiPhylo class — as.multiPhylo","text":"","code":"as.multiPhylo(x)  # S3 method for class 'phylo' as.multiPhylo(x)  # S3 method for class 'list' as.multiPhylo(x)  # S3 method for class 'phyDat' as.multiPhylo(x)  # S3 method for class 'Splits' as.multiPhylo(x)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.multiPhylo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert object to multiPhylo class — as.multiPhylo","text":"x Object converted","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.multiPhylo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert object to multiPhylo class — as.multiPhylo","text":".multiPhylo returns object class multiPhylo .multiPhylo.phyDat() returns list trees, corresponding partitions implied non-ambiguous character x.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/as.multiPhylo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert object to multiPhylo class — as.multiPhylo","text":"","code":"as.multiPhylo(BalancedTree(8)) #> 1 phylogenetic tree as.multiPhylo(list(BalancedTree(8), PectinateTree(8))) #> 2 phylogenetic trees data(\"Lobo\") as.multiPhylo(Lobo.phy) #> 115 phylogenetic trees"},{"path":"https://ms609.github.io/TreeTools/dev/reference/brewer.html","id":null,"dir":"Reference","previous_headings":"","what":"Brewer palettes — brewer","title":"Brewer palettes — brewer","text":"list eleven Brewer palettes containing one eleven colours readily distinguished colourblind viewers, followed twelfth 12-colour palette adapted colour blindness.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/brewer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Brewer palettes — brewer","text":"","code":"brewer"},{"path":"https://ms609.github.io/TreeTools/dev/reference/brewer.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Brewer palettes — brewer","text":"object class list length 12.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/brewer.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Brewer palettes — brewer","text":"ColourBrewer2.org Martin Krzywinski","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/brewer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Brewer palettes — brewer","text":"","code":"data(\"brewer\", package = \"TreeTools\") plot(0, type = \"n\", xlim = c(1, 12), ylim = c(12, 1),      xlab = \"Colour\", ylab=\"Palette\") for (i in seq_along(brewer)) text(seq_len(i), i, col = brewer[[i]])"},{"path":"https://ms609.github.io/TreeTools/dev/reference/dot-RandomParent.html","id":null,"dir":"Reference","previous_headings":"","what":"Random parent vector — .RandomParent","title":"Random parent vector — .RandomParent","text":"Random parent vector","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/dot-RandomParent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random parent vector — .RandomParent","text":"","code":".RandomParent(n, seed = sample.int(2147483647L, 1L))"},{"path":"https://ms609.github.io/TreeTools/dev/reference/dot-RandomParent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random parent vector — .RandomParent","text":"n Integer specifying number leaves. seed (Optional) Integer seed Mersenne Twister random number generator C++.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/dot-RandomParent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random parent vector — .RandomParent","text":"Integer vector corresponding \"parent\" entry tree[[\"edge\"]], \"child\" entry, .e. column 2, numbered sequentially 1:n.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/dot-RandomParent.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random parent vector — .RandomParent","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/doubleFactorials.html","id":null,"dir":"Reference","previous_headings":"","what":"Double factorials — doubleFactorials","title":"Double factorials — doubleFactorials","text":"vector pre-calculated values double factorials 300!!, logarithms double factorials 50 000!!.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/doubleFactorials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Double factorials — doubleFactorials","text":"","code":"doubleFactorials"},{"path":"https://ms609.github.io/TreeTools/dev/reference/doubleFactorials.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Double factorials — doubleFactorials","text":"object class numeric length 300.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/doubleFactorials.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Double factorials — doubleFactorials","text":"301!! large store integer; use logDoubleFactorials instead.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/edge_to_splits.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficiently convert edge matrix to splits — edge_to_splits","title":"Efficiently convert edge matrix to splits — edge_to_splits","text":"Wrapper internal C++ function maximum efficiency. Improper input may crash R.  Behaviour guaranteed. advisable contact package maintainers relying function.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/edge_to_splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficiently convert edge matrix to splits — edge_to_splits","text":"","code":"edge_to_splits(   edge,   edgeOrder,   tipLabels = NULL,   asSplits = TRUE,   nTip = NTip(edge),   ... )"},{"path":"https://ms609.github.io/TreeTools/dev/reference/edge_to_splits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficiently convert edge matrix to splits — edge_to_splits","text":"edge matrix two columns, row listing parent child node edge phylogenetic tree.  Property edge objects class phylo. edgeOrder Integer vector edge[edgeOrder, ] returns postorder ordering edges. tipLabels Character vector specifying sequence order tip labels.  Label order must (currently) match combine compare separate Splits objects. asSplits Logical specifying whether return Splits object, unannotated two-dimensional array (useful performance paramount). nTip Integer specifying number leaves tree. ... Presently unused.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/edge_to_splits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficiently convert edge matrix to splits — edge_to_splits","text":"edge_to_splits() uses return format .Splits().","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/is.TreeNumber.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object a TreeNumber object? — is.TreeNumber","title":"Is an object a TreeNumber object? — is.TreeNumber","text":"object TreeNumber object?","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/is.TreeNumber.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object a TreeNumber object? — is.TreeNumber","text":"","code":"is.TreeNumber(x)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/is.TreeNumber.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object a TreeNumber object? — is.TreeNumber","text":"x R object.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/is.TreeNumber.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is an object a TreeNumber object? — is.TreeNumber","text":".TreeNumber() returns logical vector length one specifying whether x inherits class \"TreeNumber\".","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/is.TreeNumber.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Is an object a TreeNumber object? — is.TreeNumber","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/is.TreeNumber.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is an object a TreeNumber object? — is.TreeNumber","text":"","code":"is.TreeNumber(FALSE) # FALSE  #> [1] FALSE is.TreeNumber(as.TreeNumber(BalancedTree(5))) # TRUE #> [1] TRUE"},{"path":"https://ms609.github.io/TreeTools/dev/reference/logDoubleFactorials.html","id":null,"dir":"Reference","previous_headings":"","what":"Natural logarithms of double factorials — logDoubleFactorials","title":"Natural logarithms of double factorials — logDoubleFactorials","text":"logDoubleFactorials numeric vector pre-calculated values double factorials 50 000!!.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/logDoubleFactorials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Natural logarithms of double factorials — logDoubleFactorials","text":"","code":"logDoubleFactorials"},{"path":"https://ms609.github.io/TreeTools/dev/reference/logDoubleFactorials.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Natural logarithms of double factorials — logDoubleFactorials","text":"object class numeric length 50000.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.Splits.html","id":null,"dir":"Reference","previous_headings":"","what":"Split matching — match,Splits,Splits-method","title":"Split matching — match,Splits,Splits-method","text":"match() returns vector positions (first) matches splits first argument second. %% intuitive interface binary operator, returns logical vector indicating whether match split left operand.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.Splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split matching — match,Splits,Splits-method","text":"","code":"# S4 method for class 'Splits,Splits' match(x, table, nomatch = NA_integer_, incomparables = NULL)  in.Splits(x, table)  match(x, table, nomatch = NA_integer_, incomparables = NULL)  # S4 method for class 'Splits,Splits' x %in% table"},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.Splits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split matching — match,Splits,Splits-method","text":"x, table Object class Splits. nomatch Integer value used place NA case match found. incomparables Ignored. (Included consistency generic.)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.Splits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split matching — match,Splits,Splits-method","text":"match() returns integer vector specifying position table matches element x, nomatch match found.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.Splits.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Split matching — match,Splits,Splits-method","text":".Splits() alias %%, included backwards compatibility. deprecated removed future release.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.Splits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split matching — match,Splits,Splits-method","text":"","code":"splits1 <- as.Splits(BalancedTree(7)) splits2 <- as.Splits(PectinateTree(7))  match(splits1, splits2) #> [1]  3  1 NA NA"},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.multiPhylo.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree matching — match,phylo,phylo-method","title":"Tree matching — match,phylo,phylo-method","text":"match() returns vector positions (first) matches trees first argument second. %% intuitive interface binary operator, returns logical vector indicating whether match tree left operand.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.multiPhylo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree matching — match,phylo,phylo-method","text":"","code":"# S4 method for class 'phylo,phylo' match(x, table, nomatch = NA_integer_, incomparables = NULL)  # S4 method for class 'multiPhylo,phylo' match(x, table, nomatch = NA_integer_, incomparables = NULL)  # S4 method for class 'phylo,multiPhylo' match(x, table, nomatch = NA_integer_, incomparables = NULL)  # S4 method for class 'multiPhylo,multiPhylo' match(x, table, nomatch = NA_integer_, incomparables = NULL)  # S4 method for class 'multiPhylo,multiPhylo' x %in% table  # S4 method for class 'multiPhylo,phylo' x %in% table  # S4 method for class 'phylo,multiPhylo' x %in% table  # S4 method for class 'phylo,phylo' x %in% table"},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.multiPhylo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree matching — match,phylo,phylo-method","text":"x, table Object class phylo multiPhylo. nomatch Integer value used place NA case match found. incomparables Ignored. (Included consistency generic.)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.multiPhylo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree matching — match,phylo,phylo-method","text":"match() returns integer vector specifying position table matches element x, nomatch match found.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/match.multiPhylo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree matching — match,phylo,phylo-method","text":"","code":"tree1 <- BalancedTree(7) trees <- c(PectinateTree(7), BalancedTree(7))  match(tree1, trees) #> [1] 2"},{"path":"https://ms609.github.io/TreeTools/dev/reference/nRootedShapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of rooted / unrooted tree shapes — nRootedShapes","title":"Number of rooted / unrooted tree shapes — nRootedShapes","text":"nRootedShapes nUnrootedShapes give number (un)rooted binary trees n unlabelled leaves.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/nRootedShapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of rooted / unrooted tree shapes — nRootedShapes","text":"","code":"nRootedShapes  nUnrootedShapes"},{"path":"https://ms609.github.io/TreeTools/dev/reference/nRootedShapes.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Number of rooted / unrooted tree shapes — nRootedShapes","text":"object class integer64 length 55. object class integer64 length 60.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/nRootedShapes.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Number of rooted / unrooted tree shapes — nRootedShapes","text":"nRootedShapes corresponds Wedderburn-Etherington numbers, OEIS A001190 nUnrootedShapes OEIS A000672","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/print.TreeNumber.html","id":null,"dir":"Reference","previous_headings":"","what":"Print TreeNumber object — print.TreeNumber","title":"Print TreeNumber object — print.TreeNumber","text":"S3 method objects class TreeNumber.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/print.TreeNumber.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print TreeNumber object — print.TreeNumber","text":"","code":"# S3 method for class 'TreeNumber' print(x, ...)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/print.TreeNumber.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print TreeNumber object — print.TreeNumber","text":"x Object class TreeNumber. ... Additional arguments consistency S3 method (unused).","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/root_on_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper for internal C function root_on_node() — root_on_node","title":"Wrapper for internal C function root_on_node() — root_on_node","text":"Direct entry point root_on_node(); recommended expert use . RootTree() checks input properly formatted recommended general use.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/root_on_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper for internal C function root_on_node() — root_on_node","text":"","code":"root_on_node(phy, outgroup)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/root_on_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper for internal C function root_on_node() — root_on_node","text":"phy Minimally, named list entries edge Nnode, format equivalent entries tree class phylo. edge.length also considered supplied. outgroup Integer specifying index leaf node set outgroup.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/root_on_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrapper for internal C function root_on_node() — root_on_node","text":"root_on_node() returns phy rooted specified node.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/root_on_node.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Wrapper for internal C function root_on_node() — root_on_node","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/sapply64.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function that returns 64-bit integers over a list or vector — sapply64","title":"Apply a function that returns 64-bit integers over a list or vector — sapply64","text":"Wrappers members lapply() family intended use function FUN returns vector integer64 objects. vapply(), sapply() replicate() drop integer64 class, resulting vector numerics require conversion back 64-bit integers.  functions restore missing class attribute.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/sapply64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function that returns 64-bit integers over a list or vector — sapply64","text":"","code":"sapply64(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)  vapply64(X, FUN, FUN.LEN = 1, ...)  replicate64(n, expr, simplify = \"array\")"},{"path":"https://ms609.github.io/TreeTools/dev/reference/sapply64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function that returns 64-bit integers over a list or vector — sapply64","text":"X vector (atomic list) expression     object.  objects (including classed objects) coerced     base::.list. FUN function applied element X:     see ‘Details’.  case functions like     +, %*%, function name must backquoted quoted. ... optional arguments FUN. simplify logical character string; result     simplified vector, matrix higher dimensional array     possible?  sapply must named abbreviated.     default value, TRUE, returns vector matrix appropriate,     whereas simplify = \"array\" result may     array “rank”     (\\(=\\)length(dim(.))) one higher result     FUN(X[[]]). USE.NAMES logical; TRUE X character,     use X names result unless names     already.  Since argument follows ... name     abbreviated. FUN.LEN Integer specifying length output FUN. n integer: number replications. expr expression (language object, usually call)     evaluate repeatedly.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/sapply64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a function that returns 64-bit integers over a list or vector — sapply64","text":"details underlying functions, see base::lapply().","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/sapply64.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply a function that returns 64-bit integers over a list or vector — sapply64","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/sapply64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function that returns 64-bit integers over a list or vector — sapply64","text":"","code":"sapply64(as.phylo(1:6, 6), as.TreeNumber) #> integer64 #> [1] 1 2 3 4 5 6 vapply64(as.phylo(1:6, 6), as.TreeNumber, 1) #> integer64 #> [1] 1 2 3 4 5 6 set.seed(0) replicate64(6, as.TreeNumber(RandomTree(6))) #> integer64 #> [1] 91  45  102 24  92  48"},{"path":"https://ms609.github.io/TreeTools/dev/reference/sort.multiPhylo.html","id":null,"dir":"Reference","previous_headings":"","what":"Sort a list of phylogenetic trees — sort.multiPhylo","title":"Sort a list of phylogenetic trees — sort.multiPhylo","text":"Trees sorted mixed base representation, treating leaves order labels (.e. alphabetically, leaves labelled text).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/sort.multiPhylo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sort a list of phylogenetic trees — sort.multiPhylo","text":"","code":"# S3 method for class 'multiPhylo' sort(x, decreasing = FALSE, na.last = NA, ...)  # S3 method for class 'phylo' e1 == e2  # S3 method for class 'phylo' e1 < e2  # S3 method for class 'phylo' e1 > e2  # S3 method for class 'MixedBase' e1 == e2  # S3 method for class 'MixedBase' e1 < e2  # S3 method for class 'MixedBase' e1 > e2"},{"path":"https://ms609.github.io/TreeTools/dev/reference/sort.multiPhylo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sort a list of phylogenetic trees — sort.multiPhylo","text":"x, decreasing, na.last, ... sort(). e1, e2 Objects compared.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/reference/sort.multiPhylo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sort a list of phylogenetic trees — sort.multiPhylo","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/sort.multiPhylo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sort a list of phylogenetic trees — sort.multiPhylo","text":"","code":"sort(as.phylo(5:0, 7)) #> 6 phylogenetic trees"},{"path":"https://ms609.github.io/TreeTools/dev/reference/xor.html","id":null,"dir":"Reference","previous_headings":"","what":"Exclusive OR operation — xor","title":"Exclusive OR operation — xor","text":"Exclusive operation","code":""},{"path":"https://ms609.github.io/TreeTools/dev/reference/xor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exclusive OR operation — xor","text":"","code":"xor(x, y)  # S4 method for class 'Splits,Splits' xor(x, y)"},{"path":"https://ms609.github.io/TreeTools/dev/reference/xor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exclusive OR operation — xor","text":"x, y Objects compared.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-11509009-development","dir":"Changelog","previous_headings":"","what":"TreeTools 1.15.0.9009 (development)","title":"TreeTools 1.15.0.9009 (development)","text":"Preorder() gains topologyOnly argument.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-11509008-development","dir":"Changelog","previous_headings":"","what":"TreeTools 1.15.0.9008 (development)","title":"TreeTools 1.15.0.9008 (development)","text":"Optimize ClusterTable class.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-11509007-development","dir":"Changelog","previous_headings":"","what":"TreeTools 1.15.0.9007 (development)","title":"TreeTools 1.15.0.9007 (development)","text":"Optimize NSplits().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-11509006-development","dir":"Changelog","previous_headings":"","what":"TreeTools 1.15.0.9006 (development)","title":"TreeTools 1.15.0.9006 (development)","text":"Remove exported C++ cache objects prefer calculation intrinsics.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-11509005-development","dir":"Changelog","previous_headings":"","what":"TreeTools 1.15.0.9005 (development)","title":"TreeTools 1.15.0.9005 (development)","text":"Treeness() computes treeness (=stemminess) tree, proxy phylogenetic signal. LongBranch() identifies long-branched taxa. Add KeepTip() methods correspond DropTip(). Add SplitConsistent() calculate split (dis)agreement. Fix .ClusterTable() leaf order varies. MakeTreeBinary() explicitly removes edge lengths. Fix regressions .ClusterTable() caused downstream errors. Fix regressions PhyToString(). Fix handling multiple ambiguities Reweight().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-1150-2025-07-16","dir":"Changelog","previous_headings":"","what":"TreeTools 1.15.0 (2025-07-16)","title":"TreeTools 1.15.0 (2025-07-16)","text":"CRAN release: 2025-07-21 Reweight() sets weight characters phylogenetic dataset. MatchStrings() checks mismatched tip labels, suggesting corrections. RootTree() gains fallback argument handle outgroups root tree. Fix MakeTreeBinary() labelling trees preorder. Fix .Splits.matrix(tipLabels != NULL). Improve performance PhyToString(). Modernize aspects C++ code.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-1140-2025-05-13","dir":"Changelog","previous_headings":"","what":"TreeTools 1.14.0 (2025-05-13)","title":"TreeTools 1.14.0 (2025-05-13)","text":"CRAN release: 2025-05-13 AddTip(lengthBelow = NA) adds leaf node without adding new edge. BalancedTree() equivalent gain lengths parameter specify edge lengths. Fix taxa misplaced RoguePlot(sort = TRUE). Fix unexpected polytomies Consensus() (#168).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-1131-2025-04-07","dir":"Changelog","previous_headings":"","what":"TreeTools 1.13.1 (2025-04-07)","title":"TreeTools 1.13.1 (2025-04-07)","text":"CRAN release: 2025-04-07 Support non-unique labels DropTip() checks.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-1130-2025-01-09","dir":"Changelog","previous_headings":"","what":"TreeTools 1.13.0 (2025-01-09)","title":"TreeTools 1.13.0 (2025-01-09)","text":"CRAN release: 2025-01-10 %% match methods phylo / multiPhylo objects. Decompose() decomposes additive (ordered) phylogenetic characters binary decomposition. Check overflow splits functions.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-1120-2024-07-25","dir":"Changelog","previous_headings":"","what":"TreeTools 1.12.0 (2024-07-25)","title":"TreeTools 1.12.0 (2024-07-25)","text":"CRAN release: 2024-07-25","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-methods-and-functions-1-12-0","dir":"Changelog","previous_headings":"","what":"New methods and functions","title":"TreeTools 1.12.0 (2024-07-25)","text":"TopologyOnly() removes metadata phylo objects. J1Index() computes robust, universal tree balance measure Lemant et al. 2022 doi:10.1093/sysbio/syac027, incorporating code Rob Noble.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"enhancements-1-12-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeTools 1.12.0 (2024-07-25)","text":"Consistent sequence list entries phylo objects. RandomTree() returns trees < 3 leaves. root_on_node() handles trees < 2 leaves. Support larger trees TotalCopheneticIndex(), fixing #158.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-1111-2024-06-06","dir":"Changelog","previous_headings":"","what":"TreeTools 1.11.1 (2024-06-06)","title":"TreeTools 1.11.1 (2024-06-06)","text":"CRAN release: 2024-06-07 Set random seed increase tolerance avoid false negatives tests.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-1110-2024-05-23","dir":"Changelog","previous_headings":"","what":"TreeTools 1.11.0 (2024-05-23)","title":"TreeTools 1.11.0 (2024-05-23)","text":"CRAN release: 2024-06-05","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-methods-and-functions-1-11-0","dir":"Changelog","previous_headings":"","what":"New methods and functions","title":"TreeTools 1.11.0 (2024-05-23)","text":"YuleTree() generates random tree Yule process. DescendantTips() complements DescendantEdges(), rewritten C++, fixing bug edges preorder. NodeNumbers() returns indices nodes within tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"enhancements-1-11-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeTools 1.11.0 (2024-05-23)","text":"RandomTree(root = TRUE) roots tree random edge. RoguePlot()$legendLabels returns suggested labels legend. Support node labels AddTip(), CollapseNode(), DropTip(), MakeTreeBinary(), Renumber(), Reorder(), SortTree(), Subtree() (#149). AddTip(edgeLength = NULL) defaults lengthBelow. become default future release. entry point C++ function root_on_node() now exported (intended expert use ). Fix handling weighted trees root_on_node(). Use KeepTip() internally SplitFrequency() supports Splits objects documented.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-1100-2023-08-18","dir":"Changelog","previous_headings":"","what":"TreeTools 1.10.0 (2023-08-18)","title":"TreeTools 1.10.0 (2023-08-18)","text":"CRAN release: 2023-08-18","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-methods-and-functions-1-10-0","dir":"Changelog","previous_headings":"","what":"New methods and functions","title":"TreeTools 1.10.0 (2023-08-18)","text":"TipTimedTree() displays trees leaves associated absolute ages. ReadMrBayesTrees() samples trees posterior MrBayes output. .TreeNumber() method.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"improvements-1-10-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"TreeTools 1.10.0 (2023-08-18)","text":"Support zero-edge trees .Splits() NSplits(). Support empty constraints AddUnconstrained(). Add space tokens WriteTntCharacters() support continuous characters (#139).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"deprecations-and-breaking-changes-1-10-0","dir":"Changelog","previous_headings":"","what":"Deprecations and breaking changes","title":"TreeTools 1.10.0 (2023-08-18)","text":"Change order parameters DescendantEdges() Deprecate AllDescendantEdges(); use DescendantEdges() instead. Deprecate EnforceOutgroup(); use RootTree() instead. Remove NonDuplicateRoot() .Splits().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-192-2023-04-25","dir":"Changelog","previous_headings":"","what":"TreeTools 1.9.2 (2023-04-25)","title":"TreeTools 1.9.2 (2023-04-25)","text":"CRAN release: 2023-04-27 Improve support comments ReadNotes(). Support Nexus-escaped ''s ReadCharacters(). Add legend parameter RoguePlot(). RoguePlot() now returns invisibly. Deprecate SpectrumLegend() – spun separate “PlotTools” package.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-191-2023-03-21","dir":"Changelog","previous_headings":"","what":"TreeTools 1.9.1 (2023-03-21)","title":"TreeTools 1.9.1 (2023-03-21)","text":"CRAN release: 2023-03-20 AddUnconstrained() ImposeConstraint() handle wider range inputs. PhyDatToMatrix() can (default ) override levels write ambiguous tokens custom formats {01}. Call C functions using symbols, strings.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-190-2022-11-29","dir":"Changelog","previous_headings":"","what":"TreeTools 1.9.0 (2022-11-29)","title":"TreeTools 1.9.0 (2022-11-29)","text":"CRAN release: 2022-11-28","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-methods-and-functions-1-9-0","dir":"Changelog","previous_headings":"","what":"New methods and functions","title":"TreeTools 1.9.0 (2022-11-29)","text":"ZeroTaxonTree() creates phylo object leaves. DropTip() gains new methods DropTip.list() DropTip.NULL(). .matrix.phylo() converts tree matrix representation, allowing tree passed constraint ImposeConstraint(). .matrix.Splits() .matrix.phyDat() methods added synonyms .logical.Splits() PhyDatToMatrix().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"improvements-1-9-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"TreeTools 1.9.0 (2022-11-29)","text":"Handle TipLabels(0) BalancedTree(0). Support zero-leaf trees .Splits() duplicated.Splits(). Support non-identical tip labels .Splits(). Try Latin-1 encoding ReadCharacters() family fail UTF-8.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-180-2022-09-15","dir":"Changelog","previous_headings":"","what":"TreeTools 1.8.0 (2022-09-15)","title":"TreeTools 1.8.0 (2022-09-15)","text":"CRAN release: 2022-09-15","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-methods-and-functions-1-8-0","dir":"Changelog","previous_headings":"","what":"New methods and functions","title":"TreeTools 1.8.0 (2022-09-15)","text":"TntOrder() renumbers tree’s nodes match TNT’s convention. head() tail() methods Splits objects. Set names splits object names(splits) <- .... .Splits() support character vectors form “…***“.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"improvements-1-8-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"TreeTools 1.8.0 (2022-09-15)","text":"ReadTntTree() reads tree tags follows TNT node numbering conventions. SpectrumLegend() gains title parameter styling options. Support > 32767 trees Consensus() (#127). DropTip() speed improved branch lengths present.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-173-2022-07-20","dir":"Changelog","previous_headings":"","what":"TreeTools 1.7.3 (2022-07-20)","title":"TreeTools 1.7.3 (2022-07-20)","text":"CRAN release: 2022-07-20 ReadTntTree() supports multi-line trees. .MixedBase() supports larger trees (44-32767 tips). Add deprecation warning .Splits().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-172-2022-05-24","dir":"Changelog","previous_headings":"","what":"TreeTools 1.7.2 (2022-05-24)","title":"TreeTools 1.7.2 (2022-05-24)","text":"CRAN release: 2022-05-24 RenumberTips() drops “preorder” attribute, reordering tip labels may break edge ordering guarantee. Native implementation ClusterTable class. Replace throw stop C++ scripts.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-171-2022-03-25","dir":"Changelog","previous_headings":"","what":"TreeTools 1.7.1 (2022-03-25)","title":"TreeTools 1.7.1 (2022-03-25)","text":"CRAN release: 2022-03-25 AddTip(): Fix bug adding tip root weighted tree.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-170-2022-03-21","dir":"Changelog","previous_headings":"","what":"TreeTools 1.7.0 (2022-03-21)","title":"TreeTools 1.7.0 (2022-03-21)","text":"CRAN release: 2022-03-21","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-methods-and-functions-1-7-0","dir":"Changelog","previous_headings":"","what":"New methods and functions","title":"TreeTools 1.7.0 (2022-03-21)","text":"rev.Splits() reverses order splits listed. KeepTip.Splits() faster alternative SubSplit(). %%.Splits() retains names comparing small splits (#40). sort.multiPhylo() sorts lists trees according mixed base representation (#84). Bitwise manipulation splits |, &, xor. .MixedBase() uniquely represents binary trees mixed-base vector. PathLengths() describes paths within tree. KeptVerts() KeptPaths() identify elements reduced trees. PostorderOrder() describes sequence edges corresponding postorder traversal tree. SpectrumLegend() adds gradients plot legends.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"improvements-1-7-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"TreeTools 1.7.0 (2022-03-21)","text":"Improve handling zero-split trees. DropTip() longer adds root unrooted trees, retains edge lengths. Improve speed DropTip(), order magnitude cases. Support edge lengths Preorder(), RootTree(), UnrootTree() Postorder() (#49, #89). Fix bug tree rooted discontinuous outgroup. SortTree() handles weighted non-binary trees (#25, #25), gains option sort tip labels. TipsInSplits(smallest = TRUE) counts tips smaller bipartition. Fix bug phyDat objects ArtificialExtinction(). RenumberTips() allows tipOrder contain elements present tree. Use lighter Rcpp headers. Small improvements computational efficiency.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"deprecations-1-7-0","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"TreeTools 1.7.0 (2022-03-21)","text":"Remove deprecated function PostorderEdges() (#35).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-160-2022-01-12","dir":"Changelog","previous_headings":"","what":"TreeTools 1.6.0 (2022-01-12)","title":"TreeTools 1.6.0 (2022-01-12)","text":"CRAN release: 2022-01-12","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-functions-1-6-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"TreeTools 1.6.0 (2022-01-12)","text":"RoguePlot() plots positions rogue taxa.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"improvements-1-6-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"TreeTools 1.6.0 (2022-01-12)","text":"DropTip() gains check parameter allow slightly faster operation input guaranteed valid. RandomTree() gains nodes parameter allow inclusion polytomies. Infer tips parameter missing StringToPhyDat(). Remove dependency “phangorn” (allowing use R < 4.1) Improve parsing information nexus files. Export DropTipPhylo() wrapper DropTip.phylo().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-151-2021-10-06","dir":"Changelog","previous_headings":"","what":"TreeTools 1.5.1 (2021-10-06)","title":"TreeTools 1.5.1 (2021-10-06)","text":"CRAN release: 2021-10-06 PhyDatToMatrix() optionally encodes ambiguous / inapplicable tokens NA. Implement sort.multiPhylo(). Update test suite compatibility “testthat” > 3.0.4 (@hadley, #83).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-150-2021-09-13","dir":"Changelog","previous_headings":"","what":"TreeTools 1.5.0 (2021-09-13)","title":"TreeTools 1.5.0 (2021-09-13)","text":"CRAN release: 2021-09-08","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-functions-1-5-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"TreeTools 1.5.0 (2021-09-13)","text":"ConstrainedNJ() returns approximation neighbour-joining tree respects constraints. PolarizeSplits() marks specified taxon representing ingroup splits. Add KeepTip() improve performance DropTip(). ImposeConstraint() makes tree consistent topological constraints. .phylo.Splits() represents Splits object tree. Consensus() faster C++ implementation ape::consensus(). ClusterTable() C++ functionality imported “TreeDist”.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"improved-functions-1-5-0","dir":"Changelog","previous_headings":"","what":"Improved functions","title":"TreeTools 1.5.0 (2021-09-13)","text":"Warn empty cells passed MatrixToPhyDat(). Warn LabelSplits(labels) lack names. SplitFrequency() drops tips forest aren’t reference. AddTipEverywhere() supports trees < 3 leaves. Make RootTree() PhyDatToMatrix() robust. Support encoding option ReadCharacters() function family. Support CHARSTATELABELS ReadCharacters(). Support formatting quirks ReadNotes(). Better support ambiguous tokens WriteTntCharacters().","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"optimization-1-5-0","dir":"Changelog","previous_headings":"","what":"Optimization","title":"TreeTools 1.5.0 (2021-09-13)","text":"Fast matching functions “fastmatch”. Improve efficiency Preorder() Postorder(), lift limit tree size.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-145-2021-06-23","dir":"Changelog","previous_headings":"","what":"TreeTools 1.4.5 (2021-06-23)","title":"TreeTools 1.4.5 (2021-06-23)","text":"CRAN release: 2021-06-23 Correct calculation minimum value TCIContext(). Extract tip labels objects StringToPhyDat(). Support AddTip(tree, = \"tip name\"). SplitFrequency() supports four-leaf trees. Add RootTree.matrix() method edge matrices. Add TipLabels.phyDat() method. Add NULL methods tree reordering functions. Additions improvements text parsing functions.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-144-2021-04-23","dir":"Changelog","previous_headings":"","what":"TreeTools 1.4.4 (2021-04-23)","title":"TreeTools 1.4.4 (2021-04-23)","text":"CRAN release: 2021-04-20 Add NTip.phyDat() method. Update MakeTreeBinary() docs tests reflect updated behaviour ape::multi2di() ‘ape’ v5.5.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-143-2021-04-12","dir":"Changelog","previous_headings":"","what":"TreeTools 1.4.3 (2021-04-12)","title":"TreeTools 1.4.3 (2021-04-12)","text":"CRAN release: 2021-04-12 AddTip() supports edge lengths. CladisticInfo() supports Splits objects. .multiPhylo() converts trees, datasets Splits objects multiPhylo objects. LabelSplits(labels = NULL) labels split associated node. PhyDatToMatrix() supports integer-levels. SortTree() supports lists trees. Improvements ReadTntCharacters() character block extraction (#50).","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-142-2021-01-26","dir":"Changelog","previous_headings":"","what":"TreeTools 1.4.2 (2021-01-26)","title":"TreeTools 1.4.2 (2021-01-26)","text":"CRAN release: 2021-01-26 Support star trees RootTree(). Improve memory handling root_on_node(). Documentation linkage.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-141-2020-12-09","dir":"Changelog","previous_headings":"","what":"TreeTools 1.4.1 (2020-12-09)","title":"TreeTools 1.4.1 (2020-12-09)","text":"CRAN release: 2020-12-09 MSTEdges() supports distance matrices > 256 entries. Package ‘vdiffr’ used conditionally.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-140-2020-10-20","dir":"Changelog","previous_headings":"","what":"TreeTools 1.4.0 (2020-10-20)","title":"TreeTools 1.4.0 (2020-10-20)","text":"CRAN release: 2020-10-19","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-functions-1-4-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"TreeTools 1.4.0 (2020-10-20)","text":"MSTLength() reports length minimum spanning tree. AllTipLabels() returns labels trees list. PairwiseDistances() (‘TreeDistData’) computes distances pairs trees list. ArtificialExtinction() gains replaceAll option. WriteTntCharacters(types = ...) writes different character types TNT file. Tree characterization S3 methods: add .default .NULL.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"enhancements-1-4-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeTools 1.4.0 (2020-10-20)","text":"MSTEdges() implemented C++, improving runtime orders magnitude. Improved parsing TNT character files.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-131","dir":"Changelog","previous_headings":"","what":"TreeTools 1.3.1","title":"TreeTools 1.3.1","text":"CRAN release: 2020-10-03 Improved parsing TNT files. Fix misspecified C++ linkage.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-130-2020-09-22","dir":"Changelog","previous_headings":"","what":"TreeTools 1.3.0 (2020-09-22)","title":"TreeTools 1.3.0 (2020-09-22)","text":"CRAN release: 2020-09-22","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-functions-1-3-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"TreeTools 1.3.0 (2020-09-22)","text":"SisterSize() RootNodeDist() measure sister-clade size root-node distance. MSTEdges(): Edges minimum spanning tree. SplitImbalance(): balanced split? New C++ functions root_on_node() root_binary() root trees quickly robustly.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"enhancements-1-3-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeTools 1.3.0 (2020-09-22)","text":"TNTReadTree() handles additional punctuation characters. Import RdMacros package ‘Rdpack’. C++ implementation TipsInSplits(). Export C++ functions preorder_edges_and_nodes() postorder_edges(). Remove obsolete copy C++ code ‘phangorn’.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-120-2020-08-30","dir":"Changelog","previous_headings":"","what":"TreeTools 1.2.0 (2020-08-30)","title":"TreeTools 1.2.0 (2020-08-30)","text":"CRAN release: 2020-08-03 ArtificialExtinction(): Remove characters absent fossil template. WriteTntCharacters(): Write morphological dataset TNT format. Improve TNT dataset parsing. Documentation improvements.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-110-2020-07-07","dir":"Changelog","previous_headings":"","what":"TreeTools 1.1.0 (2020-07-07)","title":"TreeTools 1.1.0 (2020-07-07)","text":"CRAN release: 2020-07-07","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-functions-1-1-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"TreeTools 1.1.0 (2020-07-07)","text":"RandomTree(): Draw tree uniform distribution, instead via ape::rtree(). MakeTreeBinary(): Uniform equivalent ape::multi2di(). match.list() method lists splits. SplitsInBinaryTree(): many splits occur n-leaf binary tree? vapply64(), sapply64(), replicate64(): helper functions function returns 64-bit integer.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"enhancements-1-1-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeTools 1.1.0 (2020-07-07)","text":"Use methods UnrootTree(), RootTree(), RootOnNode() support lists trees.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-100-2020-06-08","dir":"Changelog","previous_headings":"","what":"TreeTools 1.0.0 (2020-06-08)","title":"TreeTools 1.0.0 (2020-06-08)","text":"CRAN release: 2020-06-08","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"new-functions-1-0-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"TreeTools 1.0.0 (2020-06-08)","text":"CladisticInfo(): Calculate information content tree. RootNode(): node tree’s root? UnrootTree(): Safely remove root node. NodeDepth(): Discriminate shallow deep nodes. NodeOrder(), NDescendants(): Count edges incident node. CladeSizes(): Count leaves / nodes descended node. ListAncestors(): List ancestors node. LabelSplits(): Label splits plotted tree. DropTip(): Remove tip, handling weird node orders. LeafLabelInterchange(): Exchange position n tips. StarTree(): Generate unresolved tree. TotalCopheneticIndex() integrated ‘tci’ package.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"deprecations-1-0-0","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"TreeTools 1.0.0 (2020-06-08)","text":"PostorderEdges(): use Postorder() instead. NonDuplicateRoot(): unused internal function. match.Splits(): use match() instead. .Splits(): use %%.Splits() instead.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"enhancements-1-0-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"TreeTools 1.0.0 (2020-06-08)","text":"Improve support unrooted trees .Splits(). Use methods Reorder functions can handle multiPhylo objects edges. Handle funny node orders. Support continuous characters ReadCharacters(). Improve performance .logical.Splits() related functions. Fail nicely trees large memory. Fix memory leak .Splits(). Various --hood improvements functions. Documentation improvements.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-014-2020-03-04","dir":"Changelog","previous_headings":"","what":"TreeTools 0.1.4 (2020-03-04)","title":"TreeTools 0.1.4 (2020-03-04)","text":"CRAN release: 2020-03-04 Catch hang-inducing bugs RootOnNode(). Update doubleFactorials cache fix .integer() rounding error. Support unrooted trees AddTipEverywhere(). Documentation improvements.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-013-2020-01-07","dir":"Changelog","previous_headings":"","what":"TreeTools 0.1.3 (2020-01-07)","title":"TreeTools 0.1.3 (2020-01-07)","text":"CRAN release: 2019-12-19 RootOnNode(): Quickly root tree specified node. Improve portability C++ code.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-012-2020-12-18","dir":"Changelog","previous_headings":"","what":"TreeTools 0.1.2 (2020-12-18)","title":"TreeTools 0.1.2 (2020-12-18)","text":"CRAN release: 2019-12-18 .Newick: Fast conversion Newick format. .TreeNumber: Tree shape enumeration.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-011","dir":"Changelog","previous_headings":"","what":"TreeTools 0.1.1","title":"TreeTools 0.1.1","text":"Add functions translate trees mixed base integers. RenumberTips can extract tip order phylo Splits objects. Documentation changes satisfy CRAN submission requirements.","code":""},{"path":"https://ms609.github.io/TreeTools/dev/news/index.html","id":"treetools-010-2019-10-30","dir":"Changelog","previous_headings":"","what":"TreeTools 0.1.0 (2019-10-30)","title":"TreeTools 0.1.0 (2019-10-30)","text":"Pre-release version spun ‘TreeSearch’ package. functionality subject change.","code":""}]
